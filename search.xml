<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用oneindex+OneDrive搭建私人网盘</title>
    <url>/2021/01/create-personal-network-disk-by-oneindex/</url>
    <content><![CDATA[<p>抛弃x度，拥抱OneDrive。</p>
<span id="more"></span>
<h2 id="使用宝塔创建一个网站"><a class="header-anchor" href="#使用宝塔创建一个网站">¶</a>使用宝塔创建一个网站</h2>
<p>创建网站的目的是为了通过域名访问网站。当然，也可以不创建网站，直接通过IP地址访问。</p>
<p>如果没有宝塔，建议先安装一个，也可以手动改Apache或Nginx的的配置文件。</p>
<p>宝塔新建网站的步骤，略…</p>
<h2 id="部署oneindex源码"><a class="header-anchor" href="#部署oneindex源码">¶</a>部署oneindex源码</h2>
<p>执行下列shell指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /path/to/site_root</span><br><span class="line">rm -rf index.html 404.html</span><br><span class="line">curl https://raw.githubusercontent.com/pkemb/oneindex/master/create_oneindex_site.sh | bash</span><br></pre></td></tr></table></figure>
<h2 id="访问网站设置key"><a class="header-anchor" href="#访问网站设置key">¶</a>访问网站设置key</h2>
<p>略…</p>
<h2 id="伪静态"><a class="header-anchor" href="#伪静态">¶</a>伪静态</h2>
<p>如果想去掉URL中的问号，首先进入后台管理，在基本设置中，开启下图所示的选项。</p>
<img src="https://image.pkemb.com/image/202111302136408.png"/>
<p>然后进入宝塔的网站设置页面，在伪静态填入如下内容。</p>
<img src="https://image.pkemb.com/image/202111302135059.png"/>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">set $rule_0 1$rule_0;</span><br><span class="line">&#125;</span><br><span class="line">if (!-d $request_filename)&#123;</span><br><span class="line">set $rule_0 2$rule_0;</span><br><span class="line">&#125;</span><br><span class="line">if ($rule_0 = &quot;21&quot;)&#123;</span><br><span class="line">rewrite ^/(.*)$ /index.php?/$1 last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定时刷新"><a class="header-anchor" href="#定时刷新">¶</a>定时刷新</h2>
<p>宝塔添加一个定时任务，类型选择shell脚本，脚本内容如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php /path/to/site/one.php cache:refresh</span><br></pre></td></tr></table></figure>
<h2 id="reply-URL错误"><a class="header-anchor" href="#reply-URL错误">¶</a>reply URL错误</h2>
<p>如果绑定账号时出现下面的错误，说明oneindex设置的redirect_uri与APP设置的url不一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AADSTS50011: The reply URL specified in the request does not match the reply urls configured for the application</span><br></pre></td></tr></table></figure>
<p>查看文件<code>controller/AdminController.php</code>第186行，查看oneindex的设置。访问<code>azure.com</code>，更改APP的重定向URL。</p>
<p><img src="https://image.pkemb.com/image/20210801110101.png" alt=""></p>
<h2 id="持续运行一段时间后无法获取文件"><a class="header-anchor" href="#持续运行一段时间后无法获取文件">¶</a>持续运行一段时间后无法获取文件</h2>
<p>类似于下图的情况，网站可以访问，但是看不到任何文件。</p>
<p><img src="https://image.pkemb.com/image/20210801110412.png" alt=""></p>
<p>经过一番搜索，找到<a href="https://www.fanyaozu.com/1347.html">一篇博客</a>，经过分析，原因是<code>refreshtoken</code>没有更新。解决方法是修改<code>lib/onedrive.php</code>，添加一行<code>config('refresh_token', $token['refresh_token']);</code>。</p>
<img src="https://image.pkemb.com/image/202202152100899.png"/>]]></content>
      <tags>
        <tag>OneDrive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/hello-world/</url>
    <content><![CDATA[<p>hello HEXO!!! 终于搭建好自己的个人网站了！！！</p>
<span id="more"></span>
<p>我很早之前就开始折腾域名、云主机、建站等等东西了，一直想搭建一个个人网站。但是比较懒，时间久了也就慢慢没有维护了。这次终于下定决心一直维护下去，并且选择了一个对资金要求不高、数据管理方便的方案。</p>
<p>现在个人搭建网站，主要有如下方案：</p>
<ul>
<li>云主机 + WordPress（或其他博客方案）</li>
<li>内网穿透 + WordPress（或其他博客方案）</li>
<li>基于GitHub pages服务的静态网页</li>
</ul>
<p>方案1的成本较高（云主机+域名），对技术（运维+Web）的要求也比较高。如果不能依靠网站获取现金流，还是比较肉疼的。对于学生来说，可以考虑购买学生机。但是，毕业后学生机到期，数据迁移并重新建站是个大问题。</p>
<p>方案2相对于方案1，主要区别是将云主机换成物理机，利用ngrok将自己的内网网站穿透到公网。此方案前期设备投资较大，后期维护投资较小（电费+域名）。但是对运维的要求更高了，除了软件的维护，还包括硬件的维护。内网穿透服务可以自建（需要云主机）或购买现有的穿透服务。</p>
<p>方案3的成本最低，甚至可以做到0成本。数据管理基于github repo，非常便于迁移。网站数据存储在github repo，无需运维，无需准备主机。由于是静态网页，需要外挂评论，编辑博客时无法做到实时预览。</p>
<p>本站使用的是方案3，Github pages + Hexo, NexT主题，Github Actions实现自动部署。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux Shell指令</title>
    <url>/2021/01/linux-shell/</url>
    <content><![CDATA[<p>当初开始学习Linux shell指令时做的笔记，现在迁移到自己的博客网站。包括常用的shell指令以及对应的常用选项和示例。注意，这只是一份快速参考，有关shell指令更详细的信息，请参考<code>man</code>文档。</p>
<span id="more"></span>
<h2 id="文件处理命令"><a class="header-anchor" href="#文件处理命令">¶</a>文件处理命令</h2>
<h3 id="touch"><a class="header-anchor" href="#touch">¶</a>touch</h3>
<p>创建空文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建文件 /path/to/file，如果文件存在，则会更新文件时间。</span></span><br><span class="line">touch /path/to/file</span><br></pre></td></tr></table></figure>
<h3 id="cat"><a class="header-anchor" href="#cat">¶</a>cat</h3>
<p>查看文件内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /path/to/file</span><br><span class="line">cat -n file # 显示行号</span><br><span class="line">cat -A file # 显示控制字符</span><br></pre></td></tr></table></figure>
<h3 id="tac"><a class="header-anchor" href="#tac">¶</a>tac</h3>
<p>反向显示文件内容，即先输出最后一行。</p>
<h3 id="more"><a class="header-anchor" href="#more">¶</a>more</h3>
<p>分页显示文件内容，但是不可以向上翻页。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">more /path/to/file</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>交互命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>space 或 f</td>
<td>翻页</td>
</tr>
<tr>
<td>enter</td>
<td>换行</td>
</tr>
<tr>
<td>q 或 Q</td>
<td>退出</td>
</tr>
<tr>
<td>/</td>
<td>搜索</td>
</tr>
</tbody>
</table>
<h3 id="less"><a class="header-anchor" href="#less">¶</a>less</h3>
<p>分页显示文件内容，可以向上翻页。其余与<a href="#more">more</a>指令相同。</p>
<h3 id="head"><a class="header-anchor" href="#head">¶</a>head</h3>
<p>显示文件前面几行，默认只显示10行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head /path/to/file</span><br><span class="line">head -n 15 /path/to/file # 显示前15行</span><br><span class="line">head -n -15 /path/to/file # 最后的15行不显示</span><br></pre></td></tr></table></figure>
<h3 id="tail"><a class="header-anchor" href="#tail">¶</a>tail</h3>
<p>显示文件的最后几行，默认只显示10行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n 15 /path/to/file # 显示最后15行</span><br><span class="line">tail -n +15 /path/to/file # 从第15行开始显示到最后一行</span><br><span class="line">tail -f /path/to/file # 动态追加文件的内容，可用于日志的实时查看</span><br></pre></td></tr></table></figure>
<h3 id="ln"><a class="header-anchor" href="#ln">¶</a>ln</h3>
<p>创建软链接或硬链接文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln source_file hardlink_file</span><br><span class="line">ln -s source_file softlink_file</span><br></pre></td></tr></table></figure>
<p>软链接：</p>
<p>硬链接：</p>
<h3 id="rename"><a class="header-anchor" href="#rename">¶</a>rename</h3>
<p>批量重命名。</p>
<ul>
<li>-n 只显示将被重命名的文件，而非实际进行重命名操作。</li>
<li>-v 打印被成功重命名的文件</li>
<li>-f 覆盖已经存在的文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将所有文件的文件名中的所有str1替换为str2。g表示全部匹配，否则只匹配第一个。</span></span><br><span class="line">rename &#x27;s/str1/str2/g&#x27; *</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有文件文件名中的str1</span></span><br><span class="line">rename &#x27;s/str1//g&#x27; *</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有文件的文件名添加前缀 prefix_</span></span><br><span class="line">rename &#x27;s/^/prefix_/&#x27; *</span><br></pre></td></tr></table></figure>
<h2 id="目录处理命令"><a class="header-anchor" href="#目录处理命令">¶</a>目录处理命令</h2>
<h3 id="ls"><a class="header-anchor" href="#ls">¶</a>ls</h3>
<p>显示目录文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [-aAldi] /path/to/file</span><br></pre></td></tr></table></figure>
<ul>
<li>-a 显示所有文件，包括隐藏文件。</li>
<li>-A 显示所有文件，不包括 . 和 …</li>
<li>-l 显示详细信息。</li>
<li>-d 显示目录本身的信息，而不是此目录下的文件。</li>
<li>-i 查看i节点</li>
</ul>
<h3 id="mkdir"><a class="header-anchor" href="#mkdir">¶</a>mkdir</h3>
<p>创建目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir [-p] /path/to/dir</span><br></pre></td></tr></table></figure>
<ul>
<li>-p 递归创建。如果父目录不存在，则先创建父目录，再创建子目录。</li>
</ul>
<h3 id="cd"><a class="header-anchor" href="#cd">¶</a>cd</h3>
<p>切换当前工作目录。这是一个shell内置命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /path/to/dir # 切换到指定目录</span><br><span class="line">cd # 不加任何选项，默认回到家目录</span><br><span class="line">cd ~ # ~ 表示家目录</span><br><span class="line">cd - # 回到上一个工作目录</span><br><span class="line">cd .. # 回到上一级目录</span><br></pre></td></tr></table></figure>
<h3 id="pwd"><a class="header-anchor" href="#pwd">¶</a>pwd</h3>
<p>打印当前工作目录，绝对路径。</p>
<h3 id="basename"><a class="header-anchor" href="#basename">¶</a>basename</h3>
<p>去除文件名的目录和前缀。编写shell脚本时非常有用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">basename</span> /path/to/filename</span></span><br><span class="line">filename</span><br></pre></td></tr></table></figure>
<h3 id="dirname"><a class="header-anchor" href="#dirname">¶</a>dirname</h3>
<p>去除文件名的最后一个部分，即得到文件所在路径。编写shell脚本时非常有用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dirname</span> /path/to/filename</span></span><br><span class="line">/path/to</span><br></pre></td></tr></table></figure>
<h3 id="rmdir"><a class="header-anchor" href="#rmdir">¶</a>rmdir</h3>
<p>删除空目录，实际几乎用不到。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir /path/to/dir</span><br></pre></td></tr></table></figure>
<h3 id="cp"><a class="header-anchor" href="#cp">¶</a>cp</h3>
<p>复制文件或目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp [-rpf] source destination</span><br></pre></td></tr></table></figure>
<ul>
<li>-r 递归复制文件夹。复制文件夹时不带此选项会报错。</li>
<li>-p 保留文件属性。</li>
<li>-f 强制复制。</li>
</ul>
<p>注：如果destination不存在，但父目录存在，则会更改名字。</p>
<h3 id="mv"><a class="header-anchor" href="#mv">¶</a>mv</h3>
<p>移动文件或更改文件名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv source destination</span><br></pre></td></tr></table></figure>
<p>注：如果destination不存在，但父目录存在，则是更改文件名。</p>
<h3 id="rm"><a class="header-anchor" href="#rm">¶</a>rm</h3>
<p>删除文件或目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm [-rf] /path/to/file</span><br></pre></td></tr></table></figure>
<ul>
<li>-r 递归删除</li>
<li>-f 强制删除。否则，可能会逐个文件确认是否删除。</li>
</ul>
<p>注意，<code>rm -rf /*</code>是个非常非常非常<code>可怕</code>的指令。如果感兴趣，可以在虚拟机上做个试验，记得提前拍个快照。</p>
<h2 id="权限管理命令"><a class="header-anchor" href="#权限管理命令">¶</a>权限管理命令</h2>
<h3 id="chmod"><a class="header-anchor" href="#chmod">¶</a>chmod</h3>
<p>更改文件或目录的权限。只有文件的所有者和root用户才能执行此操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] filename [-R]</span><br><span class="line">chmod [权限的数字表示] filename [-R]</span><br></pre></td></tr></table></figure>
<ul>
<li>-R 递归修改</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod g+w,o-r filename # 所属用户组添加写权限，其他用户去除读权限</span><br><span class="line">chmod g=rwx * -R # 修改当前目录下所有文件的用户组权限为rwx</span><br><span class="line">chmod 755 filename # 设置文件权限为755</span><br></pre></td></tr></table></figure>
<p>在Linux下，文件的权限可以用数字来表示。即<code>rwxrw-r--</code>也可以用<code>764</code>来表示。注意，这是八进制。</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>八进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>4</td>
<td>100</td>
</tr>
<tr>
<td>w</td>
<td>2</td>
<td>010</td>
</tr>
<tr>
<td>x</td>
<td>1</td>
<td>001</td>
</tr>
</tbody>
</table>
<p>同样的权限，对文件和目录可能有不同的意义。下表总结了权限所代表的意义。</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的意义</th>
<th>对目录的意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r，读</td>
<td>可以查看文件的内容<br>cat/more/head/less</td>
<td>可以列出目录中的文件<br>ls</td>
</tr>
<tr>
<td>w，写</td>
<td>可以修改文件<br>vim</td>
<td>可以在目录创建修改文件<br>touch/mkdir/rmdir/rm</td>
</tr>
<tr>
<td>x，执行</td>
<td>可以执行文件</td>
<td>可以进入目录<br>cd</td>
</tr>
</tbody>
</table>
<p>注：</p>
<ol>
<li>对目录，<code>rx</code>权限一般都有。</li>
<li>是否可以删除一个文件，是看目录有没有<code>w</code>权限，而不是看文件是否有<code>w</code>权限。</li>
<li>权限有继承关系，如果对一个文件有相应的权限，而对目录没有，一样无法查看或执行。</li>
</ol>
<h3 id="chown"><a class="header-anchor" href="#chown">¶</a>chown</h3>
<p>更改文件的所有者。只有root用户才可以更改文件的所有者。可以使用sudo暂时提升权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [用户名] [文件名] [-R]</span><br></pre></td></tr></table></figure>
<ul>
<li>-R 递归修改</li>
</ul>
<h3 id="chgrp"><a class="header-anchor" href="#chgrp">¶</a>chgrp</h3>
<p>更改文件的所属组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chgrp [用户组] [文件名] [-R]</span><br></pre></td></tr></table></figure>
<ul>
<li>-R 递归修改</li>
</ul>
<p>注：chown可以在更改文件所有者的同时修改文件所属组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown user:grp filename # 文件的所有者更改为user，所属组更改为grp</span><br></pre></td></tr></table></figure>
<h3 id="umask"><a class="header-anchor" href="#umask">¶</a>umask</h3>
<p>显示、设置新建文件的权限掩码。这是一个shell内置命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umask [-S]</span><br></pre></td></tr></table></figure>
<ul>
<li>-S 已rwx形式显示新建文件的默认权限。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span></span></span><br><span class="line">0022  # 实际权限的补码</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span> -S</span></span><br><span class="line">u=rwx,g=rx,o=rx</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span> 027</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span> -S</span></span><br><span class="line">u=rwx,g=rx,o=</span><br></pre></td></tr></table></figure>
<p>注意：为了安全考虑，无论权限掩码如何设置，新建的文件是不具有x权限的。</p>
<h2 id="搜索命令"><a class="header-anchor" href="#搜索命令">¶</a>搜索命令</h2>
<h3 id="find"><a class="header-anchor" href="#find">¶</a>find</h3>
<p>最常用的文件搜索命令，但是比较慢。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /etc -name init # 在/etc目录下查找名为init的文件</span><br><span class="line">find /etc -name *init* # 模糊搜索，&#x27;*&#x27;匹配0个或多个字符</span><br><span class="line">find /etc -name init??? # &#x27;?&#x27;匹配单个字符</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在根目录下查找大于100MB的文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">+n 大于，-n 小于，n 等于</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单位是数据块，一个数据块等于512字节。</span></span><br><span class="line">find / -size +204800</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/home目录下查找所有者为username的文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-group 根据所属组查找</span></span><br><span class="line">find /home -user username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/etc下查找5分钟内被修改过属性的文件，+5表示超过5分钟</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-amin 访问时间，access</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-cmin 文件属性改变时间 change</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-mmin 文件内容改变时间 modify</span></span><br><span class="line">find /etc -cmin -5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/etc目录下查找普通文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">f 文件，d 目录，l 软链接</span></span><br><span class="line">find /etc -type f</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">条件组合</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a 与，-o 或，! 排除</span></span><br><span class="line">find /etc -size +163840 -a -size -204800</span><br><span class="line">find /etc -type f ! -name *.conf # 在/etc目录下查找所有不以conf结尾的普通文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找文件后执行指定的shell指令，&#123;&#125; 指代文件名</span></span><br><span class="line">find /etc -name init -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h3 id="locate"><a class="header-anchor" href="#locate">¶</a>locate</h3>
<p>在数据库中查找文件，速度快，但是新创建的文件可能没有收录到数据库。可以使用指令<code>updatedb</code>更新数据库。<br>
选项：</p>
<ul>
<li>-i 忽略大小写</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate filename # 查找名为filename的文件</span><br></pre></td></tr></table></figure>
<h3 id="which"><a class="header-anchor" href="#which">¶</a>which</h3>
<p>which command_name</p>
<p>搜索命令所在路径及别名信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找<span class="built_in">which</span>命令所在的路径</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> <span class="built_in">which</span></span></span><br><span class="line">alias which=&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</span><br><span class="line">        /usr/bin/alias</span><br><span class="line">        /usr/bin/which</span><br></pre></td></tr></table></figure>
<h3 id="whereis"><a class="header-anchor" href="#whereis">¶</a>whereis</h3>
<p>whichis command_name</p>
<p>搜索命令所在目录及帮助文档路径。</p>
<h3 id="type"><a class="header-anchor" href="#type">¶</a>type</h3>
<p>type command_name</p>
<p>查看命令的类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# type type</span><br><span class="line">type is a shell builtin</span><br><span class="line">[root@localhost ~]# type cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">[root@localhost ~]# type ls</span><br><span class="line">ls is aliased to `ls --color=auto&#x27;</span><br><span class="line">[root@pkserver ~]#</span><br></pre></td></tr></table></figure>
<h3 id="grep"><a class="header-anchor" href="#grep">¶</a>grep</h3>
<p>grep [选项] [字符串] [文件]</p>
<p>在文件中搜索字符串匹配的行并输出。</p>
<p>选项：</p>
<ul>
<li>-i 不区分大小写</li>
<li>-n 输出行号</li>
<li>-s 不输出报错信息</li>
<li>-w 整词匹配</li>
<li>-v 排除指定字符串，即输出不匹配的行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不显示 <span class="comment"># 号开头的行。^ 表示匹配行首。</span></span></span><br><span class="line">grep -v ^# /etc/inittab</span><br></pre></td></tr></table></figure>
<h2 id="帮助命令"><a class="header-anchor" href="#帮助命令">¶</a>帮助命令</h2>
<h3 id="man"><a class="header-anchor" href="#man">¶</a>man</h3>
<p>man [section] page</p>
<p>查看帮助手册。为了快速定位，man将手册分为9个section，说明如下表所示。</p>
<table>
<thead>
<tr>
<th>section number</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Executable programs or shell commands</td>
</tr>
<tr>
<td>2</td>
<td>System calls (functions provided by the kernel)</td>
</tr>
<tr>
<td>3</td>
<td>Library calls (functions within program libraries)</td>
</tr>
<tr>
<td>4</td>
<td>Special files (usually found in /dev)</td>
</tr>
<tr>
<td>5</td>
<td>File formats and conventions eg /etc/passwd</td>
</tr>
<tr>
<td>6</td>
<td>Games</td>
</tr>
<tr>
<td>7</td>
<td>Miscellaneous (including macro packages and conventions), e.g. man(7),groff(7)</td>
</tr>
<tr>
<td>8</td>
<td>System administration commands (usually only for root)</td>
</tr>
<tr>
<td>9</td>
<td>Kernel routines [Non standard]</td>
</tr>
</tbody>
</table>
<h3 id="info"><a class="header-anchor" href="#info">¶</a>info</h3>
<p>与man类似，只是显示内容的形式不一样。</p>
<h3 id="help"><a class="header-anchor" href="#help">¶</a>help</h3>
<p>help command_name</p>
<p>查看shell内置命令的帮助。</p>
<h3 id="whatis"><a class="header-anchor" href="#whatis">¶</a>whatis</h3>
<p>whatis command_name</p>
<p>查看命令的简短信息。</p>
<h2 id="压缩解压命令"><a class="header-anchor" href="#压缩解压命令">¶</a>压缩解压命令</h2>
<h3 id="gzip"><a class="header-anchor" href="#gzip">¶</a>gzip</h3>
<p>gzip filename</p>
<p>将文件压缩成<code>filename.gz</code>，会删除源文件。只能压缩当个文件，不能压缩文件夹。</p>
<h3 id="gunzip"><a class="header-anchor" href="#gunzip">¶</a>gunzip</h3>
<p>gunzip filename.gz</p>
<p>解压缩，与<code>gzip -d</code>可以达到同样的效果。</p>
<h3 id="tar"><a class="header-anchor" href="#tar">¶</a>tar</h3>
<table>
<thead>
<tr>
<th>格式</th>
<th>压缩</th>
<th>解压</th>
</tr>
</thead>
<tbody>
<tr>
<td>tar</td>
<td>tar -cf file.tar filelist</td>
<td>tar -xf file.tar</td>
</tr>
<tr>
<td>tar.gz</td>
<td>tar -czf file.tar.gz filelist</td>
<td>tar -xzf file.tar.gz</td>
</tr>
<tr>
<td>tar.bz2</td>
<td>tar -cjf file.tar.bz2 filelist</td>
<td>tar -xjf file.tar.bz2</td>
</tr>
<tr>
<td>tar.Z</td>
<td>tar -cZf file.tar.Z filelist</td>
<td>tar -xZf file.tar.Z</td>
</tr>
</tbody>
</table>
<p>选项说明：</p>
<ul>
<li>-c 打包，但是不压缩</li>
<li>-x 解包</li>
<li>-f 指定文件名</li>
<li>-z tar.gz格式</li>
<li>-j tar.bz2格式</li>
<li>-Z tar.Z格式</li>
<li>-v 显示详细信息</li>
<li>-C 指定解压文件存放的目录</li>
</ul>
<h3 id="zip"><a class="header-anchor" href="#zip">¶</a>zip</h3>
<p>压缩成zip格式。</p>
<p>zip -r 压缩后的文件名 文件或目录</p>
<h3 id="unzip"><a class="header-anchor" href="#unzip">¶</a>unzip</h3>
<p>解压zip文件。</p>
<p>unzip file.zip</p>
<h2 id="网络命令"><a class="header-anchor" href="#网络命令">¶</a>网络命令</h2>
<h3 id="write"><a class="header-anchor" href="#write">¶</a>write</h3>
<h3 id="wall"><a class="header-anchor" href="#wall">¶</a>wall</h3>
<h3 id="ping"><a class="header-anchor" href="#ping">¶</a>ping</h3>
<h3 id="ifconfig"><a class="header-anchor" href="#ifconfig">¶</a>ifconfig</h3>
<h3 id="mail"><a class="header-anchor" href="#mail">¶</a>mail</h3>
<h3 id="traceroute"><a class="header-anchor" href="#traceroute">¶</a>traceroute</h3>
<h3 id="netstat"><a class="header-anchor" href="#netstat">¶</a>netstat</h3>
<h2 id="系统维护命令"><a class="header-anchor" href="#系统维护命令">¶</a>系统维护命令</h2>
<h3 id="last"><a class="header-anchor" href="#last">¶</a>last</h3>
<p>列出目前与过去登入系统的用户信息。每个用户的每次登录都会产生一个条目。</p>
<h3 id="lastlog"><a class="header-anchor" href="#lastlog">¶</a>lastlog</h3>
<p>检查特定用户上次登录的时间。</p>
<p>lastlog [-u uid]</p>
<h3 id="mount"><a class="header-anchor" href="#mount">¶</a>mount</h3>
<p>挂载文件系统。</p>
<p>mount [-t type] [-o opt] device mount_point</p>
<ul>
<li>mount -t iso9660 /dev/sr0 /mnt/chrom # 挂载光盘</li>
<li>mount -t cifs //hostname/dirname /mountpoint -o username=name # 挂载samba</li>
<li>mount -o remount,rw /mountpoint # 重新挂载为可读写</li>
</ul>
<h3 id="umount"><a class="header-anchor" href="#umount">¶</a>umount</h3>
<p>取消挂载。</p>
<p>umount 设备文件名或挂载点</p>
<h3 id="shutdown"><a class="header-anchor" href="#shutdown">¶</a>shutdown</h3>
<h3 id="logout"><a class="header-anchor" href="#logout">¶</a>logout</h3>
<h3 id="who"><a class="header-anchor" href="#who">¶</a>who</h3>
<p>查看登录用户信息。</p>
<h3 id="w"><a class="header-anchor" href="#w">¶</a>w</h3>
<p>查看登录用户详细信息。</p>
<h3 id="whoami"><a class="header-anchor" href="#whoami">¶</a>whoami</h3>
<p>查看自己的用户名。</p>
<h3 id="df"><a class="header-anchor" href="#df">¶</a>df</h3>
<p>查看分区的信息，包括文件系统、已用空间、可用空间、总空间、挂载点等。</p>
<p>df [-mgh] [mountpoint]</p>
<ul>
<li>-m 单位是MB</li>
<li>-g 单位是GB</li>
<li>-h 人性化显示，自动选择合适的单位</li>
</ul>
<h3 id="du"><a class="header-anchor" href="#du">¶</a>du</h3>
<p>查看文件或文件夹的大小。</p>
<h3 id="uptime"><a class="header-anchor" href="#uptime">¶</a>uptime</h3>
<p>查看系统连续运行的时间。</p>
<h3 id="runlevel"><a class="header-anchor" href="#runlevel">¶</a>runlevel</h3>
<p>查看系统的运行级别。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux, shell</tag>
      </tags>
  </entry>
  <entry>
    <title>文件共享网盘</title>
    <url>/2021/01/personal-netdisk/</url>
    <content><![CDATA[<p>抛弃x度，从你我做起。</p>
<span id="more"></span>
<p>这是一个使用<code>OneDrive + Oneindex</code>搭建的个人网盘。如果以后要分享文件，将会通过这个网盘。可以通过网站顶部的“网盘”菜单进入网盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://share.pkemb.com</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Total Commander</title>
    <url>/2021/01/total-commander/</url>
    <content><![CDATA[<p>total commander（TC），一款功能强大的文件管理器。具有比较高的学习门槛。</p>
<span id="more"></span>
<h2 id="软件下载"><a class="header-anchor" href="#软件下载">¶</a>软件下载</h2>
<p><a href="https://share.pkemb.com/software/tc/">https://share.pkemb.com/software/tc/</a></p>
<h2 id="学习资料"><a class="header-anchor" href="#学习资料">¶</a>学习资料</h2>
<ul>
<li><a href="https://xbeta.info/studytc/index.htm">TC学堂</a>。比较全面的讲述了TC的各项功能，建议边读边操作。一遍是肯定记不住的。</li>
<li><a href="https://blog.csdn.net/fengyie007/article/details/17618073">TC命令行参数</a>。TC的一些常用命令行参数，添加自定义命令时需要用到。</li>
</ul>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用rclone挂载onedriver</title>
    <url>/2020/12/use-rclone-mount-onedriver/</url>
    <content><![CDATA[<p>rclone是一个从云端同步文件的命令行工具，常见的网盘和协议基本上都支持，更加详细的介绍可以查看<a href="https://rclone.org/">官网</a>。这还是一个开源项目，<a href="https://github.com/rclone/rclone">github</a>。</p>
<span id="more"></span>
<h2 id="环境准备"><a class="header-anchor" href="#环境准备">¶</a>环境准备</h2>
<ul>
<li>一台可以正常运行的树莓派</li>
<li><a href="http://www.bt.cn/">宝塔面板</a>
<ul>
<li>新增网站和配置反向代理。如果可以手动配置，也可以不安装。</li>
</ul>
</li>
<li>OneDriver账号，OneDriver个人账户可能无法正常登录，推荐OneDriver for business。</li>
</ul>
<h2 id="安装rclone"><a class="header-anchor" href="#安装rclone">¶</a>安装rclone</h2>
<p>参考文档：<a href="https://rclone.org/downloads/">https://rclone.org/downloads/</a></p>
<p>使用以下命令一键安装。如果因为网速原因导致下载失败，可以参考<a href="https://rclone.org/install.sh">安装脚本</a>的流程，手动下载并安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://rclone.org/install.sh | sudo bash</span><br></pre></td></tr></table></figure>
<p>Ubuntu系统可以直接使用apt安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install rclone</span><br></pre></td></tr></table></figure>
<p>安装完成之后，可以执行以下测试命令，测试是否安装成功。如果提示<code>rclone: command not found</code>，则表示安装失败。否则安装成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rclone --help</span><br></pre></td></tr></table></figure>
<h2 id="rclone配置OneDriver账户"><a class="header-anchor" href="#rclone配置OneDriver账户">¶</a>rclone配置OneDriver账户</h2>
<p>参考文档：<a href="https://rclone.org/onedrive/">https://rclone.org/onedrive/</a></p>
<h3 id="获取客户ID和密码"><a class="header-anchor" href="#获取客户ID和密码">¶</a>获取客户ID和密码</h3>
<p>以下是官方给出的获取步骤，注意保存好客户端ID和密码，关闭页面后将无法再次查看。第5步给API设置的权限，不能少，否则会影响后续对文件的操作。</p>
<blockquote>
<ol>
<li>Open <a href="https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade">https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade</a>, then <code>click New registration</code>.</li>
<li>Enter a name for your app, choose account type <code>Any Azure AD directory - Multitenant</code>, select <code>Web</code> in <code>Redirect URI</code> Enter <code>http://localhost:53682/</code> and click Register. Copy and keep the <code>Application (client) ID</code> under the app name for later use.</li>
<li>Under <code>manage</code> select <code>Certificates &amp; secrets</code>, click <code>New client secret</code>. Copy and keep that secret for later use.</li>
<li>Under <code>manage</code> select <code>API permissions</code>, click <code>Add a permission</code> and select <code>Microsoft Graph</code> then select <code>delegated permissions</code>.</li>
<li>Search and select the follwing permssions: <code>Files.Read</code>, <code>Files.ReadWrite</code>, <code>Files.Read.All</code>, <code>Files.ReadWrite.All</code>, <code>offline_access</code>, <code>User.Read</code>. Once selected click <code>Add permissions</code> at the bottom.</li>
</ol>
</blockquote>
<h3 id="配置反向代理"><a class="header-anchor" href="#配置反向代理">¶</a>配置反向代理</h3>
<p>在配置rclone的过程中，需要弹出浏览器进行认证。由于树莓派没有图形界面，所以需要曲线救国，有三种思路：</p>
<ol>
<li>先在Windows下安装rclone，并配置好OneDrive，获取token。最后在树莓派上使用token设置OneDrive，具体步骤可以参考这篇<a href="https://www.xiaoz.me/archives/10397">博客</a>。</li>
<li>利用反向代理，实现间接访问。需要使用宝塔配置反向代理。</li>
<li>树莓派安装浏览器后通过xserver访问。对机器的性能有一定的要求。</li>
</ol>
<p>配置反向代理的步骤：</p>
<ol>
<li>进入宝塔面板的<code>安全</code>界面，打开<code>53682</code>端口。</li>
<li>进入宝塔面板的<code>网站</code>界面，添加一个站点。假设域名是<code>rclone.pi3b.inc</code>。</li>
<li>点击新增网站的<code>设置</code>按钮，进入<code>反向代理</code>，将网站代理到<code>http://127.0.0.1:53682</code>。<br>
<img src="https://image.pkemb.com/image/20200515231732.png" alt=""></li>
<li>添加域名的DNS解析。</li>
</ol>
<h3 id="rclone链接OneDrive账户"><a class="header-anchor" href="#rclone链接OneDrive账户">¶</a>rclone链接OneDrive账户</h3>
<p>在终端输入<code>rclone config</code>，进入配置界面。这里选择<code>n</code>，创建一个新的remote。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rclone config</span></span><br><span class="line">2021/10/02 02:33:08 NOTICE: Config file &quot;/home/pk/.config/rclone/rclone.conf&quot; not found - using defaults</span><br><span class="line">No remotes found - make a new one</span><br><span class="line">n) New remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line"><span class="meta prompt_">n/s/q&gt; </span><span class="language-bash">n</span></span><br></pre></td></tr></table></figure>
<p>输入<code>n</code>之后点击回车，这时要为remote设置一个名字。后续的操作都是通过此name要完成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">n/s/q&gt; </span><span class="language-bash">n</span></span><br><span class="line"><span class="meta prompt_">name&gt; </span><span class="language-bash">remote_name</span></span><br></pre></td></tr></table></figure>
<p>设置好name之后，点击回车，接下来选项存储类型。<code>rclone</code>支持非常多的存储类型，这里选项<code>Microsoft OneDrive</code>。不同版本的<code>rclone</code>，前面的数字可能不一样，注意不要选错了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Type of storage to configure.</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line">Choose a number from below, or type in your own value</span><br><span class="line">......</span><br><span class="line">26 / Microsoft OneDrive</span><br><span class="line">   \ &quot;onedrive&quot;</span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_">Storage&gt; </span><span class="language-bash">26</span></span><br></pre></td></tr></table></figure>
<p>点击回车后，接着需要输入应用程序ID和密码。如果不知道这两个值，可以往前看看<a href="#%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7ID%E5%92%8C%E5%AF%86%E7%A0%81">获取客户ID和密码</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">Storage&gt; </span><span class="language-bash">26</span></span><br><span class="line">OAuth Client Id</span><br><span class="line">Leave blank normally.</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line"><span class="meta prompt_">client_id&gt; </span><span class="language-bash">xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</span></span><br><span class="line">OAuth Client Secret</span><br><span class="line">Leave blank normally.</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line"><span class="meta prompt_">client_secret&gt; </span><span class="language-bash">xxxxxxxxx</span></span><br></pre></td></tr></table></figure>
<p>选择账户的类型，根据自己的实际情况选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Choose national cloud region for OneDrive.</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;global&quot;).</span><br><span class="line">Choose a number from below, or type in your own value</span><br><span class="line"> 1 / Microsoft Cloud Global</span><br><span class="line">   \ &quot;global&quot;</span><br><span class="line"> 2 / Microsoft Cloud for US Government</span><br><span class="line">   \ &quot;us&quot;</span><br><span class="line"> 3 / Microsoft Cloud Germany</span><br><span class="line">   \ &quot;de&quot;</span><br><span class="line"> 4 / Azure and Office 365 operated by 21Vianet in China</span><br><span class="line">   \ &quot;cn&quot;</span><br><span class="line"><span class="meta prompt_">region&gt; </span><span class="language-bash">1</span></span><br></pre></td></tr></table></figure>
<p>是否需要高级配置，这里选项n。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Edit advanced config?</span><br><span class="line">y) Yes</span><br><span class="line">n) No (default)</span><br><span class="line"><span class="meta prompt_">y/n&gt; </span><span class="language-bash">n</span></span><br></pre></td></tr></table></figure>
<p>选择是否自动配置，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Use auto config?</span><br><span class="line"> * Say Y if not sure</span><br><span class="line"> * Say N if you are working on a remote or headless machine</span><br><span class="line"></span><br><span class="line">y) Yes (default)</span><br><span class="line">n) No</span><br><span class="line"><span class="meta prompt_">y/n&gt; </span><span class="language-bash">y</span></span><br><span class="line">2021/10/02 02:46:56 NOTICE: Make sure your Redirect URL is set to &quot;http://localhost:53682/&quot; in your custom config.</span><br><span class="line">2021/10/02 02:46:56 NOTICE: If your browser doesn&#x27;t open automatically go to the following link: http://127.0.0.1:53682/auth?state=vtjMEdIokDmhiFPM0xa18A</span><br><span class="line">2021/10/02 02:46:56 NOTICE: Log in and authorize rclone for access</span><br><span class="line">2021/10/02 02:46:56 NOTICE: Waiting for code...</span><br></pre></td></tr></table></figure>
<p>需要访问提示信息中出现的网址。将<code>127.0.0.1:53682</code>替换成反向代理的自定义域名，这里是<code>rclone.pi3b.inc</code>，即访问<code>http://rclone.pi3b.inc/auth?state=vtjMEdIokDmhiFPM0xa18A</code>。会出现下图，点击接受。</p>
<img src="https://image.pkemb.com/image/20211002104845.png" style="zoom: 50%;" />
<p>点击接受之后，会跳转到<code>localhost:53682</code>，一样替换成反向代理的域名，这里就授权成功了。</p>
<p><img src="https://image.pkemb.com/image/20211002104912.png" alt=""></p>
<img src="https://image.pkemb.com/image/20211002105010.png" style="zoom: 70%;" />
<p>选择连接的类型，根据自己的实际情况选择即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Type of connection</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;onedrive&quot;).</span><br><span class="line">Choose a number from below, or type in an existing value</span><br><span class="line"> 1 / OneDrive Personal or Business</span><br><span class="line">   \ &quot;onedrive&quot;</span><br><span class="line"> 2 / Root Sharepoint site</span><br><span class="line">   \ &quot;sharepoint&quot;</span><br><span class="line"> 3 / Sharepoint site name or URL (e.g. mysite or https://contoso.sharepoint.com/sites/mysite)</span><br><span class="line">   \ &quot;url&quot;</span><br><span class="line"> 4 / Search for a Sharepoint site</span><br><span class="line">   \ &quot;search&quot;</span><br><span class="line"> 5 / Type in driveID (advanced)</span><br><span class="line">   \ &quot;driveid&quot;</span><br><span class="line"> 6 / Type in SiteID (advanced)</span><br><span class="line">   \ &quot;siteid&quot;</span><br><span class="line"> 7 / Sharepoint server-relative path (advanced, e.g. /teams/hr)</span><br><span class="line">   \ &quot;path&quot;</span><br><span class="line"><span class="meta prompt_">config_type&gt; </span><span class="language-bash">3</span></span><br></pre></td></tr></table></figure>
<p>输入sharepoint网站的url</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Site URL</span><br><span class="line"></span><br><span class="line">Example: &quot;https://contoso.sharepoint.com/sites/mysite&quot; or &quot;mysite&quot;</span><br><span class="line"></span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line"><span class="meta prompt_">config_site_url&gt;</span></span><br></pre></td></tr></table></figure>
<p>后续：略。</p>
<h2 id="rclone操作云端文件"><a class="header-anchor" href="#rclone操作云端文件">¶</a>rclone操作云端文件</h2>
<p><code>rclone</code>支持非常多操作文件的命令，可以<code>rclone -h</code>或<code>man rclone</code>查看帮助。</p>
<h3 id="挂载"><a class="header-anchor" href="#挂载">¶</a>挂载</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装fuse</span></span><br><span class="line">yum -y install fuse</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建挂载目录</span></span><br><span class="line">mkdir -p /home/onedrive</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂载</span></span><br><span class="line">rclone mount remote_name:path/to/files /home/onedrive</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果需要后台保持运行，使用下面的命令</span></span><br><span class="line">nohup rclone mount remote:path/to/files /home/onedrive &amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查挂载是否成功</span></span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p><code>remote_name</code>是设置OneDrive时配置的名字。</p>
<h3 id="复制文件"><a class="header-anchor" href="#复制文件">¶</a>复制文件</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rclone copy source:path dest:path [flags]</span><br></pre></td></tr></table></figure>
<ul>
<li>Use the <code>-P</code>/<code>--progress</code> flag to view real-time transfer statistics.</li>
<li>Use the <code>--dry-run</code> or the <code>--interactive</code>/<code>-i</code> flag to test without copying anything.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ELF分析常用指令</title>
    <url>/2021/05/elf-analysis-command/</url>
    <content><![CDATA[<p>ELF分析常用指令，方便查询。</p>
<span id="more"></span>
<h2 id="按ELF段、表分类"><a class="header-anchor" href="#按ELF段、表分类">¶</a>按ELF段、表分类</h2>
<h3 id="十六进制查看"><a class="header-anchor" href="#十六进制查看">¶</a>十六进制查看</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump elffile -s -j section</span><br><span class="line">readelf elffile -x section</span><br></pre></td></tr></table></figure>
<h3 id="ELF文件头"><a class="header-anchor" href="#ELF文件头">¶</a>ELF文件头</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf elffile -h</span><br></pre></td></tr></table></figure>
<h3 id="section-header-table"><a class="header-anchor" href="#section-header-table">¶</a>section header table</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf elffile -S</span><br><span class="line">objdump elffile -h</span><br></pre></td></tr></table></figure>
<h3 id="program-header-table"><a class="header-anchor" href="#program-header-table">¶</a>program header table</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf execfile -l</span><br></pre></td></tr></table></figure>
<h3 id="符号表"><a class="header-anchor" href="#符号表">¶</a>符号表</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf execfile -s</span><br><span class="line">objdump execfile -t</span><br><span class="line">objdump execfile -T</span><br><span class="line">nm elffile</span><br></pre></td></tr></table></figure>
<p>如果想定位定义符号的文件和行号，可以使用<code>nm -l</code>，需要有debug信息。<code>nm -S</code>打印符号的大小，<code>nm -S --size-sort</code>按大小排序。如果要缩减ELF的大小，这个非常有用。</p>
<h3 id="代码段（反汇编）"><a class="header-anchor" href="#代码段（反汇编）">¶</a>代码段（反汇编）</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump elffile -d -j section_name</span><br><span class="line">gdb elffile -batch -ex &#x27;disassemble function&#x27; # 反汇编指定函数</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/wangzuxi/article/details/41322131">https://blog.csdn.net/wangzuxi/article/details/41322131</a></li>
<li><a href="https://www.nuomiphp.com/eplan/342147.html">https://www.nuomiphp.com/eplan/342147.html</a></li>
</ul>
<h3 id="数据段"><a class="header-anchor" href="#数据段">¶</a>数据段</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump elffile -s -j section</span><br></pre></td></tr></table></figure>
<h3 id="重定位表"><a class="header-anchor" href="#重定位表">¶</a>重定位表</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump elffile -r</span><br><span class="line">objdump elffile -R</span><br><span class="line">readelf elffile -r</span><br></pre></td></tr></table></figure>
<h3 id="字符串表"><a class="header-anchor" href="#字符串表">¶</a>字符串表</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf elffile -p section</span><br></pre></td></tr></table></figure>
<p>字符串表一般是<code>.strtab</code>、<code>.shstrtab</code>、<code>.dnystr</code>。</p>
<h3 id="动态链接表"><a class="header-anchor" href="#动态链接表">¶</a>动态链接表</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf elffile -d</span><br></pre></td></tr></table></figure>
<p>动态链接表指<code>.dynamic</code>段。</p>
<h2 id="按命令分类"><a class="header-anchor" href="#按命令分类">¶</a>按命令分类</h2>
<h3 id="nm"><a class="header-anchor" href="#nm">¶</a>nm</h3>
<p>打印ELF文件的符号，需要有符号表。如果文件被strip了，则无法获取符号。默认按照<code>bsd</code>格式打印，即对每个符号会打印<code>符号地址</code>、<code>符号类型</code>、<code>符号名</code>。符号类型及其说明，参考man手册：<a href="https://www.man7.org/linux/man-pages/man1/nm.1.html%E3%80%82">https://www.man7.org/linux/man-pages/man1/nm.1.html。</a></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nm [option] file...</span><br></pre></td></tr></table></figure>
<p>常用选项：</p>
<ul>
<li>-l 打印定义符号的文件和行号。需要有debug信息。</li>
<li>-n 符号地址按数字顺序排序，而不是字母顺序。</li>
<li>-p / --no-sort 不排序，按照遇到的顺序打印</li>
<li>-S 同时打印符号的地址和大小</li>
<li>–size-sort 按照符号大小排序</li>
<li>-r 反向排序</li>
<li>-t radix 指定进制。<code>d</code>十进制，<code>o</code>八进制，<code>x</code>十六进制。默认<code>x</code>。</li>
</ul>
<p>示例如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认打印符号地址、符号类型、符号名</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm nomain</span></span><br><span class="line">0000000000601000 B __bss_start</span><br><span class="line">0000000000601000 B _edata</span><br><span class="line">0000000000601008 B _end</span><br><span class="line">0000000000000000 B errno</span><br><span class="line">00000000004001c0 T _exit</span><br><span class="line">00000000004001c0 W _Exit</span><br><span class="line">00000000004003ab r __func__.1800</span><br><span class="line">0000000000400350 T __libc_disable_asynccancel</span><br><span class="line">00000000004002f0 T __libc_enable_asynccancel</span><br><span class="line">0000000000000000 B __libc_errno</span><br><span class="line">0000000000601000 B __libc_multiple_threads</span><br><span class="line">0000000000400220 T __libc_write</span><br><span class="line">0000000000400180 T nomain</span><br><span class="line">0000000000400220 W write</span><br><span class="line">0000000000400220 W __write</span><br><span class="line">00000000004002c0 T __write_nocancel</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印符号大小，并按大小排序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm nomain -S --size-sort</span></span><br><span class="line">0000000000000000 0000000000000004 B errno</span><br><span class="line">0000000000000000 0000000000000004 B __libc_errno</span><br><span class="line">0000000000601000 0000000000000004 B __libc_multiple_threads</span><br><span class="line">00000000004003ab 0000000000000007 r __func__.1800</span><br><span class="line">00000000004002c0 000000000000002c T __write_nocancel</span><br><span class="line">0000000000400180 000000000000003a T nomain</span><br><span class="line">00000000004002f0 0000000000000056 T __libc_enable_asynccancel</span><br><span class="line">00000000004001c0 0000000000000058 T _exit</span><br><span class="line">00000000004001c0 0000000000000058 W _Exit</span><br><span class="line">0000000000400350 0000000000000059 T __libc_disable_asynccancel</span><br><span class="line">0000000000400220 0000000000000099 T __libc_write</span><br><span class="line">0000000000400220 0000000000000099 W write</span><br><span class="line">0000000000400220 0000000000000099 W __write</span><br></pre></td></tr></table></figure>
<h3 id="size"><a class="header-anchor" href="#size">¶</a>size</h3>
<p>打印ELF文件每个段的大小和总大小。man手册：<a href="https://www.man7.org/linux/man-pages/man1/size.1.html">size.1.html</a>。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">size [option] file...</span><br></pre></td></tr></table></figure>
<p>常用选项如下：</p>
<ul>
<li>-A 按照SysV格式打印</li>
<li>-B 按照Berkeley格式打印。默认使用Berkeley格式。</li>
<li>-d 按照十进制打印，等同于 <code>--radix=10</code>。默认十进制。</li>
<li>-o 按照八进制打印，等同于 <code>--radix=8</code></li>
<li>-x 按照十六进制打印，等同于 <code>--radix=16</code></li>
<li>-t 显示所有文件的总大小。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SysV 格式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">size nomain -A</span></span><br><span class="line">nomain  :</span><br><span class="line">section              size      addr</span><br><span class="line">.note.gnu.build-id     36   4194648</span><br><span class="line">.text                 553   4194688</span><br><span class="line">.rodata                 9   4195241</span><br><span class="line">.eh_frame             200   4195256</span><br><span class="line">.tbss                   4   6295552</span><br><span class="line">.bss                    8   6295552</span><br><span class="line">.comment               41         0</span><br><span class="line">.debug_aranges         48         0</span><br><span class="line">.debug_info           146         0</span><br><span class="line">.debug_abbrev         106         0</span><br><span class="line">.debug_line            67         0</span><br><span class="line">.debug_str            146         0</span><br><span class="line">Total                1364</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Berkeley格式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">size nomain</span></span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">    798       0      12     810     32a nomain</span><br></pre></td></tr></table></figure>
<h3 id="addr2line"><a class="header-anchor" href="#addr2line">¶</a>addr2line</h3>
<p>将<code>地址</code>或<code>符号+偏移</code>转换为文件名和行号。需要有debug信息。man手册：<a href="https://www.man7.org/linux/man-pages/man1/addr2line.1.html">addr2line.1.html</a>。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">addr2line [option] addr...</span><br></pre></td></tr></table></figure>
<p>常用选项如下：</p>
<ul>
<li>-e filename 指定文件。默认读取<code>a.out</code>文件。</li>
<li>-a 在符号名、文件名、行号之前打印地址。</li>
<li>-f 同时打印函数名</li>
<li>-s / --basename 只打印文件的基本名字，不打印路径</li>
<li>-p 输出更加人性化：每个地址只打印一行</li>
</ul>
<p>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">addr2line -e nomain 400180</span></span><br><span class="line">/devspace/test-api/src/nomain.c:6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印符号所在的函数</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">addr2line -e nomain 400180 -f</span></span><br><span class="line">nomain</span><br><span class="line">/devspace/test-api/src/nomain.c:6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印符号地址</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">addr2line -e nomain 400180 -fa</span></span><br><span class="line">0x0000000000400180</span><br><span class="line">nomain</span><br><span class="line">/devspace/test-api/src/nomain.c:6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将所有内容打印在一行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">addr2line -e nomain 400180 -fap</span></span><br><span class="line">0x0000000000400180: nomain at /devspace/test-api/src/nomain.c:6</span><br></pre></td></tr></table></figure>
<h3 id="objcopy"><a class="header-anchor" href="#objcopy">¶</a>objcopy</h3>
<p>复制和转换目标文件。命令格式如下。如果省略<code>outfile</code>，输出的数据会写入到<code>infile</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objcopy [option] infile [outfile]</span><br></pre></td></tr></table></figure>
<p><code>objcopy</code>的功能非常强大，可以转换文件格式；可以将普通文件转换为目标文件；可以基于<code>section</code>对文件进行编辑，例如新增、删除、更新内容、修改信息（lma、vma等）、重命名等；可以基于<code>symbol</code>对文件进行编辑，例如本地符号和全局符号互相转换，弱符号和强符号互相转换，新增符号等。更详细的信息参考man手册<a href="https://www.man7.org/linux/man-pages/man1/objcopy.1.html">objcopy.1.html</a>。</p>
<p>常用选项：</p>
<ul>
<li>–info 打印支持的架构和文件格式</li>
<li>-I bfdname 指定输入文件的格式，而不是自动检测。BFD是<code>Binary format descriptor</code>的缩写。</li>
<li>-O bfdname 指定输出文件的格式。</li>
<li>-F bfdname 指定输入文件和输出文件的格式。</li>
<li>-B bfdarch 指定架构。通常用于将不含架构信息的文件转换为目标文件，其架构为<code>bfdarch</code>。具体参考后面的示例。</li>
<li>-j sectionpattern 只复制指定的段。支持通配符，如果第一个字符是<code>!</code>，表示匹配的段不复制。这个选项可以指定多次。</li>
<li>-R sectionpattern 将指定的段从输出文件中移除。支持通配符，如果第一个字符是<code>!</code>，表示匹配的段不移除。这个选项可以指定多次。</li>
<li>-S --strip-all 不从源文件复制重定位和符号信息，同时也会删除调试信息。</li>
<li>-g --strip-debug 删除调试信息</li>
</ul>
<p>示例如下：</p>
<h4 id="查询支持的架构和文件格式"><a class="header-anchor" href="#查询支持的架构和文件格式">¶</a>查询支持的架构和文件格式</h4>
<p>首先以列表的形式，列出了文件格式支持的架构。最后以表格的形式，汇总了每种格式支持的架构。行表头是文件格式，列表头是架构。示例输出如下，格式<code>elf32-i386</code>仅支持<code>i386</code>架构。交叉工具链<code>xxx-objcopy --info</code>的输出会有所不同，例如<code>arm-linux-gnueabihf-objcopy</code>支持<code>elf32-littlearm</code>和<code>elf32-bigarm</code>格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objcopy --info</span></span><br><span class="line">BFD header file version (GNU Binutils for Ubuntu) 2.30</span><br><span class="line">elf64-x86-64</span><br><span class="line"> (header little endian, data little endian)</span><br><span class="line">  i386</span><br><span class="line">elf32-i386</span><br><span class="line"> (header little endian, data little endian)</span><br><span class="line">  i386</span><br><span class="line">......</span><br><span class="line">binary</span><br><span class="line"> (header endianness unknown, data endianness unknown)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line">ihex</span><br><span class="line"> (header endianness unknown, data endianness unknown)</span><br><span class="line">  i386</span><br><span class="line">  l1om</span><br><span class="line">  k1om</span><br><span class="line">  iamcu</span><br><span class="line">  plugin</span><br><span class="line"></span><br><span class="line">         elf64-x86-64 elf32-i386 elf32-iamcu elf32-x86-64 a.out-i386-linux</span><br><span class="line">    i386 elf64-x86-64 elf32-i386 ----------- elf32-x86-64 a.out-i386-linux</span><br><span class="line">    l1om ------------ ---------- ----------- ------------ ----------------</span><br><span class="line">    k1om ------------ ---------- ----------- ------------ ----------------</span><br><span class="line">   iamcu ------------ ---------- elf32-iamcu ------------ ----------------</span><br><span class="line">  plugin ------------ ---------- ----------- ------------ ----------------</span><br><span class="line"></span><br><span class="line">         pei-i386 pei-x86-64 elf64-l1om elf64-k1om elf64-little elf64-big</span><br><span class="line">    i386 pei-i386 pei-x86-64 ---------- ---------- elf64-little elf64-big</span><br><span class="line">    l1om -------- ---------- elf64-l1om ---------- elf64-little elf64-big</span><br><span class="line">    k1om -------- ---------- ---------- elf64-k1om elf64-little elf64-big</span><br><span class="line">   iamcu -------- ---------- ---------- ---------- elf64-little elf64-big</span><br><span class="line">  plugin -------- ---------- ---------- ---------- elf64-little elf64-big</span><br><span class="line"></span><br><span class="line">         elf32-little elf32-big pe-x86-64 pe-bigobj-x86-64 pe-i386 plugin srec</span><br><span class="line">    i386 elf32-little elf32-big pe-x86-64 pe-bigobj-x86-64 pe-i386 ------ srec</span><br><span class="line">    l1om elf32-little elf32-big --------- ---------------- ------- ------ srec</span><br><span class="line">    k1om elf32-little elf32-big --------- ---------------- ------- ------ srec</span><br><span class="line">   iamcu elf32-little elf32-big --------- ---------------- ------- ------ srec</span><br><span class="line">  plugin elf32-little elf32-big --------- ---------------- ------- ------ srec</span><br><span class="line"></span><br><span class="line">         symbolsrec verilog tekhex binary ihex</span><br><span class="line">    i386 symbolsrec verilog tekhex binary ihex</span><br><span class="line">    l1om symbolsrec verilog tekhex binary ihex</span><br><span class="line">    k1om symbolsrec verilog tekhex binary ihex</span><br><span class="line">   iamcu symbolsrec verilog tekhex binary ihex</span><br><span class="line">  plugin symbolsrec verilog tekhex binary ihex</span><br></pre></td></tr></table></figure>
<h4 id="转换成二进制格式"><a class="header-anchor" href="#转换成二进制格式">¶</a>转换成二进制格式</h4>
<p>对于裸机环境，需要将可执行文件转换为单纯的二进制格式，即不包含额外的描述信息，只有指令数据。参考如下命令，可以转换为二进制格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objcopy -O binary nomain nomain.bin</span><br></pre></td></tr></table></figure>
<p>用二进制对比工具对比<code>nomain</code>和<code>nomain.bin</code>，发现<code>nomain.bin</code>的数据，等于<code>nomain</code>偏移量<code>0x158~0x480</code>的数据。查看<code>nomain</code>的段表，这些地址包含<code>.text</code>、<code>.rodata</code>、<code>.eh_frame</code>段的数据。</p>
<blockquote>
<p><code>.data</code>段的数据也会复制，但是<code>nomain</code>程序没有<code>.data</code>段。</p>
</blockquote>
<img src="http://image.pkemb.com/image/202309150000586.png"/>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset         Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.gnu.build-i NOTE             0000000000400158  00000158       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .text             PROGBITS         0000000000400180  00000180       0000000000000229  0000000000000000  AX       0     0     16</span><br><span class="line">  [ 3] .rodata           PROGBITS         00000000004003a9  000003a9       0000000000000009  0000000000000000   A       0     0     1</span><br><span class="line">  [ 4] .eh_frame         PROGBITS         00000000004003b8  000003b8       00000000000000c8  0000000000000000   A       0     0     8</span><br><span class="line">  [ 5] .tbss             NOBITS           0000000000601000  00001000       0000000000000004  0000000000000000 WAT       0     0     4</span><br><span class="line">  [ 6] .bss              NOBITS           0000000000601000  00001000       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 7] .comment          PROGBITS         0000000000000000  00000480       0000000000000029  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 8] .debug_aranges    PROGBITS         0000000000000000  000004a9       0000000000000030  0000000000000000           0     0     1</span><br><span class="line">  [ 9] .debug_info       PROGBITS         0000000000000000  000004d9       0000000000000092  0000000000000000           0     0     1</span><br><span class="line">  [10] .debug_abbrev     PROGBITS         0000000000000000  0000056b       000000000000006a  0000000000000000           0     0     1</span><br><span class="line">  [11] .debug_line       PROGBITS         0000000000000000  000005d5       0000000000000043  0000000000000000           0     0     1</span><br><span class="line">  [12] .debug_str        PROGBITS         0000000000000000  00000618       0000000000000092  0000000000000001  MS       0     0     1</span><br><span class="line">  [13] .symtab           SYMTAB           0000000000000000  000006b0       00000000000002d0  0000000000000018          14    15     8</span><br><span class="line">  [14] .strtab           STRTAB           0000000000000000  00000980       00000000000000c3  0000000000000000           0     0     1</span><br><span class="line">  [15] .shstrtab         STRTAB           0000000000000000  00000a43       000000000000009a  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>
<h4 id="转换成hex格式"><a class="header-anchor" href="#转换成hex格式">¶</a>转换成hex格式</h4>
<p>烧录器可能需要hex格式，可以使用如下命令转换。<code>hex</code>格式的文件本质上是一个纯文本，更多信息可以参考wiki <a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel_HEX</a>。</p>
<blockquote>
<p>hex文件自带地址信息，所以烧录时不用指定地址。但binary格式不带地址信息，所以需要指定起始地址。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objcopy -O ihex nomain nomain.hex</span><br></pre></td></tr></table></figure>
<h4 id="转换成目标文件"><a class="header-anchor" href="#转换成目标文件">¶</a>转换成目标文件</h4>
<p>在不带文件系统的环境，但又需要读取某个文件的数据，可以考虑将文件直接嵌入到程序中。先将文件转换为目标文件，最终和代码链接成一个文件。参考如下命令，将任意文件转换为目标文件。输入格式一定要设置为<code>binary</code>，输出格式根据运行环境选择。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objcopy -I binary -O elf32-i386 test.mp3 test.mp3.o</span><br></pre></td></tr></table></figure>
<p>创建的目标文件自带三个符号，可以在代码中使用<code>extern</code>关键字声明并使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -s test.mp3.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 5 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     2: 00000000     0 NOTYPE  GLOBAL DEFAULT    1 _binary_test_mp3_start</span><br><span class="line">     3: 000004d9     0 NOTYPE  GLOBAL DEFAULT    1 _binary_test_mp3_end</span><br><span class="line">     4: 000004d9     0 NOTYPE  GLOBAL DEFAULT  ABS _binary_test_mp3_size</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Excel常见打印设置</title>
    <url>/2021/03/excel-common-print-setting/</url>
    <content><![CDATA[<p>如何在excel365下设置打印范围、设置打印标题、加入页码。</p>
<span id="more"></span>
<h2 id="设置打印范围"><a class="header-anchor" href="#设置打印范围">¶</a>设置打印范围</h2>
<p>当表格有很多数据的时候，宽度会超过A4的范围。为了节约纸张，需要调整打印的宽度。进入视图选项卡，点击分页预览命令，这时excel会标记出每一页的宽度。即可以调整单元格的宽度，也可以直接拖动蓝色的边框线。</p>
<p>点击视图选项卡下面的普通命令，即可退出打印预览界面。</p>
<p><img src="https://image.pkemb.com/image/20210321183257.gif" alt=""></p>
<h2 id="设置打印标题"><a class="header-anchor" href="#设置打印标题">¶</a>设置打印标题</h2>
<p>当表格有很多页的时候，有时候希望每一页都有一个标题行，可以通过打印标题命令实现。</p>
<p>点击<code>页面布局</code>选项卡，点击<code>打印标题</code>命令，这时会弹出<code>页面设置</code>的窗口。在<code>工作表</code>选项卡下，设置<code>顶端标题行</code>。<code>顶端标题行</code>包含的单元格会出现在每一页的顶部，非常方便阅读。</p>
<p><img src="https://image.pkemb.com/image/20210321183535.png" alt=""></p>
<h2 id="设置页码"><a class="header-anchor" href="#设置页码">¶</a>设置页码</h2>
<p>有时需要给每一页加上页码。</p>
<p>首先进入打印窗口，快捷键<code>Ctrl+P</code>，或点击<code>文件</code>选项卡，找到<code>打印</code>。</p>
<p>点击<code>页面设置</code>，选中<code>页眉/页脚</code>选项卡，点击<code>自定义页脚</code>，将光标定位到<code>中部</code>，然后点击上方的<code>插入页码</code>命令，即可插入页码。</p>
<p>除了页码之外，还可以插入以下内容。将鼠标悬停在命令上方，会给出对应的提示。</p>
<ul>
<li>插入页码</li>
<li>插入页数</li>
<li>插入日期</li>
<li>插入时间</li>
<li>插入文件路径</li>
<li>插入文件名</li>
<li>插入数据表名称</li>
<li>插入图片</li>
</ul>
<p><img src="https://image.pkemb.com/image/20210321183609.png" alt=""></p>
]]></content>
      <categories>
        <category>excel</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF文件格式</title>
    <url>/2021/05/elf-format/</url>
    <content><![CDATA[<p>ELF文件格式说明，以及objdump和readelf指令的常用选项。</p>
<span id="more"></span>
<h2 id="ELF文件格式概述"><a class="header-anchor" href="#ELF文件格式概述">¶</a>ELF文件格式概述</h2>
<p>ELF文件格式是链接、装载的基础。ELF格式是在<code>UNIX System V</code>中引入的，用来支持<code>C++</code>和动态链接，他的前身是<code>a.out</code>格式。现在ELF被广泛用于Linux、BSD等类UNIX系统。下面是一些常见的目标文件格式，有关这些格式的详细说明，可以参考相关文档或《链接器和加载器》第3章。</p>
<ul>
<li>空目标文件格式：MS-DOS的COM文件</li>
<li>代码区段：UNIX的a.out文件</li>
<li>重定位：MS-DOS的EXE文件</li>
<li>可重定位的a.out格式</li>
<li>UNIX的ELF格式</li>
<li>IBM 360目标格式</li>
<li>微软PE格式</li>
<li>Intel/Microsoft的OMF文件格式</li>
</ul>
<h2 id="ELF学习资料"><a class="header-anchor" href="#ELF学习资料">¶</a>ELF学习资料</h2>
<ul>
<li><a href="https://share.pkemb.com/books/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB--%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%20-%20%E4%BF%9E%E7%94%B2%E5%AD%90.pdf">程序员的自我修养–链接、装载与库 - 俞甲子</a></li>
<li><a href="https://share.pkemb.com/books/%E9%93%BE%E6%8E%A5%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E6%89%AB%E6%8F%8F%E7%89%88%EF%BC%89%20-%20John%20R.%20Levine.pdf">链接器和加载器</a></li>
<li><a href="https://share.pkemb.com/books/elf%20specification%20v1.2.pdf">elf specification v1.2.pdf</a></li>
</ul>
<h2 id="示例代码"><a class="header-anchor" href="#示例代码">¶</a>示例代码</h2>
<p>为了更好的理解ELF文件格式，会使用以下代码编译出来的文件作演示。编译完成之后，会得到两个文件<code>tiny_hello.o</code>和<code>tiny_hello</code>。代码和<code>Makefile</code>可以从网页<a href="https://gist.github.com/pkemb/68dd3303dfd53e6ec400e961848c4547">tiny_hello</a>获取。注意，这份代码需要在32位Linux系统上运行。</p>
<p>编译指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -g -fno-builtin tiny_hello.c</span><br><span class="line">ld -static -e nomain tiny_hello.o -o tiny_hello</span><br></pre></td></tr></table></figure>
<p>源代码和Makefile如下：</p>
<script src="https://gist.github.com/pkemb/68dd3303dfd53e6ec400e961848c4547.js"></script>
<h2 id="ELF-文件类型"><a class="header-anchor" href="#ELF-文件类型">¶</a>ELF 文件类型</h2>
<p>ELF将文件分为4类，下表对比了不同类型之间的差异。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>链接</th>
<th>加载</th>
<th>示例文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>可重定位文件</td>
<td>Y</td>
<td>N</td>
<td>tiny_hello.o</td>
<td>由编译器和汇编器创建，运行前需要被链接器处理。</td>
</tr>
<tr>
<td>可执行文件</td>
<td>N</td>
<td>Y</td>
<td>tiny_hello</td>
<td>完成了所有的重定位工作和符号解析（除共享库符号）。</td>
</tr>
<tr>
<td>共享目标文件</td>
<td>Y</td>
<td>Y</td>
<td>libc.so.6</td>
<td>即包括链接器需要的符号信息，也包括运行时可以直接执行的代码。</td>
</tr>
<tr>
<td>核心转储文件</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>编译器、汇编器和链接器将ELF文件看作是<code>Section header table</code>描述的一系列逻辑<code>区段</code>（<code>section</code>）的集合；加载器将ELF文件看作是<code>Program header table</code>描述的一系列<code>段</code>（<code>segment</code>）的集合。一个<code>段</code>通常由多个<code>区段</code>组合。可重定位文件有<code>Section header table</code>，可执行文件有<code>Program header table</code>，共享目标文件两者都有。</p>
<p><img src="https://raw.githubusercontent.com/pkemb/notes/master/books/9787121085116/pic/ELF%E7%9A%84%E9%93%BE%E6%8E%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E8%A7%86%E5%9B%BE.png" alt=""></p>
<h2 id="ELF-文件头"><a class="header-anchor" href="#ELF-文件头">¶</a>ELF 文件头</h2>
<p>ELF文件都以ELF文件头开始，在32位机器上通过结构体<code>Elf32_Ehdr</code>来描述。重点关注<code>e_shoff</code>和<code>e_phoff</code>，通过这两个字段可以寻找到区段头部表和程序头部表，从而可以定位到其余所有的区段和段。</p>
<p><img src="https://raw.githubusercontent.com/pkemb/notes/master/books/9787121085116/pic/elf_header.png" alt=""></p>
<p>通过通过指令<code>readelf -h elffile</code>来查看ELF文件头。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Intel 80386</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1464 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               52 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           40 (bytes)</span><br><span class="line">  Number of section headers:         25</span><br><span class="line">  Section header string table index: 22</span><br></pre></td></tr></table></figure>
<h2 id="可重定位文件"><a class="header-anchor" href="#可重定位文件">¶</a>可重定位文件</h2>
<p>可重定位文件可以看作是一系列在区段头部表（Section header table）中被定义的区段的集合。区段头部表是一个以<code>Elf32_Shdr</code>结构体为元素的数组，数组中的每一个元素对应一个段。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sh_name</td>
<td>区段名，存储在区段<code>.shstrtab</code>的偏移。</td>
</tr>
<tr>
<td>sh_type</td>
<td><a href="#%E5%8C%BA%E6%AE%B5%E7%B1%BB%E5%9E%8B">区段类型</a></td>
</tr>
<tr>
<td>sh_flags</td>
<td><a href="#%E5%8C%BA%E6%AE%B5%E6%A0%87%E5%BF%97%E4%BD%8D">区段标志位</a></td>
</tr>
<tr>
<td>sh_addr</td>
<td>可加载区段在进程地址空间中的虚拟地址，不可加载区段为0。</td>
</tr>
<tr>
<td>sh_offset</td>
<td>区段在文件中的偏移。区段不在文件中则为0。</td>
</tr>
<tr>
<td>sh_size</td>
<td>区段的长度。</td>
</tr>
<tr>
<td>sh_link</td>
<td>段链接信息，存储的是相关信息的区段号。</td>
</tr>
<tr>
<td>sh_info</td>
<td>区段更多的信息。</td>
</tr>
<tr>
<td>sh_addralign</td>
<td>段地址对齐，2的指数倍。</td>
</tr>
<tr>
<td>sh_entsize</td>
<td>区段为一个表时，表项的大小。</td>
</tr>
</tbody>
</table>
<h3 id="区段类型"><a class="header-anchor" href="#区段类型">¶</a>区段类型</h3>
<p>区段常见的类型有：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHT_PROGBITS</td>
<td>程序内容，包括代码、数据和调试器信息。</td>
</tr>
<tr>
<td>SHT_NOBITS</td>
<td>在文件中没有分配空间，在程序加载时分配空间，例如.bss区段。</td>
</tr>
<tr>
<td>SHT_SYMTAB / SHT_DNYSYM</td>
<td><a href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8">符号表</a>。SHT_SYMBAT包含所有的符号，SHT_DNYSYM包含动态链接的符号，会被加载到内存。<br> readelf -s <br> objdump -t</td>
</tr>
<tr>
<td>SHT_STRTAB</td>
<td>字符串表。</td>
</tr>
<tr>
<td>SHT_REL / SHT_RELA</td>
<td>重定位表，包含重定位信息。<br> objdump -r <br> objdump -R</td>
</tr>
<tr>
<td>SHT_DYNAMIC</td>
<td>动态链接信息。<br> readelf -d</td>
</tr>
<tr>
<td>SHT_HASH</td>
<td>哈希表。</td>
</tr>
</tbody>
</table>
<h3 id="区段标志位"><a class="header-anchor" href="#区段标志位">¶</a>区段标志位</h3>
<p>区段标志位表示该区段在进程虚拟地址空间中的属性。</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHF_WRITE</td>
<td>在进程空间中可写。</td>
</tr>
<tr>
<td>SHF_ALLOC</td>
<td>在进程空间中要分配空间。</td>
</tr>
<tr>
<td>SHF_EXECINSTR</td>
<td>在进程空间中可以被执行。</td>
</tr>
</tbody>
</table>
<p>根据区段类型和区段标志位的组合，ELF文件可能有如下区段：</p>
<ul>
<li>.text，正文段，具有ALLOC+EXECINSTR属性的PROGBITS类型区段。</li>
<li>.data，数据段，具有ALLOC+WRITE属性的PROGBITS类型区段。</li>
<li>.rodata，只读数据段，具有ALLOC属性的PROGBITS类型区段。</li>
<li>.bss，具有ALLOC+WRITE属性的NOBITS类型区段。</li>
<li>.rel.text, .rel.data, .rel.rodata，REL或RELA类型区段，包含对应区段的重定位信息。</li>
<li>.init和.fini，具有ALLOC+EXECINSTR属性的PROGBITS类型区段，对C++来说时必须的。</li>
<li>.symtab，符号表，SYMTAB类型的区段。</li>
<li>.dnysym，动态链接符号表，具有ALLOC属性的DNYSYM类型区段。</li>
<li>.strtab，字符串表，STRTAB类型的区段，通常保存符号的字符串。</li>
<li>.shstrtab，段表字符串表，通常存储段名字符串。</li>
<li>.dnystr，ALLOC属性的STRTAB类型区段，通常保存动态链接符号的字符串。</li>
<li>.got</li>
<li>.plt</li>
<li>.line</li>
<li>.comment</li>
<li>.interp</li>
</ul>
<h3 id="区段头部表示例"><a class="header-anchor" href="#区段头部表示例">¶</a>区段头部表示例</h3>
<p>可以使用指令<code>readelf -S elffile </code>或<code>objdump -h elffile</code>，查看区段头部表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">There are 25 section headers, starting at offset 0x5b8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .text             PROGBITS        00000000 000034 000049 00  AX  0   0  4</span><br><span class="line">  [ 2] .rel.text         REL             00000000 000bd4 000018 08     23   1  4</span><br><span class="line">  [ 3] .data             PROGBITS        00000000 000080 000010 00  WA  0   0  4</span><br><span class="line">  [ 4] .rel.data         REL             00000000 000bec 000008 08     23   3  4</span><br><span class="line">  [ 5] .bss              NOBITS          00000000 000090 000008 00  WA  0   0  4</span><br><span class="line">  [ 6] .debug_abbrev     PROGBITS        00000000 000090 00008c 00      0   0  1</span><br><span class="line">  [ 7] .debug_info       PROGBITS        00000000 00011c 000111 00      0   0  1</span><br><span class="line">  [ 8] .rel.debug_info   REL             00000000 000bf4 000118 08     23   7  4</span><br><span class="line">  [ 9] .debug_line       PROGBITS        00000000 00022d 000045 00      0   0  1</span><br><span class="line">  [10] .rel.debug_line   REL             00000000 000d0c 000008 08     23   9  4</span><br><span class="line">  [11] .rodata           PROGBITS        00000000 000272 000007 00   A  0   0  1</span><br><span class="line">  [12] .debug_frame      PROGBITS        00000000 00027c 000060 00      0   0  4</span><br><span class="line">  [13] .rel.debug_frame  REL             00000000 000d14 000030 08     23  12  4</span><br><span class="line">  [14] .debug_loc        PROGBITS        00000000 0002dc 000084 00      0   0  1</span><br><span class="line">  [15] .debug_pubnames   PROGBITS        00000000 000360 00005a 00      0   0  1</span><br><span class="line">  [16] .rel.debug_pubnam REL             00000000 000d44 000008 08     23  15  4</span><br><span class="line">  [17] .debug_aranges    PROGBITS        00000000 0003ba 000020 00      0   0  1</span><br><span class="line">  [18] .rel.debug_arange REL             00000000 000d4c 000010 08     23  17  4</span><br><span class="line">  [19] .debug_str        PROGBITS        00000000 0003da 0000df 01  MS  0   0  1</span><br><span class="line">  [20] .comment          PROGBITS        00000000 0004b9 00002d 00      0   0  1</span><br><span class="line">  [21] .note.GNU-stack   PROGBITS        00000000 0004e6 000000 00      0   0  1</span><br><span class="line">  [22] .shstrtab         STRTAB          00000000 0004e6 0000d1 00      0   0  1</span><br><span class="line">  [23] .symtab           SYMTAB          00000000 0009a0 0001a0 10     24  20  4</span><br><span class="line">  [24] .strtab           STRTAB          00000000 000b40 000094 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure>
<h2 id="可执行文件"><a class="header-anchor" href="#可执行文件">¶</a>可执行文件</h2>
<p>程序头部表（Program Header table）是一个以<code>Elf32_Phdr</code>结构体为元素的数组，定义了要被映射的段。为了加快映射的速度，可执行文件将类似的可加载<code>区段</code>合并为一个<code>段</code>。可执行文件通常只有少数几种段，例如可读可执行的代码段，可读可写的数据段，只读的只读数据段。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>p_type</td>
<td>段的类型。LOAD、DYNAMIC、INTERP等。</td>
</tr>
<tr>
<td>p_offset</td>
<td>段在文件中的偏移。</td>
</tr>
<tr>
<td>p_vaddr</td>
<td>段在进程虚拟地址空间的起始地址。</td>
</tr>
<tr>
<td>p_paddr</td>
<td>物理装载地址。</td>
</tr>
<tr>
<td>p_filesz</td>
<td>段在文件中所占空间的大小。</td>
</tr>
<tr>
<td>p_memsz</td>
<td>段在虚拟地址空间中所占用的长度。</td>
</tr>
<tr>
<td>p_flags</td>
<td>段的权限，RWX。</td>
</tr>
<tr>
<td>p_align</td>
<td>对齐，2的指数幂。</td>
</tr>
</tbody>
</table>
<h3 id="程序头部表示例"><a class="header-anchor" href="#程序头部表示例">¶</a>程序头部表示例</h3>
<p>可以使用指令<code>readelf -l execfile</code>查看程序头表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost tiny_hello]$ readelf -l tiny_hello</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x80480c4</span><br><span class="line">There are 3 program headers, starting at offset 52</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  LOAD           0x000000 0x08048000 0x08048000 0x000e4 0x000e4 R E 0x1000</span><br><span class="line">  LOAD           0x0000e4 0x080490e4 0x080490e4 0x00010 0x0001c RW  0x1000</span><br><span class="line">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .text .rodata</span><br><span class="line">   01     .data .bss</span><br><span class="line">   02</span><br></pre></td></tr></table></figure>
<h2 id="ELF共享目标文件"><a class="header-anchor" href="#ELF共享目标文件">¶</a>ELF共享目标文件</h2>
<p>ELF第三种文件类型是共享目标文件，它包含了可重定位文件和可执行文件的所有东西。也就是说，共享目标文件既可以参与链接，也可以被加载到内容中执行。除此之外，共享目标文件还有一些独有的段，例如<code>.got</code>、<code>.plt</code>、<code>.interp</code>等。</p>
<h2 id="常见区段"><a class="header-anchor" href="#常见区段">¶</a>常见区段</h2>
<p>常见区段以及查看区段数据的指令。</p>
<h3 id="符号表"><a class="header-anchor" href="#符号表">¶</a>符号表</h3>
<p>符号表存储了ELF文件中每个符号的相关信息，是一个非常重要的表。通过符号表，可以得到非常多有用的信息，是分析ELF文件的基础。符号表是<code>Elf32_Sym</code>结构体数组，段名一般叫<code>.symtab</code>，每个表项定义了一个符号。</p>
<ul>
<li>st_name：符号名，字符串表<code>.strtab</code>的下标。</li>
<li>st_size：符号大小。</li>
<li>st_shndx：符号所在的段。
<ul>
<li>符号所在的段在段表中的下标。</li>
<li>SHN_ABS：该符号包含了一个绝对的值，例如文件名的符号。</li>
<li>SHN_COMMON：该符号是一个“COMMON块”类型的符号，例如未初始化的全局符号定义。</li>
<li>SHN_UNDEF：符号未定义，该符号在本文件中被引用，但是定义在其他文件。</li>
</ul>
</li>
<li>st_info：符号类型和绑定信息
<ul>
<li>高28位表示符号绑定信息（Symbol Binding）
<ul>
<li>STB_LOCAL：局部符号，对目标文件的外部不可见。</li>
<li>STB_GLOBAL：全局符号，外部可见。</li>
<li>STB_WEAK：若引用。</li>
</ul>
</li>
<li>低4位表示符号的类型（Symbol Type）
<ul>
<li>STT_NOTYPE：未知类型符号</li>
<li>STT_OBJECT：该符号是一个数据对象，比如变量、数组。</li>
<li>STT_FUNC：该符号是函数或其他可执行代码。</li>
<li>STT_SECTION：该符号是一个段，一定是STB_LOCAL。</li>
<li>STT_FILE：目标文件对应的源文件名，一定是STB_LOCAL，st_shndx一定是SHN_ABS。</li>
</ul>
</li>
</ul>
</li>
<li>st_value：符号值
<ul>
<li>目标文件
<ul>
<li>SHN_UNDEF：st_value没有用。</li>
<li>SHN_COMMON：表示该符号的对齐属性。</li>
<li>段的下标：st_value表示该符号在段中的偏移位置。</li>
</ul>
</li>
<li>可执行文件
<ul>
<li>st_value表示符号的虚拟地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="符号表示例"><a class="header-anchor" href="#符号表示例">¶</a>符号表示例</h4>
<p>可以使用指令<code>readelf -s elffile</code>查看符号表中的每一个表项。输出的第一列（Num）是符号在符号表的索引，第二列（Value）是符号值，第三列（Size）是符号大小，第四列（Type）是符号类型，第五列（Bind）是绑定类型，第六列（Vis）是??，第七列是（Ndx）是符号所在的段，第八列（Name）是符号名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost tiny_hello]$ readelf -s tiny_hello</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 28 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 08048094     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     2: 080480dd     0 SECTION LOCAL  DEFAULT    2</span><br><span class="line">     3: 080490e4     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 080490f4     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 00000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 00000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     7: 00000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">     8: 00000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">     9: 00000000     0 SECTION LOCAL  DEFAULT    9</span><br><span class="line">    10: 00000000     0 SECTION LOCAL  DEFAULT   10</span><br><span class="line">    11: 00000000     0 SECTION LOCAL  DEFAULT   11</span><br><span class="line">    12: 00000000     0 SECTION LOCAL  DEFAULT   12</span><br><span class="line">    13: 00000000     0 SECTION LOCAL  DEFAULT   13</span><br><span class="line">    14: 00000000     0 FILE    LOCAL  DEFAULT  ABS tiny_hello.c</span><br><span class="line">    15: 080490e8     4 OBJECT  LOCAL  DEFAULT    3 global_static_init</span><br><span class="line">    16: 080490f0     4 OBJECT  LOCAL  DEFAULT    3 local_static_init.763</span><br><span class="line">    17: 080490f4     4 OBJECT  LOCAL  DEFAULT    4 local_static_uninit.762</span><br><span class="line">    18: 080490f8     4 OBJECT  LOCAL  DEFAULT    4 global_static_uninit</span><br><span class="line">    19: 08048094    31 FUNC    GLOBAL DEFAULT    1 print</span><br><span class="line">    20: 080490e4     4 OBJECT  GLOBAL DEFAULT    3 global_init</span><br><span class="line">    21: 080480c4    25 FUNC    GLOBAL DEFAULT    1 nomain</span><br><span class="line">    22: 080490fc     4 OBJECT  GLOBAL DEFAULT    4 global_uninit</span><br><span class="line">    23: 080490f4     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start</span><br><span class="line">    24: 080490f4     0 NOTYPE  GLOBAL DEFAULT  ABS _edata</span><br><span class="line">    25: 08049100     0 NOTYPE  GLOBAL DEFAULT  ABS _end</span><br><span class="line">    26: 080490ec     4 OBJECT  GLOBAL DEFAULT    3 str</span><br><span class="line">    27: 080480b3    17 FUNC    GLOBAL DEFAULT    1 exit</span><br></pre></td></tr></table></figure>
<h3 id="代码段"><a class="header-anchor" href="#代码段">¶</a>代码段</h3>
<p>代码段存储了机器码，常见的代码段有<code>.text</code>、<code>.init</code>、<code>.fini</code>等。可以通过指令<code>objdump -d elffile</code>查看反汇编之后的代码，选项<code>-j section_name</code>可用于反汇编指定段。<code>objdump -S elffile</code>同时显示C代码和反汇编代码，这需要使用<code>-g</code>参数编译。<code>objdump -s elffile -j .text</code>查看<code>.text</code>段的十六进制内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost tiny_hello]$ objdump -d tiny_hello -j .text</span><br><span class="line"></span><br><span class="line">tiny_hello:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">08048094 &lt;print&gt;:</span><br><span class="line"> 8048094:       55                      push   %ebp</span><br><span class="line"> 8048095:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8048097:       53                      push   %ebx</span><br><span class="line"> 8048098:       a1 ec 90 04 08          mov    0x80490ec,%eax</span><br><span class="line"> 804809d:       ba 06 00 00 00          mov    $0x6,%edx</span><br><span class="line"> 80480a2:       89 c1                   mov    %eax,%ecx</span><br><span class="line"> 80480a4:       bb 01 00 00 00          mov    $0x1,%ebx</span><br><span class="line"> 80480a9:       b8 04 00 00 00          mov    $0x4,%eax</span><br><span class="line"> 80480ae:       cd 80                   int    $0x80</span><br><span class="line"> 80480b0:       5b                      pop    %ebx</span><br><span class="line"> 80480b1:       5d                      pop    %ebp</span><br><span class="line"> 80480b2:       c3                      ret</span><br><span class="line"></span><br><span class="line">省略exit和nomain函数的反汇编代码......</span><br></pre></td></tr></table></figure>
<p>有时候只需要查看某个函数的反汇编代码，而不是段中所有函数的反汇编代码。这可以通过<code>gdb</code>来完成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb /bin/ls -batch -ex &#x27;disassemble main&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="数据段"><a class="header-anchor" href="#数据段">¶</a>数据段</h3>
<p>数据段存储了全局或静态变量的初始值，常见的数据段有<code>.data</code>和<code>.rodata</code>，<code>.data</code>存储可读写的数据，<code>.rodata</code>存储只读数据。数据段只是简单的将各个变量的初始值罗列在一起，所以只能直接查看其二进制的值。还有一个特殊的数据段是<code>.bss</code>，在可执行文件中不占用空间，只在虚拟内存中占用空间，在<code>.bss</code>段中的变量，初始值都是0。可以使用指令<code>objdump -s elffile -j .data</code>查看数据段的十六进制内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost tiny_hello]$ objdump -s tiny_hello -j .data -j .rodata</span><br><span class="line"></span><br><span class="line">tiny_hello:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 80480dd 68656c6c 6f0a00                      hello..</span><br><span class="line">Contents of section .data:</span><br><span class="line"> 80490e4 02000000 03000000 dd800408 05000000  ................</span><br></pre></td></tr></table></figure>
<h3 id="字符串表"><a class="header-anchor" href="#字符串表">¶</a>字符串表</h3>
<p>字符串存储了变量、函数、段名的字符串。一般情况下，<code>.strtab</code>存储了变量和函数的名称，<code>.shstrtab</code>存储了各个段的名称，<code>.dnystr</code>存储了需要动态链接的变量和函数的名称，是<code>.strtab</code>的子集，且只在动态库文件中存在。可以使用指令<code>readelf elffile -p section</code>查看字符串表中的内容。字符串前方的数字是字符串第一个字符在字符串表中的偏移。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost tiny_hello]$ readelf tiny_hello -p .strtab -p .shstrtab</span><br><span class="line"></span><br><span class="line">String dump of section &#x27;.shstrtab&#x27;:</span><br><span class="line">  [     1]  .symtab</span><br><span class="line">  [     9]  .strtab</span><br><span class="line">  [    11]  .shstrtab</span><br><span class="line">  [    1b]  .text</span><br><span class="line">  [    21]  .rodata</span><br><span class="line">  [    29]  .data</span><br><span class="line">  [    2f]  .bss</span><br><span class="line">  [    34]  .comment</span><br><span class="line">  [    3d]  .debug_aranges</span><br><span class="line">  [    4c]  .debug_pubnames</span><br><span class="line">  [    5c]  .debug_info</span><br><span class="line">  [    68]  .debug_abbrev</span><br><span class="line">  [    76]  .debug_line</span><br><span class="line">  [    82]  .debug_frame</span><br><span class="line">  [    8f]  .debug_str</span><br><span class="line">  [    9a]  .debug_loc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String dump of section &#x27;.strtab&#x27;:</span><br><span class="line">  [     1]  tiny_hello.c</span><br><span class="line">  [     e]  global_static_init</span><br><span class="line">  [    21]  local_static_init.763</span><br><span class="line">  [    37]  local_static_uninit.762</span><br><span class="line">  [    4f]  global_static_uninit</span><br><span class="line">  [    64]  print</span><br><span class="line">  [    6a]  global_init</span><br><span class="line">  [    76]  nomain</span><br><span class="line">  [    7d]  global_uninit</span><br><span class="line">  [    8b]  __bss_start</span><br><span class="line">  [    97]  _edata</span><br><span class="line">  [    9e]  _end</span><br><span class="line">  [    a3]  str</span><br><span class="line">  [    a7]  exit</span><br></pre></td></tr></table></figure>
<h2 id="ELF实例分析"><a class="header-anchor" href="#ELF实例分析">¶</a>ELF实例分析</h2>
<p>分析一个ELF文件，目的是为了从中获取到一些有用的信息。由于可重定位文件、可执行文件和共享库文件有不同的特点，所以关注的侧重点也不同。对于可重定位和共享库文件来说，可以参与链接，所以比较关心它们的导出、导入符号。对于可执行文件和共享库文件来说，还可以被加载到内存中运行，比较关心加载地址、（虚拟）内存布局、依赖的动态库（动态链接）。</p>
<p>以<code>tiny_hello</code>为例，简单分析一下ELF可执行文件。首先从文件头可以看到程序的入口地址，这是程序开始运行的地方。通过<code>section headers</code>的入口地址、大小以及数量，可以找到其余所有区段的位置。通过<code>program headers</code>的入口地址、大小及数量，可以确定所有可加载段的位置。通过<code>shstrtab</code>的索引，可以确定每个区段的名字。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost tiny_hello]$ readelf -h tiny_hello</span><br><span class="line">......</span><br><span class="line">  Entry point address:               0x80480c4</span><br><span class="line">  Start of program headers:          52 (bytes into file)</span><br><span class="line">  Start of section headers:          1512 (bytes into file)</span><br><span class="line">  Size of program headers:           32 (bytes)</span><br><span class="line">  Number of program headers:         3</span><br><span class="line">  Size of section headers:           40 (bytes)</span><br><span class="line">  Number of section headers:         17</span><br><span class="line">  Section header string table index: 14</span><br></pre></td></tr></table></figure>
<p>由于可执行文件是可加载的，接下来看看<code>program headers</code>。从表中可以看出，有两个可加载的<code>segment</code>。第一个<code>segment</code>由<code>.text</code>和<code>.rodata</code>组合而成，包含一些只读的代码和数据。第二个<code>segment</code>由<code>.data</code>和<code>.bss</code>组合而成，包含一些可读写的数据。首先来看看<code>FileSiz</code>和<code>MemSiz</code>，分别表示在文件中占用的空间和在内存中占用的空间。第一个<code>segment</code>两者一致，第二个<code>Segment</code>的<code>MemSiz</code>稍大一些，这是因为<code>.bss</code>在文件中不占用空间，只占用内存中的空间。接下来分析<code>VirtAddr</code>和<code>PhyAddr</code>，分别表示虚拟地址和物理地址。一般情况下，两者的大小是一致的，在一些特殊的情况，比如bootloader、kernel、单片机程序中，两者可能不一致。</p>
<blockquote>
<p>为什么第二个<code>segment</code>的加载地址，是从<code>0x080490e4</code>开始，而不是<code>0x08049000</code>开始呢？</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost tiny_hello]$ readelf tiny_hello -l</span><br><span class="line">There are 3 program headers, starting at offset 52</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  LOAD           0x000000 0x08048000 0x08048000 0x000e4 0x000e4 R E 0x1000</span><br><span class="line">  LOAD           0x0000e4 0x080490e4 0x080490e4 0x00010 0x0001c RW  0x1000</span><br><span class="line">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .text .rodata</span><br><span class="line">   01     .data .bss</span><br><span class="line">   02</span><br></pre></td></tr></table></figure>
<p>为了弄清楚内存中的内容，需要看看符号表中的内容。下面的符号表已将不需要的内容删除了，并重新排序了。有三个类型为<code>FUNC</code>的符号，均在区段1，即<code>.text</code>区段。而且全部都是<code>GLOBAL</code>类型的符号，说明从外部是可见的。</p>
<p>重点在7个类型为<code>OBJECT</code>的符号。带有<code>static</code>的符号，均是<code>LOCAL</code>；不带<code>static</code>的符号均是<code>GLOBAL</code>。带有<code>uninit</code>的符号，均在区段4，即<code>.bss</code>区段；带有<code>init</code>的符号，均在区段3，即<code>.data</code>区段。对比源代码可以看出，<code>nomain()</code>定义的<code>local_init</code>和<code>local_uninit</code>变量没有出现到符号表中，因为这两个变量运行时在栈中分配空间，所以符号表中没有。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost tiny_hello]$ readelf tiny_hello -s</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 28 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">    21: 080480c4    25 FUNC    GLOBAL DEFAULT    1 nomain</span><br><span class="line">    19: 08048094    31 FUNC    GLOBAL DEFAULT    1 print</span><br><span class="line">    27: 080480b3    17 FUNC    GLOBAL DEFAULT    1 exit</span><br><span class="line"></span><br><span class="line">    15: 080490e8     4 OBJECT  LOCAL  DEFAULT    3 global_static_init</span><br><span class="line">    16: 080490f0     4 OBJECT  LOCAL  DEFAULT    3 local_static_init.763</span><br><span class="line">    17: 080490f4     4 OBJECT  LOCAL  DEFAULT    4 local_static_uninit.762</span><br><span class="line">    18: 080490f8     4 OBJECT  LOCAL  DEFAULT    4 global_static_uninit</span><br><span class="line">    20: 080490e4     4 OBJECT  GLOBAL DEFAULT    3 global_init</span><br><span class="line">    22: 080490fc     4 OBJECT  GLOBAL DEFAULT    4 global_uninit</span><br><span class="line">    26: 080490ec     4 OBJECT  GLOBAL DEFAULT    3 str</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">080480c4 &lt;nomain&gt;:</span><br><span class="line"> 80480c4:       55                      push   %ebp</span><br><span class="line"> 80480c5:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80480c7:       83 ec 10                sub    $0x10,%esp       # 栈指针减少0x10，为了4个int型变量预留栈空间</span><br><span class="line"> 80480ca:       c7 45 fc 04 00 00 00    movl   $0x4,-0x4(%ebp)  # 赋值为4</span><br><span class="line"> 80480d1:       e8 be ff ff ff          call   8048094 &lt;print&gt;</span><br><span class="line"> 80480d6:       e8 d8 ff ff ff          call   80480b3 &lt;exit&gt;</span><br><span class="line"> 80480db:       c9                      leave</span><br><span class="line"> 80480dc:       c3                      ret</span><br></pre></td></tr></table></figure>
<p>对符号表的分析可以看出，有4个变量定义在了<code>.data</code>段，来看看<code>.data</code>段中的内容。<code>.data</code>段从<code>0x080490e4</code>开始，数据段中的值可以与符号表对上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost tiny_hello]$ objdump tiny_hello -s -j .data</span><br><span class="line"></span><br><span class="line">tiny_hello:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .data:</span><br><span class="line"> 80490e4 02000000 03000000 dd800408 05000000  ................</span><br></pre></td></tr></table></figure>
<p>以上分析了ELF可执行文件的入口地址、内存布局以及如何查看数据段的内容。</p>
<h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2>
<p>本文以<code>tiny_hello.c</code>编译出来的目标文件和可执行文件为例子，利用<code>objdump</code>和<code>readelf</code>工具，分析了ELF文件的格式，并对常见区段的内容进行了重点讲解。然而，以上没有包含ELF格式的所有内容，还有重定位表、<code>.got</code>、<code>.plt</code>和<code>.interp</code>等内容没有介绍，这些内容会和链接、动态库一起介绍。</p>
]]></content>
  </entry>
  <entry>
    <title>GDB常用指令</title>
    <url>/2021/05/gdb-command/</url>
    <content><![CDATA[<p>GDB常用指令及示例。有关GDB更详细的信息，可以参考<a href="https://sourceware.org/gdb/current/onlinedocs/gdb.pdf">GDB官方手册</a>。</p>
<span id="more"></span>
<h2 id="启动与退出GDB"><a class="header-anchor" href="#启动与退出GDB">¶</a>启动与退出GDB</h2>
<p>一般有三种启动<code>gdb</code>的方式。</p>
<table>
<thead>
<tr>
<th>启动命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>gdb program</td>
<td>在gdb的监控下运行程序program</td>
</tr>
<tr>
<td>gdb program coredump</td>
<td>同时加载core dump文件，一般用于分析程序崩溃的原因。</td>
</tr>
<tr>
<td>gdb -p pid</td>
<td>调试正在运行的进程，需要有相关的权限。</td>
</tr>
</tbody>
</table>
<p><code>gdb</code>启动成功后，会进入到<code>gdb</code>交换界面，有提示符<code>(gdb) </code>。在交换界面中，可以输入一些指令，来对目标程序进行<code>debug</code>。输入指令<code>quit</code>或组合键<code>Ctrl + D</code>可以退出<code>gdb</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<h2 id="设置断点"><a class="header-anchor" href="#设置断点">¶</a>设置断点</h2>
<p>断点用于中断程序的运行，这时可以查看程序的当前状态，进行debug。</p>
<h3 id="break-b"><a class="header-anchor" href="#break-b">¶</a>break ( b )</h3>
<p><code>break</code>指令用于设置断点，断点位置可以是一个符号，或代码的某一行。下面的示例在第13行和main函数分别设置了一个断点。<code>break</code>指令的缩写是<code>b</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) break 13</span><br><span class="line">Breakpoint 1 at 0x804807e: file bubble.s, line 13.</span><br><span class="line">(gdb) break main</span><br><span class="line">Breakpoint 2 at 0x8048074: file bubble.s, line 11.</span><br></pre></td></tr></table></figure>
<h3 id="watch"><a class="header-anchor" href="#watch">¶</a>watch</h3>
<p><code>watch</code>指令用于监控表达式的变化。当表达式的值发生变化时，则停止程序。注意，<code>watch</code>只能监控变量，指针或常量地址需要解引用。<code>rwatch</code>监控读操作，<code>awatch</code>监控读写操作。</p>
<blockquote>
<p>If you watch for a change in a numerically entered address you need to dereference it, as<br>
the address itself is just a constant number which will never change. gdb refuses to create<br>
a watchpoint that watches a never-changing value:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch 0x600850</span><br><span class="line">Cannot watch constant value 0x600850.</span><br><span class="line">(gdb) watch *(int *) 0x600850</span><br><span class="line">Watchpoint 1: *(int *) 6293584</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>info watchpoints</code> 查看相关信息。</p>
<h3 id="catch"><a class="header-anchor" href="#catch">¶</a>catch</h3>
<p>捕获指定事件。常见的事件如下表格所示。<code>tcatch</code>捕获一次后自动删除相关断点。</p>
<table>
<thead>
<tr>
<th>event</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>catch exec</td>
<td>调用exec</td>
</tr>
<tr>
<td>catch syscall name/number</td>
<td>调用系统调用，可以指定名字或编号。</td>
</tr>
<tr>
<td>catch fork</td>
<td>调用fork</td>
</tr>
<tr>
<td>catch vfork</td>
<td>调用vfork</td>
</tr>
<tr>
<td>catch load</td>
<td>加载共享库</td>
</tr>
<tr>
<td>catch unload</td>
<td>卸载共享库</td>
</tr>
<tr>
<td>catch signal signal/all</td>
<td>传递信号</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://elixir.bootlin.com/linux/v5.12.10/source/arch/arm/tools/syscall.tbl">arm 系统调用编号查询</a></p>
</blockquote>
<h3 id="delete-d"><a class="header-anchor" href="#delete-d">¶</a>delete ( d )</h3>
<p><code>delete</code>指令用于删除断点，参数是断点号。如果忘记断点对应的断点号，可以用指令<code>info break</code>查看所有的断点。下面的示例删除了断点2。<code>delete</code>指令的缩写是<code>d</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">1       breakpoint     keep y   0x0804807e bubble.s:13</span><br><span class="line">2       breakpoint     keep y   0x08048074 bubble.s:11</span><br><span class="line">(gdb) delete 2</span><br><span class="line">(gdb) info break</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">1       breakpoint     keep y   0x0804807e bubble.s:13</span><br></pre></td></tr></table></figure>
<p><code>clear</code>指令也可以删除断点，参数是断点在程序中的位置。</p>
<h3 id="命中断点后自动执行指令"><a class="header-anchor" href="#命中断点后自动执行指令">¶</a>命中断点后自动执行指令</h3>
<p>命中断点后，GDB会暂停执行程序。这时可以执行一些GDB命令，调试程序。如果断点会多次名字，每次都手工敲，会浪费很多时间。可以用<code>commands</code>命令为断点设置命令。在<code>&gt;</code>提示符前输入命令，一行一个，输入<code>end</code>结束。<code>commands number</code>表示给指定断点设置命令。</p>
<p>示例，调用<code>write</code>系统调用时打印backtrace。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) catch syscall write</span><br><span class="line">Catchpoint 1 (syscall &#x27;write&#x27; [1])</span><br><span class="line">(gdb) commands</span><br><span class="line">Type commands for breakpoint(s) 1, one per line.</span><br><span class="line">End with a line saying just &quot;end&quot;.</span><br><span class="line">&gt;bt</span><br><span class="line">&gt;c</span><br><span class="line">&gt;end</span><br><span class="line">(gdb) info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       catchpoint     keep y                      syscall &quot;write&quot;</span><br><span class="line">        bt</span><br><span class="line">        c</span><br></pre></td></tr></table></figure>
<h2 id="运行程序"><a class="header-anchor" href="#运行程序">¶</a>运行程序</h2>
<h3 id="run-r"><a class="header-anchor" href="#run-r">¶</a>run ( r )</h3>
<p><code>GDB</code>启动之后，被调试的程序可能处于未运行的状态，需要使用<code>run</code>指令来启动程序的运行。程序启动之后，会在断点处停下来。<code>run</code>指令的缩写是<code>r</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/pk/asm/bubble</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at bubble.s:13</span><br><span class="line">13              movl $len, %ecx</span><br><span class="line">Current language:  auto; currently asm</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果没有设置断点，程序会一直运行下去。或者在任何可能阻塞程序运行的地方停下来，如等待用户输入。</p>
</blockquote>
<h3 id="continue-c"><a class="header-anchor" href="#continue-c">¶</a>continue ( c )</h3>
<p><code>continue</code>指令用于继续运行程序，直到遇到下列情况：</p>
<ol>
<li>遇到断点，程序中断运行。</li>
<li>程序被阻塞，等待继续运行的条件。如等待用户输入。</li>
<li>程序正常或异常退出。</li>
</ol>
<p><code>continue</code>指令的缩写<code>c</code>。</p>
<h3 id="next-n"><a class="header-anchor" href="#next-n">¶</a>next ( n )</h3>
<p>单步执行，不进入子函数。</p>
<h3 id="step-s"><a class="header-anchor" href="#step-s">¶</a>step ( s )</h3>
<p>单步执行，进入子函数。</p>
<h3 id="stepi"><a class="header-anchor" href="#stepi">¶</a>stepi</h3>
<p>调试内联汇编时，GDB认为asm段是单一语句。可以使用<code>stepi</code>命令进入asm段进行单步执行，单独地执行每条指令。</p>
<h3 id="指令级别单步"><a class="header-anchor" href="#指令级别单步">¶</a>指令级别单步</h3>
<p>对于C或其他高级语言编写的程序，单步是以语句为单位。可以使用指令<code>set disassemble-next-line on</code>开启指令级别单步，使用<code>stepi</code>（缩写<code>si</code>）或<code>nexti</code>（缩写<code>ni</code>）单步执行。</p>
<h2 id="查看寄存器或内存"><a class="header-anchor" href="#查看寄存器或内存">¶</a>查看寄存器或内存</h2>
<h3 id="print-p"><a class="header-anchor" href="#print-p">¶</a>print ( p )</h3>
<p>查看寄存器或内存的值，默认是十进制，<code>print/x</code>以十六进制打印，<code>print/o</code>以八进制打印。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p $eax</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 45</span></span><br><span class="line">(gdb) p/x $eax</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 0x2d</span></span><br><span class="line">(gdb) p/o $eax</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 055</span></span><br><span class="line">(gdb) p values   # values 是一个变量。</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = 45</span></span><br><span class="line">(gdb) p &amp;values</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = (&lt;data variable, no debug info&gt; *) 0x80490b4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>寄存器前面要加<code>$</code>，变量无需前缀；取变量地址需前缀<code>&amp;</code>。这和汇编的语法不同。</p>
</blockquote>
<h3 id="examine-x"><a class="header-anchor" href="#examine-x">¶</a>examine ( x )</h3>
<p><code>x</code>与<code>print</code>指令类似，但支持更多的格式。格式如下：<code>x /nfu address</code></p>
<ul>
<li>n 内存单元的个数</li>
<li>f 显示方式
<ul>
<li>x 十六进制</li>
<li>d 十进制</li>
<li>u 无符号十进制</li>
<li>o 八进制</li>
<li>t 二进制</li>
<li>a 十六进制</li>
<li>i 指令</li>
<li>c 字符</li>
<li>f 浮点数</li>
</ul>
</li>
<li>u 一个地址单元的长度
<ul>
<li>b 单字节</li>
<li>h 双字节</li>
<li>w 四字节</li>
<li>g 八字节</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/7xw &amp;values    # 按十六进制显示7个内存单元，每个内存单元4字节</span><br><span class="line">0x80490b4 &lt;values&gt;:     0x0000002d      0x00000022      0x0000005a      0x0000004e</span><br><span class="line">0x80490c4 &lt;values+16&gt;:  0x00000003      0x00000009      0x0000000a</span><br><span class="line">(gdb) x/5i main        # 查看从main开始的5条汇编指令</span><br><span class="line">0x8048074 &lt;main&gt;:       mov    $0x80490b4,%edi</span><br><span class="line">0x8048079 &lt;main+5&gt;:     mov    $0x6,%ebx</span><br><span class="line">0x804807e &lt;main+10&gt;:    mov    $0x6,%ecx</span><br><span class="line">0x8048083 &lt;loop&gt;:       mov    (%edi),%eax</span><br><span class="line">0x8048085 &lt;loop+2&gt;:     cmp    %eax,0x4(%edi)</span><br></pre></td></tr></table></figure>
<h3 id="display"><a class="header-anchor" href="#display">¶</a>display</h3>
<p>当程序停止时自动打印表达式的值，指令格式与指令<code>x</code>类似，但是不支持长度。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) display $pc             # 监控 pc 寄存器</span><br><span class="line">(gdb) display *(&amp;values + 4)  # 监控values数组的第二个值，语法与C语言一样</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/pk/asm/bubble</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at bubble.s:13</span><br><span class="line">13              movl $len, %ecx</span><br><span class="line">2: *(&amp;&#123;&lt;data variable, no debug info&gt;&#125; 134516916 + 4) = 3</span><br><span class="line">1: $pc = (void (*)()) 0x804807e &lt;main+10&gt;</span><br><span class="line">Current language:  auto; currently asm</span><br><span class="line">(gdb) n</span><br><span class="line">loop () at bubble.s:15</span><br><span class="line">15              movl (%edi), %eax  # load value to eax</span><br><span class="line">2: *(&amp;&#123;&lt;data variable, no debug info&gt;&#125; 134516916 + 4) = 3</span><br><span class="line">1: $pc = (void (*)()) 0x8048083 &lt;loop&gt;   # 自动打印监控的值</span><br></pre></td></tr></table></figure>
<p>指令<code>info display</code>查看当前会自动打印的表达式。指令<code>undisplay num</code>可用于取消自动打印。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) info display</span><br><span class="line">Auto-display expressions now in effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">2:   y  *(&amp;&#123;&lt;data variable, no debug info&gt;&#125; 134516916 + 4)</span><br><span class="line">1:   y  $pc</span><br><span class="line">(gdb) undisplay 2    # 取消自动打印表达式2</span><br><span class="line">(gdb) info display</span><br><span class="line">Auto-display expressions now in effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y  $pc</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<h3 id="backtrace"><a class="header-anchor" href="#backtrace">¶</a>backtrace</h3>
<p>查看调用栈。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) backtrace</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  loop () at bubble.s:17</span></span><br></pre></td></tr></table></figure>
<h2 id="源代码"><a class="header-anchor" href="#源代码">¶</a>源代码</h2>
<h3 id="list-l"><a class="header-anchor" href="#list-l">¶</a>list ( l )</h3>
<p>查看源代码。默认显示10行，再执行一次显示接下来的10行。如果接一个行号，则显示以此行为中心的10行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) list 10  # 显示以第10行为中心的10行代码</span><br><span class="line">5</span><br><span class="line">6       .equ len, (values_end - values)/4 -1</span><br><span class="line">7</span><br><span class="line">8       .section .text</span><br><span class="line">9       .global main</span><br><span class="line">10      main:</span><br><span class="line">11              movl $values, %edi</span><br><span class="line">12              movl $len, %ebx</span><br><span class="line">13              movl $len, %ecx</span><br><span class="line">14      loop:</span><br></pre></td></tr></table></figure>
<h2 id="shell指令"><a class="header-anchor" href="#shell指令">¶</a>shell指令</h2>
<h3 id="shell"><a class="header-anchor" href="#shell">¶</a>shell</h3>
<p><code>shell</code>命令可以在<code>gdb</code>环境中直接执行<code>shell</code>指令，而不必退出<code>gdb</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) shell date +&quot;%Y-%m-%d&quot;</span><br><span class="line">2021-05-16</span><br></pre></td></tr></table></figure>
<h3 id="make"><a class="header-anchor" href="#make">¶</a>make</h3>
<p>在<code>gdb</code>环境中，可以直接使用<code>make</code>指令，来执行当前目录下的<code>makefile</code>文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) make bubble</span><br><span class="line">make: “bubble”是最新的。</span><br></pre></td></tr></table></figure>
<h2 id="分析coredump"><a class="header-anchor" href="#分析coredump">¶</a>分析coredump</h2>
<blockquote>
<p>如果要分析的coredump与主机架构不一致，需要使用交叉工具链中的gdb</p>
</blockquote>
<p>使用gdb同时加载可执行文件和coredump文件，然后用<code>backtrace</code>命令打印调用栈，找出导致coredump的代码位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb elf coredump</span><br><span class="line">......</span><br><span class="line">(gdb) backtrace</span><br></pre></td></tr></table></figure>
<p>一般可执行文件会依赖非常多的库文件，如果gdb找不到库文件，或找到的库文件不带调试信息，会导致gdb无法准确找到错误点。这时可以用命令<code>info shared library</code>找出依赖的所有库文件，然后找到带调试信息的文件，按照rootfs的路径组织在一起，然后用命令<code>set sysroot</code>切换gdb的库文件查找路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) info shared library</span><br><span class="line">(gdb) set sysroot</span><br></pre></td></tr></table></figure>
<h2 id="GDB脚本"><a class="header-anchor" href="#GDB脚本">¶</a>GDB脚本</h2>
<p>可以将GDB调试命令写在一个文件中，然后使用GDB加载这个文件，可以大大减少输入调试命令的时间，提高调试效率。例如将下面的内容保存为<code>test.gdb</code>，在GDB交互界面使用<code>source test.gdb</code>命令加载GDB脚本。也可以使用<code>--command</code>选项在启动GDB时加载脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set pagination off</span><br><span class="line"></span><br><span class="line">catch syscall write</span><br><span class="line">commands</span><br><span class="line">    bt</span><br><span class="line">    c</span><br><span class="line">    end</span><br><span class="line">run</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb --batch --command=test.gdb --args your_program [pram...]</span><br></pre></td></tr></table></figure>
<p>扩展资料：<a href="https://github.com/gdbinit/Gdbinit/blob/master/gdbinit">gdbinit</a></p>
<h2 id="GDB小技巧"><a class="header-anchor" href="#GDB小技巧">¶</a>GDB小技巧</h2>
<h3 id="代码补全"><a class="header-anchor" href="#代码补全">¶</a>代码补全</h3>
<p>在<code>gdb</code>环境中，如果忘记了指令，或者指令比较长，可以尝试敲<code>tab</code>键，用于提示匹配的指令，或快速输入指令。</p>
<p>如果当前已经输入的内容，只会匹配到一个指令，敲一下<code>tab</code>，剩下的内容会自动补全；如果匹配两个或多个指令，敲两下<code>tab</code>，会输出匹配的所有指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) con[tab][tab]</span><br><span class="line">condition  continue</span><br></pre></td></tr></table></figure>
<h3 id="自动加载共享库"><a class="header-anchor" href="#自动加载共享库">¶</a>自动加载共享库</h3>
<p>如果使用命令<code>gdb command</code>启动gdb，则gdb不会加载共享库。原因如下。需要执行<code>run</code>命令启动程序，gdb才会加载共享库。</p>
<blockquote>
<p><code>gdb</code> automatically loads symbol definitions from shared libraries when you use the <code>run</code><br>
command, or when you examine a core file. (Before you issue the <code>run</code> command, gdb<br>
does not understand references to a function in a shared library, however—unless you are<br>
debugging a core file).</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>shell脚本</title>
    <url>/2021/05/shell-script/</url>
    <content><![CDATA[<p>介绍编写shell脚本的常用技巧，以及一些实用的脚本片段。</p>
<span id="more"></span>
<h2 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h2>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$#</code></td>
<td>参数的个数</td>
</tr>
<tr>
<td><code>$*</code> / <code>$@</code></td>
<td>所有参数</td>
</tr>
<tr>
<td><code>$0</code></td>
<td>第0个参数，一般是脚本文件名</td>
</tr>
<tr>
<td><code>$1</code></td>
<td>第1个参数，其余参数依次类推</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>当前进程ID</td>
</tr>
</tbody>
</table>
<p><code>$*</code>和<code>$@</code>没被双引号括起来的时候，是没区别的，将每个参数看作一份数据，用空格分隔。如果用双引号括起来，<code>&quot;$*&quot;</code>将所有参数看作一个整体，<code>&quot;$@&quot;</code>依旧将每个参数看作一份数据。可以用<code>for</code>循环体现出差别。</p>
<p>脚本将所有的特殊变量都打印出来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;param number = $#&quot;</span><br><span class="line">echo &quot;all param(\$*) = $*&quot;</span><br><span class="line">echo &quot;all param(\$@) = $@&quot;</span><br><span class="line">echo &quot;\$0 = $0&quot;</span><br><span class="line">echo &quot;\$1 = $1&quot;</span><br><span class="line">echo &quot;current PID: $$&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;print each param from \&quot;\$*\&quot;&quot;</span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;print each param from \&quot;\$@\&quot;&quot;</span><br><span class="line">for i in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">        echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>执行的输出示例如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@pkserver test]# ./special_variable.sh 1 2 3 4 5 6</span><br><span class="line">param number = 6</span><br><span class="line">all param($*) = 1 2 3 4 5 6</span><br><span class="line">all param($@) = 1 2 3 4 5 6</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">0 = ./special_variable.sh</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 1</span></span><br><span class="line">current PID: 21009</span><br><span class="line">print each param from &quot;$*&quot;</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">print each param from &quot;$@&quot;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h2 id="返回值"><a class="header-anchor" href="#返回值">¶</a>返回值</h2>
<p><code>exit</code>命令用于结束脚本的运行。可以接一个参数，表示脚本的放回值。一般用<code>0</code>表示正常结束，非0表示异常。通过遍历<code>$?</code>可以获取脚本返回值。如下是示例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;exit with 1&quot;</span><br><span class="line">exit 1</span><br></pre></td></tr></table></figure>
<p>示例输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@pkserver test]# ./exit.sh</span><br><span class="line">exit with 1</span><br><span class="line">[root@pkserver test]# echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="流程控制语句"><a class="header-anchor" href="#流程控制语句">¶</a>流程控制语句</h2>
<h3 id="条件语句if"><a class="header-anchor" href="#条件语句if">¶</a>条件语句if</h3>
<p><code>if</code>语句的基本格式如下。<code>[</code>的两边一定要有空格，<code>];</code>的两边一定也要有空格，否则会有语法错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ condition ]; then</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><code>if</code>语句的关键在于条件<code>condition</code>怎么写。下面给出常用的示例。</p>
<h4 id="和-的区别"><a class="header-anchor" href="#和-的区别">¶</a>[和[[的区别</h4>
<p>TODO</p>
<h4 id="判断是否为空"><a class="header-anchor" href="#判断是否为空">¶</a>判断是否为空</h4>
<p>一定要用双引号将变量括起来。否则，如果变量的值包含空格，则会有语法错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ ! &quot;$var&quot; ]; then</span><br><span class="line">    echo &quot;is null&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;not null&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h4 id="判断是否相等"><a class="header-anchor" href="#判断是否相等">¶</a>判断是否相等</h4>
<p>在变量前加上一个附加前缀<code>x</code>（任意字符串均可）。否则，如果<code>$var1</code>为空，则会有语法错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ x&quot;$var1&quot; = x&quot;$var2&quot; ]; then</span><br><span class="line">    echo &quot;equal&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;not equal&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h4 id="多条件"><a class="header-anchor" href="#多条件">¶</a>多条件</h4>
<ul>
<li>或：-o / ||</li>
<li>与：-a / &amp;&amp;</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或逻辑用 -o</span></span><br><span class="line">if [ condition1 -a condition2 ]; then</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或逻辑用 ||</span></span><br><span class="line">if [ condiditon1 ] &amp;&amp; [ condition2 ]; then</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h4 id="数字比较"><a class="header-anchor" href="#数字比较">¶</a>数字比较</h4>
<p>TODO</p>
<h4 id="判断文件"><a class="header-anchor" href="#判断文件">¶</a>判断文件</h4>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e filename</td>
<td>如果文件存在则为真</td>
</tr>
<tr>
<td>-d filename</td>
<td>如果filename是目录则为真</td>
</tr>
<tr>
<td>-f filename</td>
<td>如果filename是常规文件则为真</td>
</tr>
<tr>
<td>-L filename</td>
<td>符号链接</td>
</tr>
<tr>
<td>-c filename</td>
<td>字符文件</td>
</tr>
<tr>
<td>-b filename</td>
<td>块文件</td>
</tr>
<tr>
<td>-r filenmae</td>
<td>文件可读</td>
</tr>
<tr>
<td>-w filenmae</td>
<td>文件可写</td>
</tr>
<tr>
<td>-x filename</td>
<td>文件可执行</td>
</tr>
</tbody>
</table>
<h3 id="循环语句for"><a class="header-anchor" href="#循环语句for">¶</a>循环语句for</h3>
<p><code>for</code>语句的基本语法如下。<code>range</code>变量包含一系列的值，从<code>range</code>中依次取出值并赋给<code>item</code>。可以在<code>range</code>的位置使用任何命令构造一系列的值。循环体可以使用<code>continue</code>或<code>break</code>关键字。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for item in range</span><br><span class="line">do</span><br><span class="line">    echo $item</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>例如，遍历当前目录的所有文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果文件名包含空格，则下面的代码无法正常工作</span></span><br><span class="line">for file in $(ls)</span><br><span class="line">do</span><br><span class="line">    echo &quot;$file&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="循环语句while"><a class="header-anchor" href="#循环语句while">¶</a>循环语句while</h3>
<p>基本语法如下。循环体可以使用<code>continue</code>或<code>break</code>关键字。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TODO: 补充<span class="keyword">do</span> <span class="keyword">while</span></span></span><br></pre></td></tr></table></figure>
<h3 id="分支语句case"><a class="header-anchor" href="#分支语句case">¶</a>分支语句case</h3>
<p><code>case</code>语句的基本语法如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $var in</span><br><span class="line">匹配模式1)</span><br><span class="line">    # do something</span><br><span class="line">    ;;</span><br><span class="line">匹配模式2)</span><br><span class="line">    # do other something</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    # 未匹配上述任何模式</span><br><span class="line">    ;;</span><br><span class="line">esca</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h2>
<p>定义函数的基本语法如下。在脚本中使用<code>funcname</code>即可调用函数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function funcname()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数参数"><a class="header-anchor" href="#函数参数">¶</a>函数参数</h3>
<p>与shell脚本的参数一致，具体请参考<a href="#%E5%8F%82%E6%95%B0">参数</a>一节。注意<code>$0</code>不是函数名，依旧还是脚本的文件名。</p>
<h3 id="函数返回值"><a class="header-anchor" href="#函数返回值">¶</a>函数返回值</h3>
<p>在函数中，可以通过<code>return</code>关键字(提前)返回。<code>return</code>关键字可以携带一个参数，表示函数的返回值。通过变量<code>$?</code>可以获取函数的返回值。</p>
<p>示例代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function fun()</span><br><span class="line">&#123;</span><br><span class="line">        echo &quot;retutn with 2&quot;</span><br><span class="line">        return 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun</span><br><span class="line">echo &quot;fun return value is $?&quot;</span><br></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">retutn with 2</span><br><span class="line">fun return value is 2</span><br></pre></td></tr></table></figure>
<h3 id="函数返回字符串"><a class="header-anchor" href="#函数返回字符串">¶</a>函数返回字符串</h3>
<p><code>return</code>只能返回一个数字，不能返回字符串。可以在函数中使用<code>echo</code>输出字符串，然后将输出赋值给一个变量。如下是示例代码。注意函数的调用方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function func()</span><br><span class="line">&#123;</span><br><span class="line">        echo func</span><br><span class="line">        return 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var=$(func)     # 使用 $() 调用函数</span><br><span class="line">ret=$?</span><br><span class="line">echo var=$var</span><br><span class="line">echo ret=$ret</span><br></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@pkserver test]# ./function_return_string.sh</span><br><span class="line">var=func</span><br><span class="line">ret=2</span><br></pre></td></tr></table></figure>
<h2 id="eval"><a class="header-anchor" href="#eval">¶</a>eval</h2>
<p>在命令前加上<code>eval</code>，会对命令扫描两遍。第一遍扫描会进行替换，第二遍执行指令。一般用于实现一遍扫描无法实现的功能。考虑如下指令，第一遍扫描会替换成<code>echo 1</code>，第二遍扫描执行指令，输出1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var=1</span><br><span class="line">eval echo $var</span><br></pre></td></tr></table></figure>
<p>下面给出<code>eval</code>的两种应用场景。</p>
<h3 id="变量名中包含变量"><a class="header-anchor" href="#变量名中包含变量">¶</a>变量名中包含变量</h3>
<p>有些时候不同的变量包含了类似的数据，只是在不同的情况下选择不同的数据。如果使用<code>if</code>语句，<code>if</code>语句可能会写的很长。如果增加了一种类别，改动的地方也比较多。可以用<code>eval</code>解决这个问题。</p>
<p>假如有一个图书管理系统，现在有三种书，分别是math、computer、novel。现在要查询每种类别下有哪些书籍，可以使用<code>eval</code>完成。假如用户输入的是<code>math</code>，<code>eval</code>第一遍扫描会替换成<code>echo $BOOK_math</code>，第二遍正常执行指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">BOOK_math=&quot;高等数学 立体几何 复变函数 高等代数&quot;</span><br><span class="line">BOOK_computer=&quot;C语言程序设计 汇编语言程序设计 C++语言程序设计&quot;</span><br><span class="line">BOOK_novel=&quot;教父 亮剑 巴黎圣母院&quot;</span><br><span class="line"></span><br><span class="line">while read -p &quot;请输入类别： &quot; choice</span><br><span class="line">do</span><br><span class="line">    BOOK=$(eval echo \$BOOK_$choice)</span><br><span class="line">    if [ ! &quot;$BOOK&quot; ]; then</span><br><span class="line">        echo &quot;糟糕，没有对应的书籍&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;现在有的书籍是：$BOOK&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>下面是示例输出。只需要输入对应的类别，就能输出对应的书籍。如果要增加新的类别，只需要新定义一个变量即可，后面的处理代码不需要更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">请输入类别： math</span><br><span class="line">现在有的书籍是：高等数学 立体几何 复变函数 高等代数</span><br><span class="line">请输入类别： computer</span><br><span class="line">现在有的书籍是：C语言程序设计 汇编语言程序设计 C++语言程序设计</span><br><span class="line">请输入类别： nomath</span><br><span class="line">糟糕，没有对应的书籍</span><br><span class="line">请输入类别：</span><br></pre></td></tr></table></figure>
<h3 id="向函数传递变量"><a class="header-anchor" href="#向函数传递变量">¶</a>向函数传递变量</h3>
<p>通过函数参数只能传递字符串。但有些时候需要对全局变量进行操作，如果写死，则函数变得非常专一，无法通用。可以通过<code>eval</code>解决这个问题。</p>
<p>考虑下面对变量进行排序和去重的函数。将变量名作为函数参数，函数中通过变量名获取变量的值、通过变量名对变量进行赋值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">list1=&quot;3 8 5 2 9 1 3 5 8&quot;</span><br><span class="line">list2=&quot;9 45 6 32 48 75 5 25 45 9&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$1</span> var name</span></span><br><span class="line">function sort_and_uniq()</span><br><span class="line">&#123;</span><br><span class="line">        local var_name=$1</span><br><span class="line">        if [ ! &quot;$var_name&quot; ]; then</span><br><span class="line">                return 0</span><br><span class="line">        fi</span><br><span class="line">        local var=$(eval echo \$$var_name)  # 通过变量名获取变量的值</span><br><span class="line">        if [ ! &quot;$var&quot; ]; then</span><br><span class="line">                echo &quot;$var_name is null&quot;</span><br><span class="line">                return 1</span><br><span class="line">        fi</span><br><span class="line">        var=$(echo $var | tr &#x27; &#x27; &#x27;\n&#x27; | sort -n -u | tr &#x27;\n&#x27; &#x27; &#x27;)</span><br><span class="line">        eval $var_name=\$var                # 通过变量名进行赋值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort_and_uniq &quot;list1&quot;</span><br><span class="line">sort_and_uniq &quot;list2&quot;</span><br><span class="line">sort_and_uniq &quot;list3&quot;</span><br><span class="line">echo &quot;list1=$list1&quot;</span><br><span class="line">echo &quot;list2=$list2&quot;</span><br></pre></td></tr></table></figure>
<p>下面示例代码的输出。可以看出，函数正确实现了其功能，并且能识别出值为空的变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@pkserver test]# ./eval_function.sh</span><br><span class="line">list3 is null</span><br><span class="line">list1=1 2 3 5 8 9</span><br><span class="line">list2=5 6 9 25 32 45 48 75</span><br></pre></td></tr></table></figure>
<h2 id="判断命令是否有效"><a class="header-anchor" href="#判断命令是否有效">¶</a>判断命令是否有效</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if ! type -t command &gt; /dev/null; then</span><br><span class="line">    echo &quot;command not exits, please check&quot;</span><br><span class="line">    exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h2>
<h2 id="数学运算"><a class="header-anchor" href="#数学运算">¶</a>数学运算</h2>
<h2 id="log"><a class="header-anchor" href="#log">¶</a>log</h2>
]]></content>
  </entry>
  <entry>
    <title>C陷阱与缺陷</title>
    <url>/2021/06/c-traps-and-pitfalls/</url>
    <content><![CDATA[<p>《C陷阱与缺陷》读书笔记，包含各个章节的主要内容。</p>
<span id="more"></span>
<p>书籍封面</p>
<p><img src="https://image.pkemb.com/image/20210615093117.png" alt=""></p>
<h2 id="词法陷阱"><a class="header-anchor" href="#词法陷阱">¶</a>词法陷阱</h2>
<ul>
<li>程序中的单个字符孤立来看并没有什么意义，只有结合上下文才有意义。</li>
<li><code>=</code>不同于<code>==</code>。<code>=</code>是赋值运算符，其运算结果是右边表达式的取值。<code>==</code>是比较运算符，其运算结果是0（不等）或1（相等）。</li>
<li><code>&amp;</code>不同于<code>&amp;&amp;</code>。<code>&amp;</code>是位与运算符，<code>&amp;&amp;</code>是逻辑与。</li>
<li><code>|</code>不同于<code>||</code>。<code>|</code>是位或运算符，<code>||</code>是逻辑或。</li>
<li>词法分析中的贪心法：每个符号应该包含尽可能多的字符，符号的中间不能有空白（空格符、制表符和换行符）。
<ul>
<li><code>a---b</code>和<code>a -- - b</code>的含义相同，而与<code>a - -- b</code>的含义不同。</li>
<li>合理的利用空格和括号，进行符号分隔。</li>
</ul>
</li>
<li>C语言可以表示三种字面常量，以<code>0x</code>开头的十六进制，以<code>0</code>开头的八进制，其余是十进制。注意每种进制下的有效字符集。</li>
<li>用单引号引起的一个字符实际上代表一个<code>整数</code>，一般是ASCII。用双引号引其的字符串，代表的是一个指向无名数组起始字符的<code>指针</code>。</li>
</ul>
<h2 id="词法陷阱-v2"><a class="header-anchor" href="#词法陷阱-v2">¶</a>词法陷阱</h2>
<h3 id="理解函数声明"><a class="header-anchor" href="#理解函数声明">¶</a>理解函数声明</h3>
<p>利用<code>typedef</code>简化包含函数指针的函数声明。</p>
<h3 id="运算符的优先级问题"><a class="header-anchor" href="#运算符的优先级问题">¶</a>运算符的优先级问题</h3>
<p>C语言运算符优先级表：TODO</p>
<p>优先级从低到高依次为：</p>
<ul>
<li>数组下标、函数调用、结构成员选择，自左向右。</li>
<li>单目运算符</li>
<li>双目运算符
<ul>
<li>算术运算</li>
<li>移位运算</li>
<li>关系运算：<code>==</code>和<code>!=</code>低于其他关系运算符</li>
<li>逻辑运算：从高到低依次为：&amp; ^ | &amp;&amp; ||</li>
<li>赋值运算</li>
</ul>
</li>
<li>条件运算符（? :）</li>
<li>逗号运算符</li>
</ul>
<h3 id="注意作为语句结束标志的分号"><a class="header-anchor" href="#注意作为语句结束标志的分号">¶</a>注意作为语句结束标志的分号</h3>
<ul>
<li>if语句和while语句的后面<code>不要</code>加分号</li>
<li>return语句、结构体和联合体定义的后面<code>要</code>加分号。</li>
</ul>
<h3 id="switch语句"><a class="header-anchor" href="#switch语句">¶</a>switch语句</h3>
<p>每个<code>case</code>语句最好都加上一个<code>break</code>语句，如果确实不用加，请注释说明。<code>case</code>作为入口，只在遇到<code>break</code>或<code>switch</code>结束时，退出<code>switch</code>语句。</p>
<h3 id="函数调用"><a class="header-anchor" href="#函数调用">¶</a>函数调用</h3>
<p>在函数调用时即使函数不带参数，也应该包括参数列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f();</span><br></pre></td></tr></table></figure>
<h3 id="悬挂else引发的问题"><a class="header-anchor" href="#悬挂else引发的问题">¶</a>悬挂else引发的问题</h3>
<p><code>else</code>始终与同一对括号内最近的未匹配的<code>if</code>结合。</p>
<h2 id="语义陷阱"><a class="header-anchor" href="#语义陷阱">¶</a>语义陷阱</h2>
<p>本章列出了若干种可能引起歧义的程序书写方式。</p>
<h3 id="指针与数组"><a class="header-anchor" href="#指针与数组">¶</a>指针与数组</h3>
<p>C语言的数组应该注意以下两点：</p>
<ul>
<li>C语言只有一维数组，数组大小在编译期就作为一个常数确定。数组元素可以是任何类型的对象，可以仿真出多维数组。</li>
<li>对于一个数组，只能获取数组大小、获取指向数组下标为0的元素的指针。其余操作都是通过指针进行的。</li>
</ul>
<p>考虑以下的数组，该数组拥有12个元素，每个元素都是一个拥有31个整型元素的数组。<code>sizeof(calendar)</code>的值是<code>12*31*sizeof(int)</code>。在其他场合，<code>calendar</code>会被转换成一个指向<code>calendar</code>数组的起始元素的指针，其类型是<code>int(*)[31]</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> calendar[<span class="number">12</span>][<span class="number">31</span>];</span><br></pre></td></tr></table></figure>
<p>指针加1，表示指向下一个元素。</p>
<h3 id="非数组的指针"><a class="header-anchor" href="#非数组的指针">¶</a>非数组的指针</h3>
<h3 id="作为参数的数组声明"><a class="header-anchor" href="#作为参数的数组声明">¶</a>作为参数的数组声明</h3>
<p>使用数组名作为参数，那么数组名会立刻转换为指向该数组第1个元素的指针。</p>
<h3 id="避免举隅法"><a class="header-anchor" href="#避免举隅法">¶</a>避免举隅法</h3>
<p>复制指针并不同时复制指针所指向的数据。</p>
<h3 id="空指针并非空字符串"><a class="header-anchor" href="#空指针并非空字符串">¶</a>空指针并非空字符串</h3>
<h3 id="边界计算与不对称边界"><a class="header-anchor" href="#边界计算与不对称边界">¶</a>边界计算与不对称边界</h3>
<h3 id="求值顺序"><a class="header-anchor" href="#求值顺序">¶</a>求值顺序</h3>
<ul>
<li>a &amp;&amp; b 如果a为假，则b不会求值</li>
<li>a || b 如果a为真，则b不会求值</li>
<li>a ? b : c 如果a为真，只有b会求值；否则只有c会求值</li>
<li>a, b, c  a、b、c顺序求值，a和b的值求值，c的值作为表达式的值</li>
</ul>
<h3 id="运算符-、-和"><a class="header-anchor" href="#运算符-、-和">¶</a>运算符&amp;&amp;、||和!</h3>
<p>逻辑运算与按位运算的区别。</p>
<h3 id="整数溢出"><a class="header-anchor" href="#整数溢出">¶</a>整数溢出</h3>
<h3 id="为函数main提供返回值"><a class="header-anchor" href="#为函数main提供返回值">¶</a>为函数main提供返回值</h3>
<h2 id="链接"><a class="header-anchor" href="#链接">¶</a>链接</h2>
<p>一个C程序可能是由多个分别编译的部分组成，这些不同部分通过一个叫做链接器的程序合并成一个整体。</p>
<h3 id="什么是链接器"><a class="header-anchor" href="#什么是链接器">¶</a>什么是链接器</h3>
<h3 id="声明与定义"><a class="header-anchor" href="#声明与定义">¶</a>声明与定义</h3>
<h3 id="命名冲突与static修饰符"><a class="header-anchor" href="#命名冲突与static修饰符">¶</a>命名冲突与static修饰符</h3>
<p><code>static</code>修饰符号的作用域仅在本文件。</p>
<h3 id="形参、实参与返回值"><a class="header-anchor" href="#形参、实参与返回值">¶</a>形参、实参与返回值</h3>
<h3 id="检查外部类型"><a class="header-anchor" href="#检查外部类型">¶</a>检查外部类型</h3>
<h3 id="头文件"><a class="header-anchor" href="#头文件">¶</a>头文件</h3>
<h2 id="库函数"><a class="header-anchor" href="#库函数">¶</a>库函数</h2>
<p>探讨某些常见的库函数，以及编程者在使用它们的过程中可能的出错之处。</p>
<h3 id="返回整数的getchar函数"><a class="header-anchor" href="#返回整数的getchar函数">¶</a>返回整数的getchar函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="更新顺序文件"><a class="header-anchor" href="#更新顺序文件">¶</a>更新顺序文件</h3>
<p><code>fwrite</code>和<code>fread</code>之间需要调用<code>fseek</code>。</p>
<h3 id="输出缓冲与内存分配"><a class="header-anchor" href="#输出缓冲与内存分配">¶</a>输出缓冲与内存分配</h3>
<p><code>setbuf</code>函数。</p>
<h3 id="使用errno检测错误"><a class="header-anchor" href="#使用errno检测错误">¶</a>使用errno检测错误</h3>
<p>先检查库函数的返回值，出错之后再检查errno。</p>
<h3 id="库函数signal"><a class="header-anchor" href="#库函数signal">¶</a>库函数signal</h3>
<p>信号处理函数是异步执行的。要足够的简单。</p>
<h2 id="预处理器"><a class="header-anchor" href="#预处理器">¶</a>预处理器</h2>
<ul>
<li>修改程序中出现的所有实例。</li>
<li>降低调用开销，</li>
</ul>
<h3 id="不能忽视宏定义中的空格"><a class="header-anchor" href="#不能忽视宏定义中的空格">¶</a>不能忽视宏定义中的空格</h3>
<h3 id="宏并不是函数"><a class="header-anchor" href="#宏并不是函数">¶</a>宏并不是函数</h3>
<h3 id="宏并不是语句"><a class="header-anchor" href="#宏并不是语句">¶</a>宏并不是语句</h3>
<p>如果宏包括多条语句，最好用<code>do&#123; ... &#125;while(0)</code>包裹起来。</p>
<h3 id="宏并不是类型定义"><a class="header-anchor" href="#宏并不是类型定义">¶</a>宏并不是类型定义</h3>
<h2 id="可移植性缺陷"><a class="header-anchor" href="#可移植性缺陷">¶</a>可移植性缺陷</h2>
<h3 id="应对C语言标志变更"><a class="header-anchor" href="#应对C语言标志变更">¶</a>应对C语言标志变更</h3>
<h3 id="标识符名称的限制"><a class="header-anchor" href="#标识符名称的限制">¶</a>标识符名称的限制</h3>
<h3 id="整数的大小"><a class="header-anchor" href="#整数的大小">¶</a>整数的大小</h3>
<h3 id="字符是有符号整数还是无符号整数"><a class="header-anchor" href="#字符是有符号整数还是无符号整数">¶</a>字符是有符号整数还是无符号整数</h3>
<h3 id="移位运算符"><a class="header-anchor" href="#移位运算符">¶</a>移位运算符</h3>
<ul>
<li>无符号数右移空出的位填充0，而有符号数填充0还是符号位，取决于实现。</li>
<li>移位的位数是整数的长度。</li>
</ul>
<h3 id="内存位置0"><a class="header-anchor" href="#内存位置0">¶</a>内存位置0</h3>
<h3 id="除法运算时发生的截断"><a class="header-anchor" href="#除法运算时发生的截断">¶</a>除法运算时发生的截断</h3>
<h3 id="随机数的大小"><a class="header-anchor" href="#随机数的大小">¶</a>随机数的大小</h3>
<h3 id="大小写转换"><a class="header-anchor" href="#大小写转换">¶</a>大小写转换</h3>
<h3 id="首先释放然后重新分配"><a class="header-anchor" href="#首先释放然后重新分配">¶</a>首先释放然后重新分配</h3>
<h2 id="附录A-PRINTF，VARARGS与STDARG"><a class="header-anchor" href="#附录A-PRINTF，VARARGS与STDARG">¶</a>附录A PRINTF，VARARGS与STDARG</h2>
]]></content>
  </entry>
  <entry>
    <title>Scan-IT to Office</title>
    <url>/2021/06/scan-it-to-office/</url>
    <content><![CDATA[<p>Scan-IT to Office是远程条形码扫描和移动数据采集的一体化解决方案。移动应用程序可捕获条形码、文本、数字、位置、图像等数据。云服务会立即将收集的数据传输到任意桌面应用程序(Windows 和 macOS), Excel电子表格、文档、数据库等等。</p>
<span id="more"></span>
<h2 id="官方教程"><a class="header-anchor" href="#官方教程">¶</a>官方教程</h2>
<p><a href="https://www.tec-it.com/zh-cn/software/mobile-data-acquisition/scan-it-to-office/overview/Default.aspx">https://www.tec-it.com/zh-cn/software/mobile-data-acquisition/scan-it-to-office/overview/Default.aspx</a></p>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<p><code>Scan-IT to Office</code>分为两个部分，一个是移动端的APP，另一个是PC端的Office插件。</p>
<h3 id="安卓"><a class="header-anchor" href="#安卓">¶</a>安卓</h3>
<p>在<code>Google Play</code>搜索<code>Scan-IT to Office</code>，点击安装即可。如果无法访问，可以在<a href="https://share.pkemb.com/software/scan-it-to-office/mobile-data-collection-scan-it-to-office_4.5.0%2833460%29.apk">这里</a>下载离线的APK安装包安装。</p>
<h3 id="苹果"><a class="header-anchor" href="#苹果">¶</a>苹果</h3>
<p>在<code>App Store</code>搜索<code>Scan-IT to Office</code>，点击安装即可。</p>
<h3 id="Office插件"><a class="header-anchor" href="#Office插件">¶</a>Office插件</h3>
<p>进入如下链接，点击获取。这个时候需要登录Office账户，选择本机word登录的账户，等待获取完成。然后用word打开即可。</p>
<p><a href="https://appsource.microsoft.com/en-us/product/office/WA104381026?tab=Overview">https://appsource.microsoft.com/en-us/product/office/WA104381026?tab=Overview</a></p>
<img src="https://image.pkemb.com/image/20210613190157.png" style="zoom: 67%;" />
<h2 id="使用方法"><a class="header-anchor" href="#使用方法">¶</a>使用方法</h2>
<h3 id="配对"><a class="header-anchor" href="#配对">¶</a>配对</h3>
<p>打开Word或Excel，可以看到<code>加载项</code>选项卡，在这个选项卡下方，有一个<code>Show</code>命令，点击<code>Show</code>命令。</p>
<p><img src="https://image.pkemb.com/image/20210613190400.png" alt=""></p>
<p>右边会出来一个窗口，可以看到一个二维码。手机打开APP，扫描此二维码即可完成配对。</p>
<blockquote>
<p>如果没有看到二维码，点击添加手机命令即可。</p>
</blockquote>
<img src="https://image.pkemb.com/image/20210613190546.png" style="zoom:67%;" />
<h3 id="扫描"><a class="header-anchor" href="#扫描">¶</a>扫描</h3>
<p>配对完成之后，可以看到如下画面。最下方有4个按钮，从左到右依次是屏幕旋转开关、设备连接详情、表单页面、手动输入。点击中部的扫描按钮，即可开始扫描。扫描完成之后，数据会自动填充到Word或Excel中。</p>
<img src="https://image.pkemb.com/image/20210613213816.png" style="zoom: 33%;" />
<h3 id="自定义表单"><a class="header-anchor" href="#自定义表单">¶</a>自定义表单</h3>
<p>默认只有一个字段，即条形码。如果需要更多的字段，可以点击屏幕下方的第三个按钮，进入表单设置界面。软件给出了9个标准表单，如果没有满足需要的，也可以自定义表单。</p>
<img src="https://image.pkemb.com/image/20210613214442.png" style="zoom: 33%;" />
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>导出不蒜子的访问量数据</title>
    <url>/2021/07/export-busuanzi-data/</url>
    <content><![CDATA[<p>某日突发奇想，想把博客网站的访问数据导出来，看看访问量的变化情况。</p>
<span id="more"></span>
<p>在开发之前，先要确认两件事情。首先是不蒜子有没有提供类似的功能，可以直接将历史访问数据导出来。翻看<a href="https://busuanzi.ibruce.info/">不蒜子官网</a>，发现并没有提供类似的功能。这样好理解，毕竟只是一个极简计数器，没有记录访问时间。第二，有没有人做过类似的扩展。经过一番搜索，发现还真有：<a href="https://chriszheng.science/2019/01/23/Export-busuanzi-data/">导出不蒜子的访问量数据</a>。可惜找来找去，只有这一篇。但是又不太符合自己的需求，只好自己重新开发。主要是别人写的看不懂，自己不会维护( ╯□╰ )。</p>
<h2 id="准备"><a class="header-anchor" href="#准备">¶</a>准备</h2>
<p>首先要定义好需求。定时导出每篇博文的访问量数据，并绘制成可视图形。根据这个需求，有以下点需要实现。</p>
<ol>
<li>利用不蒜子提供的接口，导出一篇博文的访问量数据。</li>
<li>获取博客网站所有博文的URL。</li>
<li>定时执行脚本。</li>
<li>数据可视化：TODO。先按照一定的格式存储到文件中。</li>
</ol>
<h3 id="使用不蒜子的接口获取数据"><a class="header-anchor" href="#使用不蒜子的接口获取数据">¶</a>使用不蒜子的接口获取数据</h3>
<p>根据查询到的资料，和阅读<a href="busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">不蒜子的XML文件</a>，访问如下URL可以获取访问量数据。URL最后的数字是一个随机数，可以不用太关心。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback_1046609647591</span><br></pre></td></tr></table></figure>
<p>使用Chrome打开任何一个添加了不蒜子计数的网站，进入开发者模式，在Network选项卡下，可以找到下图所示的信息。如果没有，刷新一下网页。可以看出，在Header中，通过referer指定查询的URL。经过实验，每访问一次，<code>site_uv</code>、<code>page_pv</code>、<code>site_pv</code>都会增加1。加上cookie后，<code>site_uv</code>不会增加，<code>page_pv</code>和<code>site_pv</code>还是会增加1。cookie是一个32位的UUID。</p>
<img src="https://image.pkemb.com/image/20210711103440.png" style="zoom: 80%;" />
<p>通过curl可以验证这个接口。返回的数据是jsonp格式，需要稍微处理一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# curl -H &#x27;referer: http://test.inc&#x27; -H &#x27;cookie: busuanziId=967989F380504D9E8F3A5FA7B5F9EFAD&#x27; -X GET &#x27;http://busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback_1046609647591&#x27;</span><br><span class="line">try&#123;BusuanziCallback_1046609647591(&#123;&quot;site_uv&quot;:1,&quot;page_pv&quot;:1,&quot;version&quot;:2.4,&quot;site_pv&quot;:1&#125;);&#125;catch(e)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取博客网站所有博文的URL"><a class="header-anchor" href="#获取博客网站所有博文的URL">¶</a>获取博客网站所有博文的URL</h3>
<p>开启sitemap可以达到这个目的，<code>sitemap.xml</code>存储了本网站的所有URL。如果是使用的HEXO，在hexo根目录下执行下面两条命令，开启sitemap功能。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://eericzeng.github.io/2019/07/14/hexo%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9sitemap%E7%9A%84%E4%BD%BF%E7%94%A8">hexo博客站点sitemap的使用</a></p>
<h3 id="定时执行"><a class="header-anchor" href="#定时执行">¶</a>定时执行</h3>
<p>可以在自己的电脑上，或服务器上加个定时任务。但这里决定白嫖<code>Github Actions</code>。定时执行，并将存储到文件的结果commit到GitHub仓库。</p>
<h2 id="脚本实现"><a class="header-anchor" href="#脚本实现">¶</a>脚本实现</h2>
<p>传送门：<a href="https://github.com/pkemb/blog_puv_statistics">https://github.com/pkemb/blog_puv_statistics</a></p>
<h3 id="数据抓取和提交"><a class="header-anchor" href="#数据抓取和提交">¶</a>数据抓取和提交</h3>
<p>脚本<code>export_busuanzi_data.py</code>负责抓取数据，并存储到文件<code>page_puv_statistics_&#123;year&#125;.json</code>。考虑到是用文本文件，长久运行后数据量可能比较大，所以按年分割，存储到不同的文件。</p>
<p>脚本<code>commit.sh</code>负责提交数据到GitHub仓库。</p>
<h3 id="设置Github-actions"><a class="header-anchor" href="#设置Github-actions">¶</a>设置Github actions</h3>
<p><code>Github actions</code>脚本有两点要注意。首先需要设置运行环境，因为脚本需要Python2.7、bs4和lxml，需要在运行之前安装好。这里需要一些语法知识，可以参考<a href="https://docs.github.com/cn/actions">官方文档</a>和阮一峰的<a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></p>
<p>第二是设置<code>deploy key</code>，在提交结果到仓库的时候，不可能手动输入密码，所以要设置<code>deploy key</code>。在本地终端执行下面的指令，<code>-C</code>后面的邮箱换成自己的，也可以换成任意注释字符串。执行完成之后，会得到私钥文件<code>id_rsa</code>和公钥文件<code>id_rsa.pub</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f id_rsa -C &quot;email@email.com&quot;</span><br></pre></td></tr></table></figure>
<p>私钥设置到<code>Actions secrets</code>。进入到仓库的设置界面，点击左下角的<code>Secrets</code>，然后点击右上角的<code>New repository secret</code>。<code>Name</code>可以随意填，后面会用到。<code>Value</code>填文件<code>id_rsa</code>的内容。</p>
<img src="https://image.pkemb.com/image/20210711152408.png" style="zoom:80%;" />
<p>公钥设置到<code>Deploy keys</code>。同样进入仓库的设置界面，左边选择<code>Deploy keys</code>，然后点击右上角的<code>Add deply key</code>。<code>Title</code>随意填，<code>Key</code>填写文件<code>id_rsa.pub</code>的内容。由于是要提交数据，需要勾选下方的<code>Allow write access</code>。</p>
<img src="https://image.pkemb.com/image/20210711152134.png" style="zoom:80%;" />
<p>下方是<code>actions</code>设置<code>key</code>的代码。<code>SECRETS_KEY</code>是<code>Actions secrets</code>的名字，根据实际设置的名字修改即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Deploy</span> <span class="string">Private</span> <span class="string">Key</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">SECRETS_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRETS_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">    echo &quot;$SECRETS_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">    chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">    ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br></pre></td></tr></table></figure>
<h2 id="数据可视化"><a class="header-anchor" href="#数据可视化">¶</a>数据可视化</h2>
<p>TODO，待填坑。</p>
]]></content>
  </entry>
  <entry>
    <title>跟我一起写Makefile - 陈皓</title>
    <url>/2021/07/write-makefile-with-me/</url>
    <content><![CDATA[<p>搬运工。</p>
<span id="more"></span>
<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2>
<p>什么是<code>makefile</code>？或许很多<code>Windows</code>的程序员都不知道这个东西，因为那些<code>Windows</code>的<code>IDE</code>都为你做了这个工作，但我觉得要作一个好的和专业的程序员，<code>makefile</code>还是要懂。这就好像现在有这么多的<code>HTML</code>的编辑器，但如果你想成为一个专业人士，你还是要了解<code>HTML</code>的标签的含义。特别在<code>Unix</code>下的软件编译，你就不能不自己写<code>makefile</code>了，会不会写<code>makefile</code>，从一个侧面说明了一个人是否具备完成大型工程的能力。</p>
<p>因为<code>makefile</code>关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，<code>makefile</code>定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为<code>makefile</code>就像一个<code>Shell</code>脚本一样，其中也可以执行操作系统的命令。<code>makefile</code>带来的好处就是“<code>自动化编译</code>”，一旦写好，只需要一个<code>make</code>命令，整个工程完全自动编译，极大的提高了软件开发的效率。<code>make</code>是一个命令工具，是一个解释<code>makefile</code>中指令的命令工具，一般来说，大多数的<code>IDE</code>都有这个命令，比如：Delphi的<code>make</code>，Visual C++的<code>nmake</code>，Linux下GNU的<code>make</code>。可见，<code>makefile</code>都成为了一种在工程方面的编译方法。</p>
<p>现在讲述如何写<code>makefile</code>的文章比较少，这是我想写这篇文章的原因。当然，不同厂商的<code>make</code>各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992标准的（POSIX.2）。</p>
<p>在这篇文档中，将以<code>C/C++</code>的源码作为我们基础，所以必然涉及一些关于<code>C/C++</code>的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p>
<h2 id="关于程序的编译和链接"><a class="header-anchor" href="#关于程序的编译和链接">¶</a>关于程序的编译和链接</h2>
<p>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是.obj文件，UNIX下是.o文件，即Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫做链接（link）。编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（.o文件或是.obj文件)。</p>
<p>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（.o文件或是.obj文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File），也就是.lib文件，在UNIX下，是Archive File，也就是.a文件。</p>
<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那就会报链接错误（Linker Error），在VC下，这种错误一般是<code>Link 2001</code>错误，意思是说，链接器未能找到函数的实现，你需要指定函数的<code>Object File</code>。好，言归正传，<code>GNU</code>的<code>make</code>有许多的内容，闲言少叙，还是让我们开始吧。</p>
<h2 id="Makefile-介绍"><a class="header-anchor" href="#Makefile-介绍">¶</a>Makefile 介绍</h2>
<p><code>make</code>命令执行时，需要一个<code>Makefile</code>文件，以告诉<code>make</code>命令需要怎么样的去编译和链接程序。</p>
<p>首先，我们用一个示例来说明<code>Makefile</code>的书写规则。以便给大家一个感性认识。这个示例来源于<code>GNU</code>的<code>make</code>使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个<code>Makefile</code>来告诉<code>make</code>命令如何编译和链接这几个文件。我们的规则是：</p>
<ol>
<li>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</li>
<li>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</li>
<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</li>
</ol>
<p>只要我们的<code>Makefile</code>写得够好，所有的这一切，我们只用一个<code>make</code>命令就可以完成，<code>make</code>命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<h3 id="Makefile的规则"><a class="header-anchor" href="#Makefile的规则">¶</a>Makefile的规则</h3>
<p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">	command</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p><code>target</code>也就是一个目标文件，可以是<code>Object File</code>，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。<code>prerequisites</code>就是要生成那个<code>target</code>所需要的文件或是目标。<code>command</code>也就是<code>make</code>需要执行的命令（任意的 Shell 命令）。这是一个文件的依赖关系，也就是说，<code>target</code>这一个或多个的目标文件依赖于<code>prerequisites</code>中的文件，其生成规则定义在<code>command</code>中。说白一点就是说，<code>prerequisites</code>中如果有一个以上的文件比<code>target</code>文件要新的话，<code>command</code>所定义的命令就会被执行。这就是<code>Makefile</code>的规则。也就是<code>Makefile</code>中最核心的内容。</p>
<p>说到底，<code>Makefile</code>的东西就是这样一点，好像我的这篇文档也该结束了。还不尽然，这是<code>Makefile</code>的主线和核心，但要写好一个<code>Makefile</code>还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。:)</p>
<h3 id="一个示例"><a class="header-anchor" href="#一个示例">¶</a>一个示例</h3>
<p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">	cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">	insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">	cc -c main.c</span><br><span class="line"></span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">	cc -c kbd.c</span><br><span class="line"></span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">	cc -c command.c</span><br><span class="line"></span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">	cc -c display.c</span><br><span class="line"></span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">	cc -c insert.c</span><br><span class="line"></span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">	cc -c search.c</span><br><span class="line"></span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">	cc -c files.c</span><br><span class="line"></span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">	cc -c utils.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>反斜杠（\）是换行符的意思。这样比较便于<code>Makefile</code>的易读。我们可以把这个内容保存在文件为“<code>Makefile</code>”或“<code>makefile</code>”的文件中，然后在该目录下直接输入命令“<code>make</code>”就可以生成执行文件<code>edit</code>。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“<code>make clean</code>”就可以了。</p>
<p>在这个<code>makefile</code>中，目标文件（<code>target</code>）包含执行文件<code>edit</code>和中间目标文件（<code>*.o</code>），依赖文件（<code>prerequisites</code>）就是冒号后面的那些<code>.c</code>文件和<code>.h</code>文件。每一个<code>.o</code>文件都有一组依赖文件，而这些<code>.o</code>文件又是执行文件<code>edit</code>的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个<code>Tab键</code>作为开头。记住，<code>make</code>并不管命令是怎么工作的，他只管执行所定义的命令。<code>make</code>会比较<code>targets</code>文件和<code>prerequisites</code>文件的修改日期，如果<code>prerequisites</code>文件的日期要比<code>targets</code>文件的日期要新，或者<code>target</code>不存在的话，那么，<code>make</code>就会执行后续定义的命令。</p>
<p>这里要说明一点的是，<code>clean</code>不是一个文件，它只不过是一个动作名字，有点像C语言中的<code>label</code>一样，其冒号后什么也没有，那么，<code>make</code>就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在<code>make</code>命令后明显得指出这个<code>label</code>的名字。这样的方法非常有用，我们可以在一个<code>makefile</code>中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h3 id="make-是如何工作的"><a class="header-anchor" href="#make-是如何工作的">¶</a>make 是如何工作的</h3>
<p>在默认的方式下，也就是我们只输入<code>make</code>命令。那么，</p>
<ol>
<li><code>make</code>会在当前目录下找名字叫“<code>Makefile</code>”或“<code>makefile</code>”的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（<code>target</code>），在上面的例子中，他会找到“<code>edit</code>”这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果<code>edit</code>文件不存在，或是<code>edit</code>所依赖的后面的<code>.o</code>文件的文件修改时间要比<code>edit</code>这个文件新，那么，他就会执行后面所定义的命令来生成<code>edit</code>这个文件。</li>
<li>如果<code>edit</code>所依赖的<code>.o</code>文件也存在，那么<code>make</code>会在当前文件中找目标为<code>.o</code>文件的依赖性，如果找到则再根据那一个规则生成<code>.o</code>文件（这有点像一个堆栈的过程）。</li>
<li>当然，你的<code>.c</code>文件和<code>.h</code>文件是存在的，于是<code>make</code>会生成<code>.o</code>文件，然后再用<code>.o</code>文件生命<code>make</code>的终极任务，也就是执行文件<code>edit</code>了。</li>
</ol>
<p>这就是整个<code>make</code>的依赖性，<code>make</code>会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么<code>make</code>就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，<code>make</code>根本不理。<code>make</code>只管文件的依赖性，即，如果在找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像<code>clean</code>这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要<code>make</code>执行。即命令：“<code>make clean</code>”，以此来清除所有的目标文件，以便重编译。<br>
于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如<code>file.c</code>，那么根据我们的依赖性，我们的目标<code>file.o</code>会被重编译（也就是在这个依性关系后面所定义的命令），于是<code>file.o</code>的文件也是最新的啦，于是<code>file.o</code>的文件修改时间要比<code>edit</code>要新，所以<code>edit</code>也会被重新链接了（详见<code>edit</code>目标文件后定义的命令）。而如果我们改变了“<code>command.h</code>”，那么，<code>kdb.o</code>、<code>command.o</code>和<code>files.o</code>都会被重编译，并且，<code>edit</code>会被重链接。</p>
<h3 id="makefile中使用变量"><a class="header-anchor" href="#makefile中使用变量">¶</a>makefile中使用变量</h3>
<p>在上面的例子中，先让我们看看edit的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">	cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>[.o]</code>文件的字符串被重复了两次，如果我们的工程需要加入一个新的<code>[.o]</code>文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在<code>clean</code>中）。当然，我们的<code>makefile</code>并不复杂，所以在两个地方加也不累，但如果<code>makefile</code>变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了<code>makefile</code>的易维护，在<code>makefile</code>中我们可以使用变量。<code>makefile</code>的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p>
<p>比如，我们声明一个变量，叫<code>objects</code>，<code>OBJECTS</code>，<code>objs</code>，<code>OBJS</code>，<code>obj</code>，或是<code>OBJ</code>，反正不管什么啦，只要能够表示<code>obj</code>文件就行了。我们在<code>makefile</code>一开始就这样定义：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>于是，我们就可以很方便地在我们的<code>makefile</code>中以“<code>$(objects)</code>”的方式来使用这个变量了，于是我们的改良版<code>makefile</code>就变成下面这个样子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">	cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">	cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">	cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">	cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">	cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">	cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">	cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">	cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">	cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">	rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>于是如果有新的<code>.o</code>文件加入，我们只需简单地修改一下<code>objects</code>变量就可以了。关于变量更多的话题，我会在后续给你一一道来。</p>
<h3 id="让make自动推导"><a class="header-anchor" href="#让make自动推导">¶</a>让make自动推导</h3>
<p>GNU的<code>make</code>很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个<code>[.o]</code>文件后都写上类似的命令，因为，我们的<code>make</code>会自动识别，并自己推导命令。</p>
<p>只要<code>make</code>看到一个<code>[.o]</code>文件，它就会自动的把<code>[.c]</code>文件加在依赖关系中，如果<code>make</code>找到一个<code>whatever.o</code>，那么<code>whatever.c</code>就会是<code>whatever.o</code>的依赖文件。并且<code>cc -c whatever.c</code>也会被推导出来，于是，我们的<code>makefile</code>再也不用写得这么复杂。我们的是新的<code>makefile</code>又出炉了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">	cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line"></span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line"></span><br><span class="line">command.o : defs.h command.h</span><br><span class="line"></span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line"></span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line"></span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line"></span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line"></span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这种方法，也就是<code>make</code>的“<code>隐晦规则</code>”。上面文件内容中，“<code>.PHONY</code>”表示<code>clean</code>是个伪目标文件。关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。</p>
<h3 id="另类风格的makefile"><a class="header-anchor" href="#另类风格的makefile">¶</a>另类风格的makefile</h3>
<p>既然我们的make可以自动推导命令，那么我看到那堆<code>[.o]</code>和<code>[.h]</code>的依赖就有点不爽，那么多的重复的<code>[.h]</code>，能不能把其收拢起来，好吧，没有问题，这个对于<code>make</code>来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的<code>makefile</code>吧。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">	cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line"></span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line"></span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这种风格，让我们的<code>makefile</code>变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得，还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>
<h3 id="清空目标文件的规则"><a class="header-anchor" href="#清空目标文件的规则">¶</a>清空目标文件的规则</h3>
<p>每个<code>Makefile</code>中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>更为稳健的做法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	-rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>前面说过，<code>.PHONY</code>意思表示<code>clean</code>是一个“<code>伪目标</code>”。而在rm命令前面加了一个<code>小减号</code>的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，<code>clean</code>的规则不要放在文件的开头，不然，这就会变成<code>make</code>的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。</p>
<p>上面就是一个<code>makefile</code>的概貌，也是<code>makefile</code>的基础，下面还有很多<code>makefile</code>的相关细节，准备好了吗？准备好了就来。</p>
<h2 id="Makefile总述"><a class="header-anchor" href="#Makefile总述">¶</a>Makefile总述</h2>
<h3 id="Makefile里有什么？"><a class="header-anchor" href="#Makefile里有什么？">¶</a>Makefile里有什么？</h3>
<p><code>Makefile</code>里主要包含了五个东西：<code>显式规则</code>、<code>隐晦规则</code>、<code>变量定义</code>、<code>文件指示</code>和<code>注释</code>。</p>
<ol>
<li>显式规则。显式规则说明了如何生成一个或多个的目标文件。这是由<code>Makefile</code>的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li>
<li>隐晦规则。由于我们的<code>make</code>有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写<code>Makefile</code>，这是由<code>make</code>所支持的。</li>
<li>变量的定义。在<code>Makefile</code>中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，当<code>Makefile</code>被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示。其包括了三个部分，一个是在一个<code>Makefile</code>中引用另一个<code>Makefile</code>，就像C语言中的<code>include</code>一样；另一个是指根据某些情况指定<code>Makefile</code>中的有效部分，就像C语言中的预编译<code>#if</code>一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li>
<li>注释。<code>Makefile</code>中只有行注释，和<code>UNIX</code>的<code>Shell</code>脚本一样，其注释是用“<code>#</code>”字符，这个就像<code>C/C++</code>中的“<code>//</code>”一样。如果你要在你的<code>Makefile</code>中使用“<code>#</code>”字符，可以用反斜线进行转义，如：“<code>\#</code>”。</li>
</ol>
<p>最后，还值得一提的是，在Makefile中的命令必须要以<code>[Tab]</code>键开始。</p>
<h3 id="Makefile的文件名"><a class="header-anchor" href="#Makefile的文件名">¶</a>Makefile的文件名</h3>
<p>默认的情况下，<code>make</code>命令会在当前目录下按顺序找寻文件名为“<code>GNUmakefile</code>”、“<code>makefile</code>”、“<code>Makefile</code>”的文件，找到了解释这个文件。在这三个文件名中，最好使用“<code>Makefile</code>”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“<code>GNUmakefile</code>”，这个文件是GNU的make识别的。有另外一些make只对全小写的“<code>makefile</code>”文件名敏感，但是基本上来说，大多数的<code>make</code>都支持“<code>makefile</code>”和“<code>Makefile</code>”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“<code>-f</code>”和“<code>--file</code>”参数，如：<code>make -f Make.Linux</code>或<code>make --file Make.AIX</code>。</p>
<h3 id="引用其它的Makefile"><a class="header-anchor" href="#引用其它的Makefile">¶</a>引用其它的Makefile</h3>
<p>在<code>Makefile</code>使用<code>include</code>关键字可以把别的<code>Makefile</code>包含进来，这很像<code>C</code>语言的<code>#include</code>，被包含的文件会原模原样的放在当前文件的包含位置。<code>include</code>的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><code>filename</code>可以是当前操作系统<code>Shell</code>的文件模式（可以保含路径和通配符），在<code>include</code>前面可以有一些空字符，但是绝<code>不能</code>是<code>[Tab]</code>键开始。<code>include</code>和<code>&lt;filename&gt;</code>可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：<a href="http://a.mk">a.mk</a>、<a href="http://b.mk">b.mk</a>、<a href="http://c.mk">c.mk</a>，还有一个文件叫foo.make，以及一个变量$(bar)，<a href="http://xn--e-nv6ax7gv1b90b.xn--mkf-bj4e.mk">其包含了e.mk和f.mk</a>，那么，下面的语句：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure>
<p><code>make</code>命令开始时，会把找寻<code>include</code>所指出的其它<code>Makefile</code>，并把其内容安置在当前的位置。就好像<code>C/C++</code>的<code>#include</code>指令一样。如果文件都没有指定绝对路径或是相对路径的话，<code>make</code>会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<ol>
<li>如果make执行时，有“<code>-I</code>”或“<code>--include-dir</code>”参数，那么<code>make</code>就会在这个参数所指定的目录下去寻找。</li>
<li>如果目录<code>&lt;prefix&gt;/include</code>（一般是<code>/usr/local/bin</code>或<code>/usr/include</code>）存在的话，make也会去找。</li>
</ol>
<p>如果有文件没有找到的话，<code>make</code>会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成<code>makefile</code>的读取，<code>make</code>会再重试这些没有找到，或是不能读取的文件，如果还是不行，<code>make</code>才会出现一条致命信息。如果你想让<code>make</code>不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">-include</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>其表示，无论include过程中出现什么错误，都不要报错，继续执行。和其它版本make兼容的相关命令是<code>sinclude</code>，其作用和这一个是一样的。</p>
<h3 id="环境变量MAKEFILES"><a class="header-anchor" href="#环境变量MAKEFILES">¶</a>环境变量MAKEFILES</h3>
<p>如果你的当前环境中定义了环境变量<code>MAKEFILES</code>，那么make会把这个变量中的值做一个类似于<code>include</code>的动作。这个变量中的值是其它的<code>Makefile</code>，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h3 id="make的工作方式"><a class="header-anchor" href="#make的工作方式">¶</a>make的工作方式</h3>
<p>GNU的 make工作时的执行步骤入下（想来其它的 make 也是类似）：</p>
<ol>
<li>读入所有的Makefile。</li>
<li>读入被include的其它Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h2 id="书写规则"><a class="header-anchor" href="#书写规则">¶</a>书写规则</h2>
<p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p>
<p>在<code>Makefile</code>中，规则的顺序是很重要的，因为，<code>Makefile</code>中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让<code>make</code>知道你的最终目标是什么。一般来说，定义在<code>Makefile</code>中的目标可能会有很多，但是<code>第一条规则中的目标将被确立为最终的目标</code>。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。<code>make</code>所完成的也就是这个目标。</p>
<p>好了，还是让我们来看一看如何书写规则。</p>
<h3 id="规则举例"><a class="header-anchor" href="#规则举例">¶</a>规则举例</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c defs.h <span class="comment"># foo 模块</span></span><br><span class="line">	cc -c -g foo.c</span><br></pre></td></tr></table></figure>
<p>看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“<code>cc -c -g foo.c</code>”（以Tab键开头）。这个规则告诉我们两件事：</p>
<ol>
<li>文件的依赖关系。foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。</li>
<li>如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了如何生成foo.o这个文件（当然foo.c文件include了defs.h文件）。</li>
</ol>
<h3 id="规则的语法"><a class="header-anchor" href="#规则的语法">¶</a>规则的语法</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">	command</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>或是这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">targets : prerequisites ; command</span><br><span class="line">	command</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p><code>targets</code>是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。</p>
<p><code>command</code>是命令行，如果其不与“<code>target : rerequisites</code>”在一行，那么，必须以<code>[Tab键]</code>开头，如果和<code>prerequisites</code>在一行，那么可以用分号做为分隔（见上）。</p>
<p><code>prerequisites</code>也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。如果命令太长，你可以使用反斜框（‘\’）作为换行符。<code>make</code>对一行上有多少个字符没有限制。规则告诉<code>make</code>两件事，文件的依赖关系和如何成成目标文件。一般来说，<code>make</code>会以UNIX的标准Shell，也就是<code>/bin/sh</code>来执行命令。</p>
<h3 id="在规则中使用通配符"><a class="header-anchor" href="#在规则中使用通配符">¶</a>在规则中使用通配符</h3>
<p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。<code>make</code>支持三各通配符：“<code>*</code>”，“<code>?</code>”和“<code>[...]</code>”。这是和Unix的B-Shell是相同的。波浪号(“~”)字符在文件名中也有比较特殊的用途。如果是“<code>~/test</code>”，这就表示当前用户的<code>$HOME</code>目录下的test目录。而“<code>~hchen/test</code>”则表示用户hchen的宿主目录下的test目录（这些都是Unix下的小知识了，make也支持）。而在<code>Windows</code>或是<code>MS-DOS</code>下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“<code>HOME</code>”而定。</p>
<p>通配符代替了你一系列的文件，如“<code>*.c</code>”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“<code>*</code>”，那么可以用转义字符“<code>\</code>”，如“<code>\*</code>”来表示真实的“<code>*</code>”字符，而不是任意长度的字符串。好吧，还是先来看几个例子吧：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o</span><br></pre></td></tr></table></figure>
<p>上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">print: *.c</span></span><br><span class="line">	lpr -p <span class="variable">$?</span></span><br><span class="line">	touch print</span><br></pre></td></tr></table></figure>
<p>上面这个例子说明了通配符也可以在我们的规则中，目标<code>print</code>依赖于所有的<code>[.c]</code>文件。其中的“<code>$?</code>”是一个自动化变量，我会在后面给你讲述。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure>
<p>上面这个例子，表示了，通配符同样可以用在变量中。并不是说<code>[*.o]</code>会展开，objects的值就是“<code>*.o</code>”。<code>Makefile</code>中的变量其实就是<code>C/C++</code>中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有<code>[.o]</code>的文件名的集合，那么，你可以这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br></pre></td></tr></table></figure>
<p>这种用法由关键字“<code>wildcard</code>”指出，关于<code>Makefile</code>的关键字，我们将在后面讨论。</p>
<h3 id="文件搜寻"><a class="header-anchor" href="#文件搜寻">¶</a>文件搜寻</h3>
<p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当<code>make</code>需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉<code>make</code>，让<code>make</code>在自动去找。</p>
<p><code>Makefile</code>文件中的特殊变量“<code>VPATH</code>”就是完成这个功能的，如果没有指明这个变量，<code>make</code>只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，<code>make</code>就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>
<p>上面的定义指定两个目录，“<code>src</code>”和“<code>../headers</code>”，make会按照这个顺序进行搜索。目录由“冒号”分隔（当然，当前目录永远是最高优先搜索的地方）。另一个设置文件搜索路径的方法是使用make的“vpath”关键字(注意，它是全小写的)，这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>
<ol>
<li>为符合模式<pattern>的文件指定搜索目录<directories>。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt; &lt;directories&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>清除符合模式<pattern>的文件的搜索目录。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>清除所有已被设置好了的文件搜索目录。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span></span><br></pre></td></tr></table></figure>
<p><code>vapth</code>使用方法中的<code>&lt;pattern&gt;</code>需要包含“<code>%</code>”字符。“<code>%</code>”的意思是匹配零或若干字符，例如，“<code>%.h</code>”表示所有以“.h”结尾的文件。<code>&lt;pattern&gt;</code>指定了要搜索的文件集，而<code>&lt;directories&gt;</code>则指定了<code>&lt;pattern&gt;</code>的文件集的搜索的目录。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure>
<p>该语句表示，要求make在“<code>../headers</code>”目录下搜索所有以“<code>.h</code>”结尾的文件（如果某文件在当前目录没有找到的话）。我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的<code>&lt;pattern&gt;</code>，或是被重复了的<code>&lt;pattern&gt;</code>，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo</span><br><span class="line"><span class="keyword">vpath</span> % blish</span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br></pre></td></tr></table></figure>
<p>其表示“<code>.c</code>”结尾的文件，先在“<code>foo</code>”目录，然后是“<code>blish</code>”，最后是“<code>bar</code>”目录。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> % blish</span><br></pre></td></tr></table></figure>
<p>而上面的语句则表示“<code>.c</code>”结尾的文件，先在“<code>foo</code>”目录，然后是“<code>bar</code>”目录，最后才是“<code>blish</code>”目录。</p>
<h3 id="伪目标"><a class="header-anchor" href="#伪目标">¶</a>伪目标</h3>
<p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o temp</span><br></pre></td></tr></table></figure>
<p>正像我们前面例子中的“<code>clean</code>”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用（以“make clean”来使用该目标）。因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“<code>.PHONY</code>”来显示地指明一个目标是“伪目标”，向make 说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>
<p>只要有这个声明，不管是否有“<code>clean</code>”文件，要运行“<code>clean</code>”这个目标，只有“<code>make clean</code>”这样。于是整个过程可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o temp</span><br></pre></td></tr></table></figure>
<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">	cc -o prog1 prog1.o utils.o</span><br><span class="line">prog2 : prog2.o</span><br><span class="line">	cc -o prog2 prog2.o</span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">	cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们知道，<code>Makefile</code>中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，<code>总是被执行的</code>，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“<code>.PHONY : all</code>”声明了“all”这个目标为“伪目标”。</p>
<p>顺便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">	rm program</span><br><span class="line">cleanobj :</span><br><span class="line">	rm *.o</span><br><span class="line">cleandiff :</span><br><span class="line">	rm *.diff</span><br></pre></td></tr></table></figure>
<p>“make clean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。</p>
<h3 id="多目标"><a class="header-anchor" href="#多目标">¶</a>多目标</h3>
<p><code>Makefile</code>的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“<code>$@</code>”（关于自动化变量， 将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">	generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上述规则等价于:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">	generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">	generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>
<p>其中，<code>-$(subst output,,$@)</code>中的“<code>$</code>”表示执行一个<code>Makefile</code>的函数，函数名为<code>subst</code>，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“<code>$@</code>”表示目标的集合，就像一个数组，“<code>$@</code>”依次取出目标，并执行命令。</p>
<h3 id="静态模式"><a class="header-anchor" href="#静态模式">¶</a>静态模式</h3>
<p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span><br><span class="line">	&lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p><code>targets</code>定义了一系列的目标文件，可以有通配符。是目标的一个集合。<code>target-parrtern</code>是指明了<code>targets</code>的模式，也就是的目标集模式。<code>prereq-parrterns</code>是目标的依赖模式，它对<code>target-parrtern</code>形成的模式再进行一次依赖目标的定义。</p>
<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<code>&lt;target-parrtern&gt;</code>定义成“<code>%.o</code>”，意思是我们的<code>&lt;target&gt;</code>集合中都是以“<code>.o</code>”结尾的，而如果我们的<code>&lt;prereq-parrterns&gt;</code>定义成“<code>%.c</code>”，意思是对<code>&lt;target-parrtern&gt;</code>所形成的目标集进行二次定义，其计算方法是，取<code>&lt;target-parrtern&gt;</code>模式中的“<code>%</code>”(也就是去掉了<code>[.o]</code>这个结尾)，并为其加上<code>[.c]</code>这个结尾，形成的新集合。</p>
<p>所以，我们的“目标模式”或是“依赖模式”中都应该有“<code>%</code>”这个字符，如果你的文件名中有“<code>%</code>”那么你可以使用反斜杠“<code>\</code>”进行转义，来标明真实的“<code>%</code>”字符。看一个例子:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，指明了我们的目标从<code>$object</code>中获取，“<code>%.o</code>”表明要所有以“<code>.o</code>”结尾的目标，也就是“<code>foo.o bar.o</code>”，也就是变量<code>$object</code>集合的模式，而依赖模式“<code>%.c</code>”则取模式“<code>%.o</code>”的“<code>%</code>”，也就是“<code>foo bar</code>”，并为其加下“<code>.c</code>”的后缀，于是，我们的依赖目标就是“<code>foo.c bar.c</code>”。而命令中的“<code>$&lt;</code>”和“<code>$@</code>”则是自动化变量，“<code>$&lt;</code>”表示所有的依赖目标集(也就是“<code>foo.c bar.c</code>”)，“<code>$@</code>”表示目标集(也就是“f<code>oo.o bar.o</code>”)。于是，上面的规则展开后等价于下面的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>
<p>试想，如果我们的“<code>%.o</code>”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o, <span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc, <span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">	emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p><code>$(filter %.o, $(files))</code>表示调用Makefile的<code>filter</code>函数，过滤“<code>$filter</code>”集，只要其中模式为“<code>%.o</code>”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。</p>
<h3 id="自动生成依赖性"><a class="header-anchor" href="#自动生成依赖性">¶</a>自动生成依赖性</h3>
<p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“<code>#include &quot;defs.h&quot;</code>”，那么我们的依赖关系应该是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>但是，如果是一个比较大型的工程，你必需清楚哪些<code>.c</code>文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改<code>Makefile</code>，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用<code>C/C++</code>编译的一个功能。大多数的<code>C/C++</code>编译器都支持一个“<code>-M</code>”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc -M main.c</span><br></pre></td></tr></table></figure>
<p>其输出是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的<code>C/C++</code>编译器，你得用“<code>-MM</code>”参数，不然，“<code>-M</code>”参数会把一些标准库的头文件也包含进来。<code>gcc -M main.c</code>的输出是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \</span></span><br><span class="line">/usr/<span class="keyword">include</span>/sys/cdefs.h /usr/<span class="keyword">include</span>/gnu/stubs.h \</span><br><span class="line">/usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="keyword">include</span>/stddef.h \</span><br><span class="line">/usr/<span class="keyword">include</span>/bits/types.h /usr/<span class="keyword">include</span>/bits/pthreadtypes.h \</span><br><span class="line">/usr/<span class="keyword">include</span>/bits/sched.h /usr/<span class="keyword">include</span>/libio.h \</span><br><span class="line">/usr/<span class="keyword">include</span>/_G_config.h /usr/<span class="keyword">include</span>/wchar.h \</span><br><span class="line">/usr/<span class="keyword">include</span>/bits/wchar.h /usr/<span class="keyword">include</span>/gconv.h \</span><br><span class="line">/usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class="keyword">include</span>/stdarg.h \</span><br><span class="line">/usr/<span class="keyword">include</span>/bits/stdio_lim.h</span><br></pre></td></tr></table></figure>
<p><code>gcc -MM main.c</code>的输出则是:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.c defs.h</span></span><br></pre></td></tr></table></figure>
<p>那么，编译器的这个功能如何与我们的<code>Makefile</code>联系在一起呢。因为这样一来，我们的<code>Makefile</code>也要根据这些源文件重新生成，让<code>Makefile</code>自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。<code>GNU</code>组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“<code>name.c</code>”的文件都生成一个“<code>name.d</code>”的<code>Makefile</code>文件，<code>[.d]</code>文件中就存放对应<code>[.c]</code>文件的依赖关系。于是，我们可以写出<code>[.c]</code>文件和<code>[.d]</code>文件的依赖关系，并让<code>make</code>自动更新或自成<code>[.d]</code>文件，并把其包含在我们的主<code>Makefile</code>中，这样，我们就可以自动化地生成每个文件的依赖关系了。这里，我们给出了一个模式规则来产生[.d]文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">	@set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">	sed &#x27;s，\(<span class="variable">$*</span>\)\.o[ :]*，\1.o <span class="variable">$@</span> : ，g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure>
<p>这个规则的意思是，所有的<code>[.d]</code>文件依赖于<code>[.c]</code>文件，“<code>rm -f $@</code>”的意思是删除所有的目标，也就是<code>[.d]</code>文件，第二行的意思是，为每个依赖文件“<code>$&lt;</code>”，也就是<code>[.c]</code>文件生成依赖文件，“<code>$@</code>”表示模式“<code>%.d</code>”文件，如果有一个<code>.c</code>文件是<code>name.c</code>，那么“<code>%</code>”就是“<code>name</code>”，“<code>$$$$</code>”意为一个随机编号，第二行生成的文件有可能是“<code>name.d.12345</code>”，第三行使用<code>sed</code>命令做了一个替换，关于<code>sed</code>命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入<code>[.d]</code>文件的依赖，即把依赖关系:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>转成：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">main.o main.d : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>于是，我们的<code>[.d]</code>文件也会自动更新了，并会自动生成了，当然，你还可以在这个<code>[.d]</code>文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个<code>[.d]</code>文件都包含一个完整的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主<code>Makefile</code>中。我们可以使用<code>Makefile</code>的“<code>include</code>”命令，来引入别的<code>Makefile</code>文件（前面讲过），例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>
<p>上述语句中的“<code>$(sources:.c=.d)</code>”中的“<code>.c=.d</code>”的意思是做一个替换，把变量<code>$(sources)</code>所有<code>[.c]</code>的字串都替换成<code>[.d]</code>，关于这个“替换”的内容，在后面我会有更为详细的讲述。</p>
<p>当然，你得注意次序，因为include是按次来载入文件，最先载入的<code>[.d]</code>文件中的目标会成为默认目标。</p>
<h2 id="书写命令"><a class="header-anchor" href="#书写命令">¶</a>书写命令</h2>
<p>每条规则中的命令和操作系统Shell的命令行是一致的。<code>make</code>会按顺序一条一条的执行命令，每条命令的开头必须以<code>[Tab]</code>键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以<code>Tab</code>键开头的，那么<code>make</code>会认为其是一个空命令。</p>
<p>我们在<code>UNIX</code>下可能会使用不同的<code>Shell</code>，但是<code>make</code>的命令默认是被“<code>/bin/sh</code>”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。</p>
<h3 id="显示命令"><a class="header-anchor" href="#显示命令">¶</a>显示命令</h3>
<p>通常，<code>make</code>会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“<code>@</code>”字符在命令行前，那么，这个命令将不被<code>make</code>显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure>
<p>当make执行时，会输出“<code>正在编译XXX模块......</code>”字串，但不会输出命令，如果没有“<code>@</code>”，那么，make将输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 正在编译 XXX 模块......</span><br><span class="line">正在编译 XXX 模块......</span><br></pre></td></tr></table></figure>
<p>如果make执行时，带入<code>make</code>参数“<code>-n</code>”或“<code>--just-print</code>”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的<code>Makefile</code>，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。而<code>make</code>参数“<code>-s</code>”或“<code>--slient</code>”则是全面禁止命令的显示。</p>
<h3 id="命令执行"><a class="header-anchor" href="#命令执行">¶</a>命令执行</h3>
<p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，<code>make</code>会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是<code>cd</code>命令，你希望第二条命令得在<code>cd</code>之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如： <br>
示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">makefile</span><br><span class="line"><span class="section">exec:</span></span><br><span class="line">	cd /home/hchen</span><br><span class="line">	pwd</span><br></pre></td></tr></table></figure>
<p>示例二:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">	cd /home/hchen; pwd</span><br></pre></td></tr></table></figure>
<p>当我们执行“<code>make exec</code>”时，第一个例子中的<code>cd</code>没有作用，pwd会打印出当前的<code>Makefile</code>目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p>
<p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——<code>/bin/sh</code>来执行命令。但在<code>MS-DOS</code>下有点特殊，因为<code>MS-DOS</code>下没有<code>SHELL</code>环境变量，当然你也可以指定。如果你指定了<code>UNIX</code>风格的目录形式，首先，make会在<code>SHELL</code>所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。<code>MS-DOS</code>中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。</p>
<h3 id="命令出错"><a class="header-anchor" href="#命令出错">¶</a>命令出错</h3>
<p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。<br>
有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。<br>
为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“<code>-</code>”（在Tab键之后），标记为<code>不管命令出不出错都认为是成功的</code>。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -f *.o</span><br></pre></td></tr></table></figure>
<p>还有一个全局的办法是，给make加上“<code>-i</code>”或是“<code>--ignore-errors</code>”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“<code>.IGNORE</code>”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>还有一个要提一下的make的参数的是“<code>-k</code>”或是“<code>--keep-going</code>”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>
<h3 id="嵌套执行make"><a class="header-anchor" href="#嵌套执行make">¶</a>嵌套执行make</h3>
<p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>
<p>其等价于:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>
<p>定义<code>$(MAKE)</code>宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &lt;variable ...&gt;</span><br></pre></td></tr></table></figure>
<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unexport</span> &lt;variable ...&gt;</span><br></pre></td></tr></table></figure>
<p>示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> variable = value</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable = value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> variable := value</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> variable += value</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable += value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure>
<p>如果你要传递所有的变量，那么，只要一个<code>export</code>就行了。后面什么也不用跟，表示传递所有的变量。</p>
<p>需要注意的是，有两个变量，一个是<code>SHELL</code>，一个是<code>MAKEFLAGS</code>，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是<code>MAKEFLAGS</code>变量，其中包含了make的参数信息，如果我们执行“总控 Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p>
<p>但是make命令中的有几个参数并不往下传递，它们是“-C”、“-f”、“-h”、“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure>
<p>如果你定义了环境变量<code>MAKEFLAGS</code>，那么你得确信其中的选项是大家都会用到的，如果其中有“<code>-t</code>”、“<code>-n</code>”和“<code>-q</code>”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p>
<p>还有一个在“嵌套执行”中比较有用的参数，“<code>-w</code>”或是“<code>--print-directory</code>”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make: Entering directory `/home/hchen/gnu/make&#x27;.</span><br></pre></td></tr></table></figure>
<p>而在完成下层make后离开目录时，我们会看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make: Leaving directory `/home/hchen/gnu/make&#x27;</span><br></pre></td></tr></table></figure>
<p>当你使用“<code>-C</code>”参数来指定make下层Makefile时，“<code>-w</code>”会被自动打开的。如果参数中有“<code>-s</code>”（“<code>--slient</code>”）或是“<code>--no-print-directory</code>”，那么，“<code>-w</code>”总是失效的。</p>
<h3 id="定义命令包"><a class="header-anchor" href="#定义命令包">¶</a>定义命令包</h3>
<p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“<code>define</code>”开始，以“<code>endef</code>”结束，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>这里，“<code>run-yacc</code>”是这个命令包的名字，其不要和Makefile中的变量重名。在“<code>define</code>”和“<code>endef</code>”中的两行就是命令序列。这个命令包中的第一个命令是运行<code>yacc</code>程序，因为<code>yacc</code>程序总是生成“<code>y.tab.c</code>”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line">	$(run-yacc)</span><br></pre></td></tr></table></figure>
<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“<code>run-yacc</code>”中的“<code>$^</code>”就是“<code>foo.y</code>”，“<code>$@</code>”就是“<code>foo.c</code>”（有关这种以“<code>$</code>”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h2 id="使用变量"><a class="header-anchor" href="#使用变量">¶</a>使用变量</h2>
<p>在<code>Makefile</code>中的定义的变量，就像是<code>C/C++</code>语言中的宏一样，他代表了一个<code>文本字串</code>，在Makefile中执行的时候其会<code>自动原模原样地展开在所使用的地方</code>。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”、“依赖目标”、“命令”或是Makefile的其它部分中。</p>
<p>变量的命名字可以包含<code>字符</code>、<code>数字</code>，<code>下划线</code>（可以是数字开头），但不应该含有“<code>:</code>”、“<code>#</code>”、“<code>=</code>”或是<code>空字符（空格、回车等）</code>。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p>
<p>有一些变量是很奇怪字串，如“<code>$&lt;</code>”、“<code>$@</code>”等，这些是<code>自动化变量</code>，我会在后面介绍。</p>
<h3 id="变量基础"><a class="header-anchor" href="#变量基础">¶</a>变量基础</h3>
<p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“<code>$</code>”符号，但最好用小括号“<code>()</code>”或是大括号“<code>&#123;&#125;</code>”把变量给包括起来。如果你要使用真实的“<code>$</code>”字符，那么你需要用“<code>$$</code>”来表示。</p>
<p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br><span class="line">program : <span class="variable">$(objects)</span></span><br><span class="line">	cc -o program <span class="variable">$(objects)</span></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br></pre></td></tr></table></figure>
<p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = c</span><br><span class="line">prog.o : prog.<span class="variable">$(foo)</span></span><br><span class="line">	<span class="variable">$(foo)</span><span class="variable">$(foo)</span> -<span class="variable">$(foo)</span> prog.<span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>
<p>展开后得到:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">prog.o : prog.c</span><br><span class="line">	cc -c prog.c</span><br></pre></td></tr></table></figure>
<p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。</p>
<p>另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>
<h3 id="变量中的变量"><a class="header-anchor" href="#变量中的变量">¶</a>变量中的变量</h3>
<p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>
<p>我们执行“make all”将会打出变量$(foo)的值是“Huh?”（$(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）。可见，变量是可以使用后面的变量来定义的。这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(include_dirs)</span> -O</span><br><span class="line">include_dirs = -Ifoo -Ibar</span><br></pre></td></tr></table></figure>
<p>当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS = <span class="variable">$(CFLAGS)</span> -O</span><br></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">A = <span class="variable">$(B)</span></span><br><span class="line">B = <span class="variable">$(A)</span></span><br></pre></td></tr></table></figure>
<p>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“<code>:=</code>”操作符，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
<p>其等价于:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">y := foo bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
<p>值得一提的是，这种方法，前面的变量<code>不能使用后面的变量</code>，只能使用前面已定义好了的变量。如果是这样:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := foo</span><br></pre></td></tr></table></figure>
<p>那么，y的值是“bar”，而不是“foo bar”。</p>
<p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“<code>MAKELEVEL</code>”的使用：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (0，$&#123;MAKELEVEL&#125;)</span><br><span class="line">	cur-dir := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">	whoami := <span class="variable">$(<span class="built_in">shell</span> whoami)</span></span><br><span class="line">	host-type := <span class="variable">$(<span class="built_in">shell</span> arch)</span></span><br><span class="line">	MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure>
<p><code>nullstring</code>是一个<code>Empty</code>变量，其中什么也没有，而我们的<code>space</code>的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“<code>#</code>”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“<code>#</code>”的使用，注释符“<code>#</code>”的这种特性值得我们注意，如果我们这样定义一个变量：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dir := /foo/bar <span class="comment"># directory to put the frobs in</span></span><br></pre></td></tr></table></figure>
<p>dir这个变量的值是“<code>/foo/bar</code>”，后面还跟了<code>4个空格</code>，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p>
<p>还有一个比较有用的操作符是“<code>?=</code>”，先看示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure>
<p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h3 id="变量高级用法"><a class="header-anchor" href="#变量高级用法">¶</a>变量高级用法</h3>
<p>这里介绍两种变量的高级使用方法，第一种是变量值的替换。我们可以替换变量中的共有的部分，其格式是“<code>$(var:a=b)</code>”或是“<code>$&#123;var:a=b&#125;</code>”，其意思是，把变量“<code>var</code>”中所有以“<code>a</code>”字串“结尾”的“<code>a</code>”替换成“<code>b</code>”字串。这里的“结尾”意思是“空格”或是“结束符”。还是看一个示例吧:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure>
<p>这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“<code>a.c b.c c.c</code>”。</p>
<p>另外一种变量替换的技术是以“静态模式”(参见前面章节)定义的，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure>
<p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。</p>
<p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>$(x)</code>的值是“<code>y</code>”，所以<code>$($(x))</code>就是<code>$(y)</code>，于是<code>$(a)</code>的值就是“<code>z</code>”。（注意是“<code>x=y</code>”，而不是“<code>x=$(y)</code>”）。我们还可以使用更多的层次：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">z = u</span><br><span class="line">a := $($(<span class="variable">$(x)</span>))</span><br></pre></td></tr></table></figure>
<p>这里的<code>$(a)</code>的值是“<code>u</code>”，相关的推导留给读者自己去做吧。让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = z</span><br><span class="line">z = Hello</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>
<p>这里的<code>$($(x))</code>被替换成了<code>$($(y))</code>，因为<code>$(y)</code>值是“<code>z</code>”，所以，最终结果是<code>a:=$(z)</code>，也就是“Hello”。再复杂一点，我们再加上函数：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">y = <span class="variable">$(<span class="built_in">subst</span> 1, 2, <span class="variable">$(x)</span>)</span></span><br><span class="line">z = y</span><br><span class="line">a := $($(<span class="variable">$(z)</span>))</span><br></pre></td></tr></table></figure>
<p>这个例子中，“<code>$($($(z)))</code>”扩展为“<code>$($(y))</code>”，而其再次被扩展为“<code>$($(subst 1, 2, $(x)))</code>”。<code>$(x)</code>的值是“<code>variable1</code>”，<code>subst</code>函数把“<code>variable1</code>”中的所有“1”字串替换成“2”字串，于是，“<code>variable1</code>”变成“<code>variable2</code>”，再取其值，所以，最终，<code>$(a)</code>的值就是<code>$(variable2)</code>的值——“<code>Hello</code>”（喔，好不容易）。</p>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line">b = second</span><br><span class="line">all = $($a_$b)</span><br></pre></td></tr></table></figure>
<p>这里的“<code>$a_$b</code>”组成了“first_second”，于是，<code>$(all)</code>的值就是“Hello”。再来看看结合第一种技术的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">a_objects := a.o b.o c.o</span><br><span class="line">1_objects := 1.o 2.o 3.o</span><br><span class="line">sources := $(<span class="variable">$(a1)</span>_objects:.o=.c)</span><br></pre></td></tr></table></figure>
<p>这个例子中，如果<code>$(a1)</code>的值是“<code>a</code>”的话，那么，<code>$(sources)</code>的值就是“<code>a.c b.c c.c</code>”;如果<code>$(a1)</code>的值是“<code>1</code>”，那么<code>$(sources)</code>的值是“<code>1.c 2.c 3.c</code>”。再来看一个这种技术和“函数”与“条件语句”一同使用的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> do_sort</span><br><span class="line">	func := sort</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	func := strip</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">bar := a d b g q c</span><br><span class="line">foo := $(<span class="variable">$(func)</span> <span class="variable">$(bar)</span>)</span><br></pre></td></tr></table></figure>
<p>这个示例中，如果定义了“<code>do_sort</code>”，那么<code>foo := $(sort a d b g q c)</code>，于是<code>$(foo)</code>的值就是“<code>a b c d g q</code>”，而如果没有定义“<code>do_sort</code>”，那么<code>foo := $(sort a d b g q c)</code>，调用的就是<code>strip</code>函数。</p>
<p>当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dir = foo</span><br><span class="line"><span class="variable">$(dir)</span>_sources := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span></span><br><span class="line"><span class="keyword">define</span> <span class="variable">$(dir)</span>_print</span><br><span class="line">lpr $(<span class="variable">$(dir)</span>_sources)</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>这个例子中定义了三个变量“<code>dir</code>”，“<code>foo_sources</code>”和“<code>foo_print</code>”。</p>
<h3 id="追加变量值"><a class="header-anchor" href="#追加变量值">¶</a>追加变量值</h3>
<p>我们可以使用“+=”操作符给变量追加值，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br></pre></td></tr></table></figure>
<p>于是，我们的<code>$(objects)</code>值变成“<code>main.o foo.o bar.o utils.o another.o</code>”（another.o被追加进去了）。使用“<code>+=</code>”操作符，可以模拟为下面的这种例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects := <span class="variable">$(objects)</span> another.o</span><br></pre></td></tr></table></figure>
<p>所不同的是，用“<code>+=</code>”更为简洁。</p>
<p>如果变量之前没有定义过，那么，“<code>+=</code>”会自动变成“<code>=</code>”，如果前面有变量定义，那么“<code>+=</code>”会继承于前次操作的赋值符。如果前一次的是“<code>:=</code>”，那么“<code>+=</code>”会以“<code>:=</code>”作为其赋值符，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable := <span class="variable">$(variable)</span> more</span><br></pre></td></tr></table></figure>
<p>但如果是这种情况:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">variable = value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure>
<p>由于前次的赋值符是“=”，所以“+=”也会以“=”来作为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h3 id="override指示符"><a class="header-anchor" href="#override指示符">¶</a>override指示符</h3>
<p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“<code>override</code>”指示符。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; = &lt;value&gt;</span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt; := &lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>当然，你还可以追加:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; += &lt;more text&gt;</span><br></pre></td></tr></table></figure>
<p>对于多行的变量定义，我们用<code>define</code>指示符，在<code>define</code>指示符前，也同样可以使用<code>override</code>指示符，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> foobar</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<h3 id="多行变量"><a class="header-anchor" href="#多行变量">¶</a>多行变量</h3>
<p>还有一种设置变量值的方法是使用<code>define</code>关键字。使用<code>define</code>关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。</p>
<p><code>define</code>指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以<code>endef</code>关键字结束。其工作方式和“<code>=</code>”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以<code>[Tab]</code>键开头，所以如果你用<code>define</code>定义的命令变量中没有以<code>[Tab]</code>键开头，那么<code>make</code>就不会把其认为是命令。下面的这个示例展示了define的用法：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<h3 id="环境变量"><a class="header-anchor" href="#环境变量">¶</a>环境变量</h3>
<p><code>make</code>运行时的系统环境变量可以在<code>make</code>开始运行时被载入到<code>Makefile</code>文件中，但是如果<code>Makefile</code>中已定义了这个变量，或是这个变量由<code>make</code>命令行带入，那么系统的环境变量的值将被覆盖（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）。</p>
<p>因此，如果我们在环境变量中设置了“·”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果<code>Makefile</code>中定义了<code>CFLAGS</code>，那么则会使用<code>Makefile</code>中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p>
<p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用export关键字来声明（参见前面章节）。</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h3 id="目标变量"><a class="header-anchor" href="#目标变量">¶</a>目标变量</h3>
<p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“<code>$&lt;</code>”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为“<code>Target-specific Variable</code>”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;</span><br><span class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;variable-assignment&gt;</code>可以是前面讲过的各种赋值表达式，如“<code>=</code>”、“<code>:=</code>”、“<code>+=</code>”或是“<code>?=</code>”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由<code>这个目标所引发的所有的规则</code>中去。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br><span class="line">prog.o : prog.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.c</span><br><span class="line">foo.o : foo.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> foo.c</span><br><span class="line">bar.o : bar.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> bar.c</span><br></pre></td></tr></table></figure>
<p>在这个示例中，不管全局的<code>$(CFLAGS)</code>的值是什么，在<code>prog</code>目标，以及其所引发的所有规则中（<code>prog.o foo.o bar.o</code>的规则），<code>$(CFLAGS)</code>的值都是“<code>-g</code>”。</p>
<h3 id="模式变量"><a class="header-anchor" href="#模式变量">¶</a>模式变量</h3>
<p>在GNU的make中，还支持模式变量(<code>Pattern-specific Variable</code>)，通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make 的“模式”一般是至少含有一个“<code>%</code>”的，所以，我们可以以如下方式给所有以<code>[.o]</code>结尾的目标定义目标变量：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure>
<p>同样，模式变量的语法和“目标变量”一样:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;pattern ...&gt; : &lt;variable-assignment&gt;</span><br><span class="line">&lt;pattern ...&gt; : <span class="keyword">override</span> &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure>
<p><code>override</code>同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<h2 id="使用条件判断"><a class="header-anchor" href="#使用条件判断">¶</a>使用条件判断</h2>
<p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h3 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h3>
<p>下面的例子，判断<code>$(CC)</code>变量是否“<code>gcc</code>”，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">	<span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>, gcc)</span><br><span class="line">		<span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line">	<span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字:<code>ifeq</code>、<code>else</code>和<code>endif</code>。<code>ifeq</code>的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。<code>else</code>表示条件表达式为假的情况。<code>endif</code>表示一个条件语句的结束，任何一个条件表达式都应该以<code>endif</code>结束。当我们的变量<code>$(CC)</code>值是“<code>gcc</code>”时，目标foo的规则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">	<span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br></pre></td></tr></table></figure>
<p>而当我们的变量$(CC)值不是“gcc”时(比如“cc”)，目标foo的规则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br></pre></td></tr></table></figure>
<p>当然，我们还可以把上面的那个例子写得更简洁一些:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>，gcc)</span><br><span class="line">	libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">	<span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure>
<h3 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h3>
<p>条件表达式的语法为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">	&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>以及:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">	&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	&lt;text-if-false&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;conditional-directive&gt;</code>表示条件关键字，如“<code>ifeq</code>”。这个关键字有四个。第一个是我们前面所见过的“<code>ifeq</code>”</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(foo)</span>)</span>,)</span><br><span class="line">	&lt;text-if-empty&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>这个示例中使用了“<code>strip</code>”函数，如果这个函数的返回值是空(<code>Empty</code>)，那么<code>&lt;text-if-empty&gt;</code>就生效。</p>
<p>第二个条件关键字是“<code>ifneq</code>”。语法是:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (&lt;arg1&gt;, &lt;arg2&gt; )</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifneq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>其比较参数“arg1”和“arg2”的值是否相同，<code>如果不同则为真</code>。和“<code>ifeq</code>”类似。</p>
<p>第三个条件关键字是“<code>ifdef</code>”。语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure>
<p>如果变量<code>&lt;variable-name&gt;</code>的值非空，那到表达式为真。否则，表达式为假。当然，<code>&lt;variable-name&gt;</code>同样可以是一个函数的返回值。注意，<code>ifdef</code>只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子。示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">	frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># frobozz = yes</span></span><br></pre></td></tr></table></figure>
<p>示例二:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo =</span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">	frobozz = yes</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	frobozz = no</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># frobozz = no</span></span><br></pre></td></tr></table></figure>
<p>第一个例子中，“<code>$(frobozz)</code>”值是“<code>yes</code>”，第二个则是“<code>no</code>”。</p>
<p>第四个条件关键字是“<code>ifndef</code>”。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> &lt;variable-name&gt;</span><br></pre></td></tr></table></figure>
<p>这个我就不多说了，和“<code>ifdef</code>”是相反的意思。</p>
<p>在<code>&lt;conditional-directive&gt;</code>这一行上，多余的空格是被允许的，但是不能以<code>[Tab]</code>键作为开始（不然就被认为是命令）。而注释符“<code>#</code>”同样也是安全的。“<code>else</code>”和“<code>endif</code>”也一样，只要不是以<code>[Tab]</code>键开始就行了。</p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量(如“<code>$@</code>”等)放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h2 id="使用函数"><a class="header-anchor" href="#使用函数">¶</a>使用函数</h2>
<p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当作变量来使用。</p>
<h3 id="函数的调用语法"><a class="header-anchor" href="#函数的调用语法">¶</a>函数的调用语法</h3>
<p>函数调用，很像变量的使用，也是以“<code>$</code>”来标识的，其语法如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>&lt;function&gt;</code>就是函数名，make支持的函数不多。<code>&lt;arguments&gt;</code>是函数的参数，参数间以逗号“<code>,</code>”分隔，而函数名和参数之间以“<code>空格</code>”分隔。函数调用以“<code>$</code>”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“<code>$(subst a，b，$(x))</code>”这样的形式，而不是“<code>$(subst a, b, $&#123;x&#125;)</code>”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p>
<p>还是来看一个示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>, <span class="variable">$(comma)</span>, <span class="variable">$(foo)</span>)</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>$(comma)</code>的值是一个逗号。<code>$(space)</code>使用了<code>$(empty)</code>定义了一个空格，<code>$(foo)</code>的值是“<code>a b c</code>”，<code>$(bar)</code>的定义调用了函数“<code>subst</code>”，这是一个替换函数，这个函数有三个参数，第一个参数是<code>被替换字串</code>，第二个参数是<code>替换字串</code>，第三个参数是<code>替换操作作用的字串</code>。这个函数也就是把<code>$(foo)</code>中的空格替换成逗号，所以$(bar)的值是“a,b,c”。</p>
<h3 id="字符串处理函数"><a class="header-anchor" href="#字符串处理函数">¶</a>字符串处理函数</h3>
<h4 id="subst"><a class="header-anchor" href="#subst">¶</a>subst</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;, &lt;to&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：字符串替换函数——subst。</li>
<li>功能：把字串<text>中的<from>字符串替换成<to>。</li>
<li>返回：函数返回被替换过后的字符串。</li>
<li>示例：把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee, EE, feet on the street)</span></span><br></pre></td></tr></table></figure>
<h4 id="patsubst"><a class="header-anchor" href="#patsubst">¶</a>patsubst</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：模式字符串替换函数——patsubst。</li>
<li>功能：查找<code>&lt;text&gt;</code>中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合模式<code>&lt;pattern&gt;</code>，如果匹配的话，则以<code>&lt;replacement&gt;</code>替换。这里，<code>&lt;pattern&gt;</code>可以包括通配符“<code>%</code>”，表示任意长度的字串。如果<code>&lt;replacement&gt;</code>中也包含“<code>%</code>”，那么，<code>&lt;replacement&gt;</code>中的这个“<code>%</code>”将是<code>&lt;pattern&gt;</code>中的那个“<code>%</code>”所代表的字串。（可以用“<code>\</code>”来转义，以“<code>\%</code>”来表示真实含义的“<code>%</code>”字符）。</li>
<li>返回：函数返回被替换过后的字符串。</li>
<li>示例：把字串“<code>x.c.c bar.c</code>”符合模式<code>[%.c]</code>的单词替换成<code>[%.o]</code>，返回结果是“<code>x.c.o bar.o</code>”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, x.c.c bar.c)</span></span><br></pre></td></tr></table></figure>
<p>备注：这和我们前面“变量章节”说过的相关知识有点相似。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(var:&lt;pattern&gt;=&lt;replacement&gt;)</span></span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;，&lt;replacement&gt;，<span class="variable">$(var)</span>)</span></span><br></pre></td></tr></table></figure>
<p>而</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(var: &lt;suffix&gt;=&lt;replacement&gt;)</span></span><br></pre></td></tr></table></figure>
<p>则相当于</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %&lt;<span class="built_in">suffix</span>&gt;，%&lt;replacement&gt;，<span class="variable">$(var)</span>)</span></span><br></pre></td></tr></table></figure>
<p>例如有：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o baz.o</span><br></pre></td></tr></table></figure>
<p>那么，</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(objects:.o=.c)</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.o, %.c, <span class="variable">$(objects)</span>)</span></span><br></pre></td></tr></table></figure>
<p>是一样的。</p>
<h4 id="strip"><a class="header-anchor" href="#strip">¶</a>strip</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> &lt;string&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：去空格函数——strip。</li>
<li>功能：去掉<code>&lt;string&gt;</code>字串中开头和结尾的空字符。</li>
<li>返回：返回被去掉空格的字符串值。</li>
<li>示例：把字串“<code>a b c</code>”去掉开头和结尾的空格，结果是“<code>a b c</code>”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a b c )</span></span><br></pre></td></tr></table></figure>
<h4 id="findstring"><a class="header-anchor" href="#findstring">¶</a>findstring</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> &lt;find&gt;，&lt;in&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：查找字符串函数。</li>
<li>功能：在字串<code>&lt;in&gt;</code>中查找<code>&lt;find&gt;</code>字串。</li>
<li>返回：如果找到，那么返回<code>&lt;find&gt;</code>，否则返回空字符串。</li>
<li>示例：第一个函数返回“<code>a</code>”字符串，第二个返回“”字符串（空字符串）。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a, a b c)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a, b c)</span></span><br></pre></td></tr></table></figure>
<h4 id="filter"><a class="header-anchor" href="#filter">¶</a>filter</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern...&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：过滤函数。</li>
<li>功能：以<code>&lt;pattern&gt;</code>模式过滤<code>&lt;text&gt;</code>字符串中的单词，保留符合模式<code>&lt;pattern&gt;</code>的单词。可以有多个模式。</li>
<li>返回：返回符合模式<code>&lt;pattern&gt;</code>的字串。</li>
<li>示例：<code>$(filter %.c %.s, $(sources))</code>返回的值是“<code>foo.c bar.c baz.s</code>”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources := foo.c bar.c baz.s ugh.h</span><br><span class="line"><span class="section">foo: <span class="variable">$(sources)</span></span></span><br><span class="line">cc <span class="variable">$(<span class="built_in">filter</span> %.c %.s, <span class="variable">$(sources)</span>)</span> -o foo</span><br></pre></td></tr></table></figure>
<h4 id="filter-out"><a class="header-anchor" href="#filter-out">¶</a>filter-out</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out &lt;pattern...&gt;，&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：反过滤函数。</li>
<li>功能：以<code>&lt;pattern&gt;</code>模式过滤<code>&lt;text&gt;</code>字符串中的单词，去除符合模式<code>&lt;pattern&gt;</code>的单词。可以有多个模式。</li>
<li>返回：返回不符合模式<code>&lt;pattern&gt;</code>的字串。</li>
<li>示例：返回值是“<code>foo.o bar.o</code>”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects=main1.o foo.o main2.o bar.o</span><br><span class="line">mains=main1.o main2.o</span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(mains)</span>, <span class="variable">$(objects)</span>)</span></span><br></pre></td></tr></table></figure>
<h4 id="sort"><a class="header-anchor" href="#sort">¶</a>sort</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> &lt;list&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：排序函数。</li>
<li>功能：给字符串<list>中的单词排序(升序)。</li>
<li>返回：返回排序后的字符串。</li>
<li>示例：返回值是“<code>bar foo lose</code>”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> foo bar lose)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注：sort 函数会去掉<code>&lt;list&gt;</code>中相同的单词。</p>
</blockquote>
<h4 id="word"><a class="header-anchor" href="#word">¶</a>word</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> &lt;n&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取单词函数。</li>
<li>功能：取字符串<code>&lt;text&gt;</code>中第<code>&lt;n&gt;</code>个单词，从1开始。</li>
<li>返回：返回字符串<code>&lt;text&gt;</code>中第<code>&lt;n&gt;</code>个单词。如果<code>&lt;n&gt;</code>比<code>&lt;text&gt;</code>中的单词数要大，那么返回空字符串。</li>
<li>示例：返回值是“<code>bar</code>”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> 2, foo bar baz)</span></span><br></pre></td></tr></table></figure>
<h4 id="wordlist"><a class="header-anchor" href="#wordlist">¶</a>wordlist</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> &lt;s&gt;, &lt;e&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取单词串函数。</li>
<li>功能：从字符串<code>&lt;text&gt;</code>中取出从<code>&lt;s&gt;</code>开始到<code>&lt;e&gt;</code>的单词串。<code>&lt;s&gt;</code>和<code>&lt;e&gt;</code>是一个数字。</li>
<li>返回：返回字符串<code>&lt;text&gt;</code>中从<code>&lt;s&gt;</code>到<code>&lt;e&gt;</code>的单词字串。如果<code>&lt;s&gt;</code>比<code>&lt;text&gt;</code>中的单词数要大，那么返回空字符串。如果<code>&lt;e&gt;</code>大于<code>&lt;text&gt;</code>的单词数，那么返回从<code>&lt;s&gt;</code>开始到<code>&lt;text&gt;</code>结束的单词串。</li>
<li>示例：返回值是“bar baz”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> 2, 3, foo bar baz)</span></span><br></pre></td></tr></table></figure>
<h4 id="words"><a class="header-anchor" href="#words">¶</a>words</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(words &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：单词个数统计函数。</li>
<li>功能：统计<code>&lt;text&gt;</code>中字符串中的单词个数。</li>
<li>返回：返回<code>&lt;text&gt;</code>中的单词数。</li>
<li>示例：返回值是“3”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$(words, foo bar baz)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注：如果我们要取<text>中最后的一个单词，可以使用以下代码。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> $(words &lt;text&gt;)</span>, &lt;text&gt;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="firstword"><a class="header-anchor" href="#firstword">¶</a>firstword</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：首单词函数。</li>
<li>功能：取字符串<text>中的第一个单词。</li>
<li>返回：返回字符串<text>的第一个单词。</li>
<li>示例：返回值是“foo”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> foo bar)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注：这个函数可以用 word 函数来实现。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> 1, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="综合示例"><a class="header-anchor" href="#综合示例">¶</a>综合示例</h4>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> CFLAGS += <span class="variable">$(<span class="built_in">patsubst</span> %, -I%, $(<span class="built_in">subst</span> :, ,<span class="variable">$(VPATH)</span>)</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们的“<code>$(VPATH)</code>”值是“<code>src:../headers</code>”，那么“<code>$(patsubst %, -I%, $(subst :, ,$(VPATH)))</code>”将返回“<code>-Isrc -I../headers</code>”，这正是cc或gcc搜索头文件路径的参数。</p>
<h3 id="文件名操作函数"><a class="header-anchor" href="#文件名操作函数">¶</a>文件名操作函数</h3>
<p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当作一个或是一系列的文件名来对待。</p>
<h4 id="dir"><a class="header-anchor" href="#dir">¶</a>dir</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取目录函数。</li>
<li>功能：从文件名序列<code>&lt;names&gt;</code>中取出目录部分。目录部分是指最后一个反斜杠(“<code>/</code>”)之前的部分。如果没有反斜杠，那么返回“<code>./</code>”。</li>
<li>返回：返回文件名序列<code>&lt;names&gt;</code>的目录部分。</li>
<li>示例：返回值是“<code>src/ ./</code>”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> src/foo.c hacks)</span></span><br></pre></td></tr></table></figure>
<h4 id="notdir"><a class="header-anchor" href="#notdir">¶</a>notdir</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取文件函数。</li>
<li>功能：从文件名序列<code>&lt;names&gt;</code>中取出非目录部分。非目录部分是指最后一个反斜杠(“<code>/</code>”)之后的部分。</li>
<li>返回：返回文件名序列<code>&lt;names&gt;</code>的非目录部分。</li>
<li>示例：返回值是“foo.c hacks”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> src/foo.c hacks)</span></span><br></pre></td></tr></table></figure>
<h4 id="suffix"><a class="header-anchor" href="#suffix">¶</a>suffix</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取后缀函数。</li>
<li>功能：从文件名序列<code>&lt;names&gt;</code>中取出各个文件名的后缀。</li>
<li>返回：返回文件名序列<code>&lt;names&gt;</code>的后缀序列，如果文件没有后缀，则返回空字串。</li>
<li>示例：返回值是“.c .c”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> src/foo.c src-1.0/bar.c hacks)</span></span><br></pre></td></tr></table></figure>
<h4 id="basename"><a class="header-anchor" href="#basename">¶</a>basename</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：取前缀函数。</li>
<li>功能：从文件名序列<code>&lt;names&gt;</code>中取出各个文件名的前缀部分。</li>
<li>返回：返回文件名序列<code>&lt;names&gt;</code>的前缀序列，如果文件没有前缀，则返回空字串。</li>
<li>示例：返回值是“src/foo src-1.0/bar hacks”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> src/foo.c src-1.0/bar.c hacks)</span></span><br></pre></td></tr></table></figure>
<h4 id="addsuffix"><a class="header-anchor" href="#addsuffix">¶</a>addsuffix</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> &lt;<span class="built_in">suffix</span>&gt;, &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：加后缀函数。</li>
<li>功能：把后缀<code>&lt;suffix&gt;</code>加到<code>&lt;names&gt;</code>中的每个单词后面。</li>
<li>返回：返回加过后缀的文件名序列。</li>
<li>示例：返回值是“<code>foo.c bar.c</code>”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> .c, foo bar)</span></span><br></pre></td></tr></table></figure>
<h4 id="addprefix"><a class="header-anchor" href="#addprefix">¶</a>addprefix</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> &lt;prefix&gt;, &lt;names...&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：加前缀函数。</li>
<li>功能：把前缀<prefix>加到<names>中的每个单词前面。</li>
<li>返回：返回加过前缀的文件名序列。</li>
<li>示例：返回值是“src/foo src/bar”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> src/, foo bar)</span></span><br></pre></td></tr></table></figure>
<h4 id="join"><a class="header-anchor" href="#join">¶</a>join</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> &lt;list1&gt;, &lt;list2&gt;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>名称：连接函数。</li>
<li>功能：把<code>&lt;list2&gt;</code>中的单词对应地加到<code>&lt;list1&gt;</code>的单词后面。如果<code>&lt;list1&gt;</code>的单词个数要比<code>&lt;list2&gt;</code>的多，那么，<code>&lt;list1&gt;</code>中的多出来的单词将保持原样。如果<code>&lt;list2&gt;</code>的单词个数要比<code>&lt;list1&gt;</code>多，那么，<code>&lt;list2&gt;</code>多出来的单词将被复制到<code>&lt;list2&gt;</code>中。</li>
<li>返回：返回连接过后的字符串。</li>
<li>示例：返回值是“aaa111 bbb222 333”。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> aaa bbb, 111 222 333)</span></span><br></pre></td></tr></table></figure>
<h3 id="foreach函数"><a class="header-anchor" href="#foreach函数">¶</a>foreach函数</h3>
<p><code>foreach</code>函数和别的函数非常的不一样。因为这个函数是用来做<code>循环</code>用的，<code>Makefile</code>中的<code>foreach</code>函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;, &lt;list&gt;, &lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的意思是，把参数<code>&lt;list&gt;</code>中的单词逐一取出放到参数<code>&lt;var&gt;</code>所指定的变量中，然后再执行<code>&lt;text&gt;</code>所包含的表达式。每一次<code>&lt;text&gt;</code>会返回一个字符串，循环过程中，<code>&lt;text&gt;</code>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<code>&lt;text&gt;</code>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是<code>foreach</code>函数的返回值。</p>
<p>所以，<code>&lt;var&gt;</code>最好是一个变量名，<code>&lt;list&gt;</code>可以是一个表达式，而<code>&lt;text&gt;</code>中一般会使用<code>&lt;var&gt;</code>这个参数来依次枚举<code>&lt;list&gt;</code>中的单词。举个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">names := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> n, <span class="variable">$(names)</span>, <span class="variable">$(n)</span>.o)</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>$(name)</code>中的单词会被挨个取出，并存到变量“<code>n</code>”中，“<code>$(n).o</code>”每次根据“<code>$(n)</code>”计算出一个值，这些值以空格分隔，最后作为<code>foreach</code>函数的返回，所以，<code>$(files)</code>的值是“<code>a.o b.o c.o d.o</code>”。</p>
<p>注意，<code>foreach</code>中的<code>&lt;var&gt;</code>参数是一个临时的局部变量，<code>foreach</code>函数执行完后，参数<code>&lt;var&gt;</code>的变量将不在作用，其作用域只在<code>foreach</code>函数当中。</p>
<h3 id="if函数"><a class="header-anchor" href="#if函数">¶</a>if函数</h3>
<p><code>if</code>函数很像GNU的make所支持的条件语句——<code>ifeq</code>（参见前面所述的<a href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">章节</a>），<code>if</code>函数的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;, &lt;then-part&gt;)</span></span><br></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;, &lt;then-part&gt;, &lt;else-part&gt;)</span></span><br></pre></td></tr></table></figure>
<p>可见，<code>if</code>函数可以包含“<code>else</code>”部分，或是不含。即<code>if</code>函数的参数可以是两个，也可以是三个。<code>&lt;condition&gt;</code>参数是<code>if</code>的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<code>&lt;then-part&gt;</code>会被计算，否则<code>&lt;else-part&gt;</code>会被计算。</p>
<p>而if函数的返回值是，如果<code>&lt;condition&gt;</code>为真（非空字符串），那个<code>&lt;then-part&gt;</code>会是整个函数的返回值，如果<code>&lt;condition&gt;</code>为假（空字符串），那么<code>&lt;else-part&gt;</code>会是整个函数的返回值，此时如果<code>&lt;else-part&gt;</code>没有被定义，那么，整个函数返回空字串。</p>
<p>所以，<code>&lt;then-part&gt;</code>和<code>&lt;else-part&gt;</code>只会有一个被计算。</p>
<h3 id="call函数"><a class="header-anchor" href="#call函数">¶</a>call函数</h3>
<p><code>call</code>函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用<code>call</code>函数来向这个表达式传递参数。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;, &lt;parm1&gt;, &lt;parm2&gt;, &lt;parm3&gt;...)</span></span><br></pre></td></tr></table></figure>
<p>当<code>make</code>执行这个函数时，<code>&lt;expression&gt;</code>参数中的变量，如<code>$(1)</code>、<code>$(2)</code>、<code>$(3)</code>等，会被参数<code>&lt;parm1&gt;</code>、<code>&lt;parm2&gt;</code>、<code>&lt;parm3&gt;</code>依次取代。而<code>&lt;expression&gt;</code>的返回值就是<code>call</code>函数的返回值。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">reverse = $(1) $(2)</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse, a, b)</span></span><br></pre></td></tr></table></figure>
<p>那么，<code>foo</code>的值就是“<code>a b</code>”。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">reverse = $(2) $(1)</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse, a, b)</span></span><br></pre></td></tr></table></figure>
<p>此时的foo的值就是“<code>b a</code>”。</p>
<h3 id="origin函数"><a class="header-anchor" href="#origin函数">¶</a>origin函数</h3>
<p><code>origin</code>函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>&lt;variable&gt;</code>是变量的名字，不应该是引用。所以你最好不要在<code>&lt;variable&gt;</code>中使用“<code>$</code>”字符。<code>Origin</code>函数会以其返回值来告诉你这个变量的“出生情况”，下面是<code>origin</code>函数可能的返回值。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>如果<variable>从来没有定义过，origin函数返回这个值“undefined”。</td>
</tr>
<tr>
<td>default</td>
<td>如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</td>
</tr>
<tr>
<td>environment</td>
<td>如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</td>
</tr>
<tr>
<td>file</td>
<td>如果<variable>这个变量被定义在Makefile中。</td>
</tr>
<tr>
<td>command line</td>
<td>如果<variable>这个变量是被命令行定义的。</td>
</tr>
<tr>
<td>override</td>
<td>如果<variable>是被override指示符重新定义的。</td>
</tr>
<tr>
<td>automatic</td>
<td>如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</td>
</tr>
</tbody>
</table>
<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> bletch</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;$(origin bletch)&quot;</span> <span class="string">&quot;environment&quot;</span></span><br><span class="line">	bletch = barf, gag, etc.</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<h3 id="shell函数"><a class="header-anchor" href="#shell函数">¶</a>shell函数</h3>
<p><code>shell</code>函数也不像其它的函数。顾名思义，它的参数应该就是操作系统<code>Shell</code>的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk、sed等等命令来生成一个变量，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h3 id="控制make的函数"><a class="header-anchor" href="#控制make的函数">¶</a>控制make的函数</h3>
<p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<h4 id="error"><a class="header-anchor" href="#error">¶</a>error</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>产生一个致命的错误，<code>&lt;text ...&gt;</code>是错误信息。注意，<code>error</code>函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如： <br>
示例一：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line"><span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>示例二:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: err</span></span><br><span class="line"><span class="section">err: ; <span class="variable">$(ERR)</span></span></span><br></pre></td></tr></table></figure>
<p>示例一会在变量<code>ERROR_001</code>定义了后执行时产生<code>error</code>调用，而示例二则在目标<code>err</code>被执行时才发生error调用。</p>
<h4 id="warning"><a class="header-anchor" href="#warning">¶</a>warning</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br></pre></td></tr></table></figure>
<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make<code>继续执行</code>。</p>
<h2 id="make的运行"><a class="header-anchor" href="#make的运行">¶</a>make的运行</h2>
<p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h3 id="make的退出码"><a class="header-anchor" href="#make的退出码">¶</a>make的退出码</h3>
<p>make命令执行后有三个退出码：</p>
<ul>
<li>0 —— 表示成功执行。</li>
<li>1 —— 如果make运行时出现任何错误，其返回1。</li>
<li>2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</li>
</ul>
<p>make的相关参数我们会在后续章节中讲述。</p>
<h3 id="指定Makefile"><a class="header-anchor" href="#指定Makefile">¶</a>指定Makefile</h3>
<p>前面我们说过，<code>GNU make</code>找寻默认<code>Makefile</code>的规则是在当前目录下依次找三个文件——“<code>GNUmakefile</code>”、“<code>makefile</code>”和“<code>Makefile</code>”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“–file”参数（“–makefile”参数也行）。例如，我们有个makefile的名字是“<code>hchen.mk</code>”，那么，我们可以这样来让make来执行这个文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f hchen.mk</span><br></pre></td></tr></table></figure>
<p>如果在make的命令行，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>
<h3 id="指定目标"><a class="header-anchor" href="#指定目标">¶</a>指定目标</h3>
<p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后<code>直接跟目标的名字</code>就可以完成（如前面提到的“<code>make clean</code>”形式）。</p>
<p>任何在makefile中的目标都可以被指定成终极目标，但是除了以“<code>-</code>”打头，或是包含了“<code>=</code>”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个<code>make</code>的环境变量叫“<code>MAKECMDGOALS</code>”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(MAKECMDGOALS)</span>，clean)</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>基于上面的这个例子，只要我们输入的命令不是“<code>make clean</code>”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: prog1 prog2 prog3 prog4</span></span><br></pre></td></tr></table></figure>
<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序：“prog1”、“prog2”、“prog3”和“prog4”，我们可以使用“make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。</p>
<p>既然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<table>
<thead>
<tr>
<th>伪目标</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td>所有目标的目标，其功能一般是编译所有的目标。</td>
</tr>
<tr>
<td>clean</td>
<td>删除所有被make创建的文件。</td>
</tr>
<tr>
<td>install</td>
<td>安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</td>
</tr>
<tr>
<td>print</td>
<td>列出改变过的源文件。</td>
</tr>
<tr>
<td>tar</td>
<td>把源程序打包备份。也就是一个tar文件。</td>
</tr>
<tr>
<td>dist</td>
<td>创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</td>
</tr>
<tr>
<td>TAGS</td>
<td>更新所有的目标，以备完整地重编译使用。</td>
</tr>
<tr>
<td>check / test</td>
<td>一般用来测试makefile的流程。</td>
</tr>
</tbody>
</table>
<p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>
<h3 id="检查规则"><a class="header-anchor" href="#检查规则">¶</a>检查规则</h3>
<p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-n</span><br><span class="line">--just-print</span><br><span class="line">--dry-run</span><br><span class="line">--recon</span><br></pre></td></tr></table></figure>
<p>不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-t</span><br><span class="line">--touch</span><br></pre></td></tr></table></figure>
<p>这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-q</span><br><span class="line">--question</span><br></pre></td></tr></table></figure>
<p>这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-W &lt;file&gt;</span><br><span class="line">--what-if=&lt;file&gt;</span><br><span class="line">--assume-new=&lt;file&gt;</span><br><span class="line">--new-file=&lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</p>
<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>
<h3 id="make的参数"><a class="header-anchor" href="#make的参数">¶</a>make的参数</h3>
<p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-b</span><br><span class="line">-m</span><br></pre></td></tr></table></figure>
<p>这两个参数的作用是忽略和其它版本make的兼容性。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-B</span><br><span class="line">--always-make</span><br></pre></td></tr></table></figure>
<p>认为所有的目标都需要更新（重编译）。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-C &lt;dir&gt;</span><br><span class="line">--directory=&lt;dir&gt;</span><br></pre></td></tr></table></figure>
<p>指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。例如<code>make -C ~hchen/test -C prog</code>等价于<code>make -C ~hchen/test/prog</code>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">--debug[=&lt;options&gt;]</span><br></pre></td></tr></table></figure>
<p>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<code>&lt;options&gt;</code>的取值：</p>
<table>
<thead>
<tr>
<th>options</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>all，输出所有的调试信息（会非常的多）。</td>
</tr>
<tr>
<td>b</td>
<td>basic，只输出简单的调试信息。即输出不需要重编译的目标。</td>
</tr>
<tr>
<td>v</td>
<td>verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。</td>
</tr>
<tr>
<td>i</td>
<td>implicit，输出所以的隐含规则。</td>
</tr>
<tr>
<td>j</td>
<td>jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。</td>
</tr>
<tr>
<td>m</td>
<td>makefile，输出make读取makefile，更新makefile，执行makefile的信息。</td>
</tr>
</tbody>
</table>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-d</span><br></pre></td></tr></table></figure>
<p>相当于“–debug=a”。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-e</span><br><span class="line">--environment-overrides</span><br></pre></td></tr></table></figure>
<p>指明环境变量的值覆盖makefile中定义的变量的值。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-f=&lt;file&gt;</span><br><span class="line">--file=&lt;file&gt;</span><br><span class="line">--makefile=&lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>指定需要执行的makefile。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-h</span><br><span class="line">--help</span><br></pre></td></tr></table></figure>
<p>显示帮助信息。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-i</span><br><span class="line">--ignore-errors</span><br></pre></td></tr></table></figure>
<p>在执行时忽略所有的错误。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-I &lt;dir&gt;</span><br><span class="line">--include-dir=&lt;dir&gt;</span><br></pre></td></tr></table></figure>
<p>指定一个被包含makefile的搜索目标。可以使用多个“<code>-I</code>”参数来指定多个目录。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-j [&lt;jobsnum&gt;]</span><br><span class="line">--jobs[=&lt;jobsnum&gt;]</span><br></pre></td></tr></table></figure>
<p>指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。注意这个参数在<code>MS-DOS</code>中是无用的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-k</span><br><span class="line">--keep-going</span><br></pre></td></tr></table></figure>
<p>出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-l &lt;load&gt;</span><br><span class="line">--load-average[=&lt;load]</span><br><span class="line">--max-load[=&lt;load&gt;]</span><br></pre></td></tr></table></figure>
<p>指定make运行命令的负载。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-n</span><br><span class="line">--just-print</span><br><span class="line">--dry-run</span><br><span class="line">--recon</span><br></pre></td></tr></table></figure>
<p>仅输出执行过程中的命令序列，但并不执行。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-o &lt;file&gt;</span><br><span class="line">--old-file=&lt;file&gt;</span><br><span class="line">--assume-old=&lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-p</span><br><span class="line">--print-data-base</span><br></pre></td></tr></table></figure>
<p>输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“<code>make -qp</code>”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“<code>make -p -f /dev/null</code>”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-q</span><br><span class="line">--question</span><br></pre></td></tr></table></figure>
<p>不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-r</span><br><span class="line">--no-builtin-rules</span><br></pre></td></tr></table></figure>
<p>禁止make使用任何隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-R</span><br><span class="line">--no-builtin-variabes</span><br></pre></td></tr></table></figure>
<p>禁止make使用任何作用于变量上的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-s</span><br><span class="line">--silent</span><br><span class="line">--quiet</span><br></pre></td></tr></table></figure>
<p>在命令运行时不输出命令的输出。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-S</span><br><span class="line">--no-keep-going</span><br><span class="line">--stop</span><br></pre></td></tr></table></figure>
<p>取消“<code>-k</code>”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-t</span><br><span class="line">--touch</span><br></pre></td></tr></table></figure>
<p>相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-v</span><br><span class="line">--version</span><br></pre></td></tr></table></figure>
<p>输出make程序的版本、版权等关于make的信息。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-w</span><br><span class="line">--print-directory</span><br></pre></td></tr></table></figure>
<p>输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">--no-print-directory</span><br></pre></td></tr></table></figure>
<p>禁止“-w”选项。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-W &lt;file&gt;</span><br><span class="line">--what-if=&lt;file&gt;</span><br><span class="line">--new-file=&lt;file&gt;</span><br><span class="line">--assume-file=&lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>假定目标<code>&lt;file&gt;</code>需要更新，如果和“<code>-n</code>”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“<code>-n</code>”那么就像运行UNIX的“<code>touch</code>”命令一样，使得<code>&lt;file&gt;</code>的修改时间为当前时间。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">--warn-undefined-variables</span><br></pre></td></tr></table></figure>
<p>只要make发现有未定义的变量，那么就输出警告信息。</p>
<h2 id="隐含规则"><a class="header-anchor" href="#隐含规则">¶</a>隐含规则</h2>
<p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译<code>C/C++</code>的源程序为中间目标文件(Unix下是<code>[.o]</code>文件，Windows下是<code>[.obj]</code>文件)。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把<code>[.c]</code>文件编译成<code>[.o]</code>文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的<code>[.o]</code>文件。</p>
<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“<code>CFLAGS</code>”可以控制编译时的编译器参数。</p>
<p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。</p>
<p>我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<h3 id="使用隐含规则"><a class="header-anchor" href="#使用隐含规则">¶</a>使用隐含规则</h3>
<p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">	cc -o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>我们可以注意到，这个<code>Makefile</code>中并没有写下如何生成<code>foo.o</code>和<code>bar.o</code>这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<p>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把<code>[.o]</code>的目标的依赖文件置成<code>[.c]</code>，并使用C的编译命令“<code>cc -c $(CFLAGS) [.c]</code>”来生成<code>[.o]</code>的目标。也就是说，我们完全没有必要写下下面的两条规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">	cc -c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">	cc -c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“<code>cc</code>”生成<code>[.o]</code>文件的规则，这就是隐含规则。</p>
<p>当然，如果我们为<code>[.o]</code>文件书写了自己的规则，那么<code>make</code>就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo.o : foo.p</span><br></pre></td></tr></table></figure>
<p>依赖文件“<code>foo.p</code>”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“<code>foo.c</code>”文件，那么我们的隐含规则一样会生效，并会通过“<code>foo.c</code>”调用C的编译器生成<code>foo.o</code>文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成<code>foo.o</code>的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>
<h3 id="隐含规则一览"><a class="header-anchor" href="#隐含规则一览">¶</a>隐含规则一览</h3>
<p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“<code>-r</code>”或“<code>--no-builtin-rules</code>”选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了“<code>-r</code>”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”（也就是系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：<code> .out .a	.ln .o .c .cc .C .p .f .F .r .y .l .s .S .mod	.sym .def .h .info .dvi .tex .texinfo .texi .txinfo .w .ch .web .sh .elc .el</code>。具体的细节，我们会在后面讲述。还是先来看一看常用的隐含规则吧。</p>
<h4 id="编译C程序的隐含规则"><a class="header-anchor" href="#编译C程序的隐含规则">¶</a>编译C程序的隐含规则</h4>
<p>“<code>&lt;n&gt;.o</code>”的目标的依赖目标会自动推导为“<code>&lt;n&gt;.c</code>”，并且其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>
<h4 id="编译C-程序的隐含规则"><a class="header-anchor" href="#编译C-程序的隐含规则">¶</a>编译C++程序的隐含规则</h4>
<p><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为“<code>&lt;n&gt;.cc</code>”或是“<code>&lt;n&gt;.C</code>”，并且其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(CXX)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span>”</span><br></pre></td></tr></table></figure>
<p>建议使用“.cc”作为C++源文件的后缀，而不是“.C”。</p>
<h4 id="编译Pascal-程序的隐含规则"><a class="header-anchor" href="#编译Pascal-程序的隐含规则">¶</a>编译Pascal 程序的隐含规则</h4>
<p>“<code>&lt;n&gt;.o</code>”的目标的依赖目标会自动推导为“<code>&lt;n&gt;.p</code>”，并且其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(PC)</span> -c <span class="variable">$(PFLAGS)</span></span><br></pre></td></tr></table></figure>
<h4 id="编译Fortran-Ratfor程序的隐含规则"><a class="header-anchor" href="#编译Fortran-Ratfor程序的隐含规则">¶</a>编译Fortran/Ratfor程序的隐含规则</h4>
<p>“<code>&lt;n&gt;.o</code>”的目标的依赖目标会自动推导为“<code>&lt;n&gt;.r</code>”或“<code>&lt;n&gt;.F</code>”或“<code>&lt;n&gt;.f</code>”，并且其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .f</span></span><br><span class="line"><span class="variable">$(FC)</span> -c <span class="variable">$(FFLAGS)</span></span><br><span class="line">$ .F</span><br><span class="line"><span class="variable">$(FC)</span> -c <span class="variable">$(FFLAGS)</span> <span class="variable">$(CPPFLAGS)</span></span><br><span class="line"><span class="comment"># .r</span></span><br><span class="line"><span class="variable">$(FC)</span> -c <span class="variable">$(FFLAGS)</span> <span class="variable">$(RFLAGS)</span></span><br></pre></td></tr></table></figure>
<h4 id="预处理Fortran-Ratfor程序的隐含规则"><a class="header-anchor" href="#预处理Fortran-Ratfor程序的隐含规则">¶</a>预处理Fortran/Ratfor程序的隐含规则</h4>
<p>“<code>&lt;n&gt;.f</code>”的目标的依赖目标会自动推导为“<code>&lt;n&gt;.r</code>”或“<code>&lt;n&gt;.F</code>”。这个规则只是转换<code>Ratfor</code>或有预处理的<code>Fortran</code>程序到一个标准的<code>Fortran</code>程序。其使用的命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .F</span></span><br><span class="line"><span class="variable">$(FC)</span> -F <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(FFLAGS)</span></span><br><span class="line"><span class="comment"># .r</span></span><br><span class="line"><span class="variable">$(FC)</span> -F <span class="variable">$(FFLAGS)</span> <span class="variable">$(RFLAGS)</span></span><br></pre></td></tr></table></figure>
<h4 id="编译Modula-2程序的隐含规则"><a class="header-anchor" href="#编译Modula-2程序的隐含规则">¶</a>编译Modula-2程序的隐含规则</h4>
<p>“<code>&lt;n&gt;.sym</code>”的目标的依赖目标会自动推导为“<code>&lt;n&gt;.def</code>”，并且其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(M2C)</span> <span class="variable">$(M2FLAGS)</span> <span class="variable">$(DEFFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>“<code>&lt;n.o&gt;</code>”的目标的依赖目标会自动推导为“<code>&lt;n&gt;.mod</code>”，并且其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(M2C)</span> <span class="variable">$(M2FLAGS)</span> <span class="variable">$(MODFLAGS)</span></span><br></pre></td></tr></table></figure>
<h4 id="汇编和汇编预处理的隐含规则"><a class="header-anchor" href="#汇编和汇编预处理的隐含规则">¶</a>汇编和汇编预处理的隐含规则</h4>
<p>“<code>&lt;n&gt;.o</code>”的目标的依赖目标会自动推导为“<code>&lt;n&gt;.s</code>”，默认使用编译器“<code>as</code>”，并且其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASFLAGS)</span>”</span><br></pre></td></tr></table></figure>
<p>“<code>&lt;n&gt;.s</code>”的目标的依赖目标会自动推导为“<code>&lt;n&gt;.S</code>”，默认使用C预编译器“<code>cpp</code>”，并且其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASFLAGS)</span></span><br></pre></td></tr></table></figure>
<h4 id="链接Object文件的隐含规则"><a class="header-anchor" href="#链接Object文件的隐含规则">¶</a>链接Object文件的隐含规则</h4>
<p>“<code>&lt;n&gt;</code>”目标依赖于“<code>&lt;n&gt;.o</code>”，通过运行C的编译器来运行链接程序生成(一般是“ld”)，其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> &lt;n&gt;.o <span class="variable">$(LOADLIBES)</span> <span class="variable">$(LDLIBS)</span></span><br></pre></td></tr></table></figure>
<p>这个规则对于只有一个源文件的工程有效，同时也对多个<code>Object</code>文件（由不同的源文件生成）的也有效。例如如下规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x : y.o z.o</span><br></pre></td></tr></table></figure>
<p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc -c x.c -o x.o</span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line">rm -f x.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure>
<p>如果没有一个源文件(如上例中的<code>x.c</code>)和你的目标名字(如上例中的 x)相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<h4 id="Yacc-C程序时的隐含规则。"><a class="header-anchor" href="#Yacc-C程序时的隐含规则。">¶</a>Yacc C程序时的隐含规则。</h4>
<p>“<code>&lt;n&gt;.c</code>”的依赖文件被自动推导为“<code>n.y</code>”（Yacc生成的文件），其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(YACC)</span> <span class="variable">$(YFALGS)</span></span><br></pre></td></tr></table></figure>
<p>“<code>Yacc</code>”是一个语法分析器，关于其细节请查看相关资料。</p>
<h4 id="Lex-C程序时的隐含规则。"><a class="header-anchor" href="#Lex-C程序时的隐含规则。">¶</a>Lex C程序时的隐含规则。</h4>
<p>“<code>&lt;n&gt;.c</code>”的依赖文件被自动推导为“<code>n.l</code>”（Lex生成的文件），其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(LEX)</span> <span class="variable">$(LFALGS)</span></span><br></pre></td></tr></table></figure>
<p>关于“Lex”的细节请查看相关资料。</p>
<h4 id="Lex-Ratfor程序的隐含规则"><a class="header-anchor" href="#Lex-Ratfor程序的隐含规则">¶</a>Lex Ratfor程序的隐含规则</h4>
<p>“<code>&lt;n&gt;.r</code>”的依赖文件被自动推导为“<code>n.l</code>”(Lex生成的文件)，其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(LEX)</span> <span class="variable">$(LFALGS)</span></span><br></pre></td></tr></table></figure>
<h4 id="从C程序、Yacc-文件或Lex文件创建Lint库的隐含规则"><a class="header-anchor" href="#从C程序、Yacc-文件或Lex文件创建Lint库的隐含规则">¶</a>从C程序、Yacc 文件或Lex文件创建Lint库的隐含规则</h4>
<p>“<code>&lt;n&gt;.ln</code>”（lint生成的文件）的依赖文件被自动推导为“<code>n.c</code>”，其生成命令是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(LINT)</span> <span class="variable">$(LINTFALGS)</span> <span class="variable">$(CPPFLAGS)</span> -i</span><br></pre></td></tr></table></figure>
<p>对于“<code>&lt;n&gt;.y</code>”和“<code>&lt;n&gt;.l</code>”也是同样的规则。</p>
<h3 id="隐含规则使用的变量"><a class="header-anchor" href="#隐含规则使用的变量">¶</a>隐含规则使用的变量</h3>
<p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的<code>makefile</code>中改变这些变量的值，或是在<code>make</code>的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用<code>make</code>的“<code>-R</code>”或“<code>--no-builtin-variables</code>”参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是“<code>$(CC) -c $(CFLAGS) $(CPPFLAGS)</code>”。Make默认的编译命令是“<code>CC</code>”，如果你把变量“<code>$(CC)</code>”重定义成“<code>gcc</code>”，把变量“<code>$(CFLAGS)</code>”重定义成“<code>-g</code>”，那么，隐含规则中的命令全部会以“<code>gcc -c -g $(CPPFLAGS)</code>”的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量。</p>
<h4 id="关于命令的变量"><a class="header-anchor" href="#关于命令的变量">¶</a>关于命令的变量</h4>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AR</td>
<td>函数库打包程序。默认命令是“ar”。</td>
</tr>
<tr>
<td>AS</td>
<td>汇编语言编译程序。默认命令是“as”。</td>
</tr>
<tr>
<td>CC</td>
<td>C语言编译程序。默认命令是“cc”。</td>
</tr>
<tr>
<td>CXX</td>
<td>C<ins>语言编译程序。默认命令是“g</ins>”。</td>
</tr>
<tr>
<td>CO</td>
<td>从RCS文件中扩展文件程序。默认命令是“co”。</td>
</tr>
<tr>
<td>CPP</td>
<td>C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) -E”。</td>
</tr>
<tr>
<td>FC</td>
<td>Fortran和Ratfor的编译器和预处理程序。默认命令是“f77”。</td>
</tr>
<tr>
<td>GET</td>
<td>从SCCS文件中扩展文件的程序。默认命令是“get”。</td>
</tr>
<tr>
<td>LEX</td>
<td>Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。</td>
</tr>
<tr>
<td>PC</td>
<td>Pascal语言编译程序。默认命令是“pc”。</td>
</tr>
<tr>
<td>YACC</td>
<td>Yacc文法分析器（针对于C程序）。默认命令是“yacc”。</td>
</tr>
<tr>
<td>YACCR</td>
<td>Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc -r”。</td>
</tr>
<tr>
<td>MAKEINFO</td>
<td>转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。</td>
</tr>
<tr>
<td>TEX</td>
<td>从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。</td>
</tr>
<tr>
<td>TEXI2DVI</td>
<td>从Texinfo源文件创建军TeX DVI文件的程序。默认命令是“texi2dvi”。</td>
</tr>
<tr>
<td>WEAVE</td>
<td>转换Web到TeX的程序。默认命令是“weave”。</td>
</tr>
<tr>
<td>CWEAVE</td>
<td>转换C Web到TeX的程序。默认命令是“cweave”。</td>
</tr>
<tr>
<td>TANGLE</td>
<td>转换Web到 Pascal语言的程序。默认命令是“tangle”。</td>
</tr>
<tr>
<td>CTANGLE</td>
<td>转换C Web到C。默认命令是“ctangle”。</td>
</tr>
<tr>
<td>RM</td>
<td>删除文件命令。默认命令是“rm -f”。</td>
</tr>
</tbody>
</table>
<h4 id="关于命令参数的变量"><a class="header-anchor" href="#关于命令参数的变量">¶</a>关于命令参数的变量</h4>
<p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ARFLAGS</td>
<td>函数库打包程序AR命令的参数。默认值是“rv”。</td>
</tr>
<tr>
<td>ASFLAGS</td>
<td>汇编语言编译器参数。当明显地调用“.s”或“.S”文件时。</td>
</tr>
<tr>
<td>CFLAGS</td>
<td>C语言编译器参数。</td>
</tr>
<tr>
<td>CXXFLAGS</td>
<td>C++语言编译器参数。</td>
</tr>
<tr>
<td>COFLAGS</td>
<td>RCS命令参数。</td>
</tr>
<tr>
<td>CPPFLAGS</td>
<td>C预处理器参数。C和Fortran编译器也会用到。</td>
</tr>
<tr>
<td>FFLAGS</td>
<td>Fortran语言编译器参数。</td>
</tr>
<tr>
<td>GFLAGS</td>
<td>SCCS“get”程序参数。</td>
</tr>
<tr>
<td>LDFLAGS</td>
<td>链接器参数。如“ld”。</td>
</tr>
<tr>
<td>LFLAGS</td>
<td>Lex文法分析器参数。</td>
</tr>
<tr>
<td>PFLAGS</td>
<td>Pascal语言编译器参数。</td>
</tr>
<tr>
<td>RFLAGS</td>
<td>Ratfor程序的Fortran编译器参数。</td>
</tr>
<tr>
<td>YFLAGS</td>
<td>Yacc文法分析器参数。</td>
</tr>
</tbody>
</table>
<h3 id="隐含规则链"><a class="header-anchor" href="#隐含规则链">¶</a>隐含规则链</h3>
<p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个<code>[.o]</code>的文件生成，可能会是先被Yacc的<code>[.y]</code>文件先成<code>[.c]</code>，然后再被<code>C</code>的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件<code>[.c]</code>存在，那么就直接调用C的编译器的隐含规则，如果没有<code>[.c]</code>文件，但有一个<code>[.y]</code>文件，那么Yacc的隐含规则会被调用，生成<code>[.c]</code>文件，然后，再调用C编译的隐含规则最终由<code>[.c]</code>生成<code>[.o]</code>文件，达到目标。</p>
<p>我们把这种<code>[.c]</code>的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的<code>makefile</code>发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“<code>rm -f</code>”删除。</p>
<p>通常，一个被<code>makefile</code>指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“<code>.INTERMEDIATE</code>”来强制声明。如：<code>.INTERMEDIATE : mid</code>。</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“<code>.SECONDARY</code>”来强制声明，如<code>.SECONDARY : sec</code>。你还可以把你的目标，以模式的方式来指定（如<code>%.o</code>）成伪目标“<code>.PRECIOUS</code>”的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“<code>foo.c</code>”生成目标程序“<code>foo</code>”，按道理，make会编译生成中间文件“<code>foo.o</code>”，然后链接成“<code>foo</code>”，但在实际情况下，这一动作可以被一条“cc”的命令完成(<code>cc -o foo foo.c</code>)，于是优化过的规则就不会生成中间文件。</p>
<h3 id="定义模式规则"><a class="header-anchor" href="#定义模式规则">¶</a>定义模式规则</h3>
<p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有“<code>%</code>”字符。“<code>%</code>”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用“<code>%</code>”，只是依赖目标中的“<code>%</code>”的取值，取决于其目标。</p>
<p>有一点需要注意的是，“<code>%</code>”的展开发生在变量和函数的展开之后，变量和函数的展开发生在<code>make</code>载入<code>Makefile</code>时，而模式规则中的“<code>%</code>”则发生在运行时。</p>
<h4 id="模式规则介绍"><a class="header-anchor" href="#模式规则介绍">¶</a>模式规则介绍</h4>
<p>模式规则中，至少在规则的目标定义中要包含“<code>%</code>”，否则，就是一般的规则。目标中的“<code>%</code>”定义表示对文件名的匹配，“<code>%</code>”表示长度任意的非空字符串。例如：“<code>%.c</code>”表示以“<code>.c</code>”结尾的文件名（文件名的长度至少为3），而“<code>s.%.c</code>”则表示以“<code>s.</code>”开头，“<code>.c</code>”结尾的文件名（文件名的长度至少为5）。</p>
<p>如果“<code>%</code>”定义在目标中，那么，目标中的“<code>%</code>”的值决定了依赖目标中的“<code>%</code>”的值，也就是说，目标中的模式的“<code>%</code>”决定了依赖目标中“<code>%</code>”的样子。例如有一个模式规则如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c ; &lt;command ......&gt;</span><br></pre></td></tr></table></figure>
<p>其含义是，指出了怎么从所有的<code>[.c]</code>文件生成相应的<code>[.o]</code>文件的规则。如果要生成的目标是“<code>a.o b.o</code>”，那么“<code>%c</code>”就是“<code>a.c b.c</code>”。</p>
<p>一旦依赖目标中的“<code>%</code>”模式被确定，那么，<code>make</code>会被要求去匹配当前目录下所有的文件名，一旦找到，<code>make</code>就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，<code>make</code>就会产生所有的模式目标，此时，<code>make</code>关心的是依赖的文件名和生成目标的命令这两件事。</p>
<h4 id="模式规则示例"><a class="header-anchor" href="#模式规则示例">¶</a>模式规则示例</h4>
<p>下面这个例子表示了，把所有的[.c]文件都编译成[.o]文件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>其中，“<code>$@</code>”表示所有的目标的挨个值，“<code>$&lt;</code>”表示了所有依赖目标的挨个值。这些奇怪的变量我们叫“自动化变量”，后面会详细讲述。下面的这个例子中有两个目标是模式的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.tab.c %.tab.h: %.y</span><br><span class="line">	bison -d <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>这条规则告诉make把所有的<code>[.y]</code>文件都以&quot;<code>bison -d &lt;n&gt;.y</code>&quot;执行，然后生成&quot;<code>&lt;n&gt;.tab.c</code>&quot;和&quot;<code>&lt;n&gt;.tab.h</code>&quot;文件。其中，&quot;<code>&lt;n&gt;</code>&quot;表示一个任意字符串。如果我们的执行程序“<code>foo</code>”依赖于文件“<code>parse.tab.o</code>”和“<code>scan.o</code>”，并且文件“<code>scan.o</code>”依赖于文件“<code>parse.tab.h</code>”，如果“<code>parse.y</code>”文件被更新了，那么根据上述的规则，“<code>bison -d parse.y</code>”就会被执行一次，于是，“<code>parse.tab.o</code>”和“<code>scan.o</code>”的依赖文件就齐了。（假设，&quot;<code>parse.tab.o</code>&quot;由&quot;<code>parse.tab.c</code>&quot;生成，和&quot;<code>scan.o</code>&quot;由&quot;<code>scan.c</code>&quot;生成，而&quot;<code>foo</code>&quot;由&quot;<code>parse.tab.o</code>&quot;和&quot;<code>scan.o</code>&quot;链接生成，而且<code>foo</code>和其<code>[.o]</code>文件的依赖关系也写好，那么，所有的目标都会得到满足）。</p>
<h4 id="自动化变量"><a class="header-anchor" href="#自动化变量">¶</a>自动化变量</h4>
<p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种<code>自动化变量只应出现在规则的命令中</code>。</p>
<p>下面是所有的自动化变量及其说明：</p>
<table>
<thead>
<tr>
<th>自动化变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$@</code></td>
<td>表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，&quot;<code>$@</code>&quot;就是匹配于目标中模式定义的集合。</td>
</tr>
<tr>
<td><code>$%</code></td>
<td>仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是&quot;foo.a (bar.o)“，那么，”<code>$%</code>“就是&quot;bar.o”，&quot;<code>$@</code>“就是&quot;foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows 下是[.lib]），那么，其值为空。</td>
</tr>
<tr>
<td><code>$&lt;</code></td>
<td><code>依赖目标</code>中的第一个目标名字。如果依赖目标是以模式（即“<code>%</code>”）定义的，那么“<code>$&lt;</code>”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</td>
</tr>
<tr>
<td>$?</td>
<td>所有比目标新的依赖目标的集合。以空格分隔。</td>
</tr>
<tr>
<td>$^</td>
<td>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</td>
</tr>
<tr>
<td>$+</td>
<td>这个变量很像&quot;$^&quot;，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>这个变量表示目标模式中&quot;<code>%</code>“及其之前的部分。如果目标是&quot;<code>dir/a.foo.b</code>”，并且目标的模式是&quot;<code>a.%.b</code>&quot;，那么，“<code>$*</code>“的值就是&quot;<code>dir/a.foo&quot;</code>。这个变量对于构造有关联的文件名是比较有用。如果目标中没有模式的定义，那么”<code>$*</code>“也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么”<code>$*</code>“就是除了后缀的那一部分。例如：如果目标是&quot;foo.c”，因为”.c&quot;是make所能识别的后缀名，所以，“<code>$*</code>“的值就是&quot;foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用”<code>$*</code>“，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么”<code>$*</code>&quot;就是空值。</td>
</tr>
</tbody>
</table>
<p>当你希望只对更新过的依赖文件进行操作时，&quot;<code>$?</code>“在显式规则中很有用，例如，假设有一个函数库文件叫&quot;lib”，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">lib : foo.o bar.o lose.o win.o</span><br><span class="line">	ar r lib <span class="variable">$?</span></span><br></pre></td></tr></table></figure>
<p>在上述所列出来的自动量变量中。四个变量（<code>$@</code>、<code>$&lt;</code>、<code>$%</code>、<code>$*</code>）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上&quot;D&quot;或&quot;F&quot;字样。这是GNU make中老版本的特性，在新版本中，我们使用函数“dir”或“notdir”就可以做到了。“D”的含义就是Directory，就是目录，“F”的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上&quot;D&quot;或是&quot;F&quot;的含义：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$(@D)</code></td>
<td>表示&quot;$@“的目录部分（不以斜杠作为结尾），如果”$@“值是&quot;dir/foo.o”，那么&quot;$(@D)“就是&quot;dir”，而如果&quot;$@“中没有包含斜杠的话，其值就是”.&quot;（当前目录）。</td>
</tr>
<tr>
<td><code>$(@F)</code></td>
<td>表示“$@”的文件部分，如果“$@”值是“dir/foo.o”，那么“$(@F)”就是“foo.o”，“$(@F)”相当于函数“$(notdir $@)”。</td>
</tr>
<tr>
<td><code>$(*D)</code> <br> <code>$(*F)</code></td>
<td>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，“<code>$(*D)</code>“返回&quot;dir”，而”<code>$(*F)</code>“返回&quot;foo”。</td>
</tr>
<tr>
<td><code>$(%D)</code> <br> <code>$(%F)</code></td>
<td>分别表示了函数包文件成员的目录部分和文件部分。这对于形同&quot;archive(member)&quot;形式的目标中的&quot;member&quot;中包含了不同的目录很有用。</td>
</tr>
<tr>
<td><code>$(&lt;D)</code> <br> <code>$(&lt;F)</code></td>
<td>分别表示依赖文件的目录部分和文件部分。</td>
</tr>
<tr>
<td><code>$(^D)</code> <br> <code>$(^F)</code></td>
<td>分别表示所有依赖文件的目录部分和文件部分。(无相同的)</td>
</tr>
<tr>
<td><code>$(+D)</code> <br> <code>$(+F)</code></td>
<td>分别表示所有依赖文件的目录部分和文件部分。(可以有相同的)</td>
</tr>
<tr>
<td><code>$(?D)</code> <br> <code>$(?F)</code></td>
<td>分别表示被更新的依赖文件的目录部分和文件部分。</td>
</tr>
</tbody>
</table>
<p>最后想提醒一下的是，对于“<code>$&lt;</code>”，为了避免产生不必要的麻烦，我们最好给<code>$</code>后面的那个特定字符都加上圆括号，比如，“<code>$(&lt;)</code>”就要比“<code>$&lt;</code>”要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是“显式规则”和“静态模式规则”（参见前面“书写规则”一章）。其在隐含规则中并没有意义。</p>
<h4 id="模式的匹配"><a class="header-anchor" href="#模式的匹配">¶</a>模式的匹配</h4>
<p>一般来说，一个目标的模式有一个有前缀或是后缀的“<code>%</code>”，或是没有前后缀，直接就是一个“<code>%</code>”。因为“<code>%</code>”代表一个或多个字符，所以在定义好了的模式中，我们把“<code>%</code>”所匹配的内容叫做“<code>茎</code>”，例如“<code>%.c</code>”所匹配的文件“<code>test.c</code>”中&quot;<code>test</code>&quot;就是“茎”。因为在目标和依赖目标中同时有“<code>%</code>”时，依赖目标的“茎”会传给目标，当做目标中的“茎”。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式“<code>e%t</code>”，文件“<code>src/eat</code>”匹配于该模式，于是“<code>src/a</code>”就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式“<code>c%r</code>”，那么，目标就是“<code>src/car</code>”（“茎”被传递）。</p>
<h4 id="重载内建隐含规则"><a class="header-anchor" href="#重载内建隐含规则">¶</a>重载内建隐含规则</h4>
<p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span> -D<span class="variable">$(date)</span></span><br></pre></td></tr></table></figure>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.s</span><br></pre></td></tr></table></figure>
<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h4 id="老式风格的“后缀规则”"><a class="header-anchor" href="#老式风格的“后缀规则”">¶</a>老式风格的“后缀规则”</h4>
<p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：“双后缀”和“单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如“<code>.c.o</code>”相当于“<code>%o : %c</code>”。单后缀规则只定义一个后缀，也就是源文件的后缀。如“<code>.c</code>”相当于“<code>% : %.c</code>”。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：“.c”和“.o”都是make所知道。因而，如果你定义了一个规则是“.c.o”那么其就是双后缀规则，意义就是“.c”是源文件的后缀，“.o”是目标文件的后缀。如下示例</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.c.o: foo.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子，就是说，文件&quot;.c.o&quot;依赖于文件&quot;foo.h&quot;，而不是我们想要的这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o: %.c foo.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。而要让make知道一些特定的后缀，我们可以使用伪目标&quot;.SUFFIXES&quot;来定义或是删除，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.SUFFIXES: .hack .win #把后缀.hack和.win加入后缀列表中的末尾。</span></span><br><span class="line"><span class="section">.SUFFIXES: # 删除默认的后缀</span></span><br><span class="line"><span class="section">.SUFFIXES: .c .o .h # 定义自己的后缀</span></span><br></pre></td></tr></table></figure>
<p>先清楚默认后缀，后定义自己的后缀列表。</p>
<p>make的参数“<code>-r</code>”或“<code>--no-builtin-rules</code>”也会使用得默认的后缀列表为空。而变量“SUFFIXE”被用来定义默认的后缀列表，你可以用“<code>.SUFFIXES</code>”来改变后缀列表，但请不要改变变量“SUFFIXE”的值。</p>
<h4 id="隐含规则搜索算法"><a class="header-anchor" href="#隐含规则搜索算法">¶</a>隐含规则搜索算法</h4>
<p>比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是“archive(member)”的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把“member”当作T来搜索。</p>
<ol>
<li>把T的目录部分分离出来。叫D，而剩余部分叫N。如：如果T是“src/foo.o”，那么，D就是“src/”，N就是“foo.o”。</li>
<li>创建所有匹配于T或是N的模式规则列表。</li>
<li>如果在模式规则列表中有匹配所有文件的模式，如&quot;%&quot;，那么从列表中移除其它的模式。</li>
<li>移除列表中没有命令的规则。</li>
<li>对于第一个在列表中的模式规则：
<ol>
<li>推导其&quot;茎&quot;S，S应该是T或是N匹配于模式中&quot;%&quot;非空的部分。</li>
<li>计算依赖文件。把依赖文件中的&quot;%&quot;都替换成&quot;茎&quot;S。如果目标模式中没有包含斜框字符，而把 D 加在第一个依赖文件的开头。</li>
<li>测试是否所有的依赖文件都存在或是理当存在。(如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫&quot;理当存在&quot;)</li>
<li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li>
</ol>
</li>
<li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则:
<ol>
<li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li>
<li>计算依赖文件。(同第5步)</li>
<li>测试所有的依赖文件是否存在或是理当存在。</li>
<li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li>
<li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li>
</ol>
</li>
<li>如果没有隐含规则可以使用，查看&quot;.DEFAULT&quot;规则，如果有，采用，把&quot;.DEFAULT&quot;的命令给T使用。</li>
</ol>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h2 id="使用make更新函数库文件"><a class="header-anchor" href="#使用make更新函数库文件">¶</a>使用make更新函数库文件</h2>
<p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令&quot;ar&quot;来完成打包工作。</p>
<h3 id="函数库文件的成员"><a class="header-anchor" href="#函数库文件的成员">¶</a>函数库文件的成员</h3>
<p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">archive(member)</span><br></pre></td></tr></table></figure>
<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了&quot;ar&quot;命令来服务的。如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foolib(hack.o) : hack.o</span><br><span class="line">	ar cr foolib hack.o</span><br></pre></td></tr></table></figure>
<p>如果要指定多个member，那就以空格分开，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foolib(hack.o kludge.o)</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foolib(hack.o) foolib(kludge.o)</span><br></pre></td></tr></table></figure>
<p>你还可以使用Shell的文件通配符来定义，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foolib(*.o)</span><br></pre></td></tr></table></figure>
<h3 id="函数库成员的隐含规则"><a class="header-anchor" href="#函数库成员的隐含规则">¶</a>函数库成员的隐含规则</h3>
<p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是&quot;<code>a(m)</code>“形式的，其会把目标变成”<code>(m)</code>“。于是，如果我们的成员是”<code>%.o</code>&quot;的模式定义，并且如果我们使用&quot;<code>make foo.a(bar.o)</code>&quot;的形式调用<code>Makefile</code>时，隐含规则会去找&quot;<code>bar.o</code>&quot;的规则，如果没有定义<code>bar.o</code>的规则，那么内建隐含规则生效，make会去找<code>bar.c</code>文件来生成<code>bar.o</code>，如果找得到的话，make执行的命令大致如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cc -c bar.c -o bar.o</span><br><span class="line">ar r foo.a bar.o</span><br><span class="line">rm -f bar.o</span><br></pre></td></tr></table></figure>
<p>还有一个变量要注意的是&quot;<code>$%</code>&quot;，这是专属函数库文件的自动化变量，有关其说明请参见&quot;自动化变量&quot;一节。</p>
<h3 id="函数库文件的后缀规则"><a class="header-anchor" href="#函数库文件的后缀规则">¶</a>函数库文件的后缀规则</h3>
<p>你可以使用“后缀规则”和“隐含规则”来生成函数库打包文件，如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">.c.a:</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">	<span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure>
<p>其等效于:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">(%.o) : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">	<span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h3>
<p>在进行函数库打包文件生成时，请小心使用make的并行机制（&quot;-j&quot;参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。但就目前而言，你还是应该不要尽量不要使用“-j”参数。</p>
<h2 id="后序"><a class="header-anchor" href="#后序">¶</a>后序</h2>
<p>终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测“函数”那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows)“杀伤力”。</p>
<p>对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、ftp…等等，来完成诸如“程序打包”、“程序备份”、“制作程序安装包”、“提交代码”、“使用程序模板”、“合并文件”等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如&quot;@@@N、###N&quot;奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的&quot;@@@N、###N&quot;等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的&quot;扩展C&quot;语言（即在C语言中用“EXEC SQL”的样子执行SQL语句，在用cc/gcc编译之前，需要使用“扩展C”的翻译程序，如cpre，把其翻译成标准C）。如果你在使用make时有一些更为绝妙的方法，请记得告诉我啊。</p>
<p>回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入&quot;!make&quot;时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人年，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。</p>
<p>现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间钻研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。</p>
<p>因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因此，我迫切地得等待各位给我指证和建议，以及任何的反馈。</p>
<p>最后，还是利用这个后序，介绍一下自己。我目前从事于所有Unix平台下的软件研发，主要是做分布式计算/网格计算方面的系统产品软件，并且我对于下一代的计算机革命——网格计算非常地感兴趣，对于分布式计算、P2P、Web Service、J2EE技术方向也很感兴趣，同时，对于项目实施、团队管理、项目管理也小有心得，希望同样和我战斗在“技术和管理并重”的阵线上的年轻一代，能够和我多多地交流。我的MSN是：haoel@hotmail.com（常用），QQ是：753640（不常用）。（注：请勿给我MSN的邮箱发信，由于hotmail的垃圾邮件导致我拒收这个邮箱的所有来信）我欢迎任何形式的交流，无论是讨论技术还是管理，或是其它海阔天空的东西。除了政治和娱乐新闻我不关心，其它只要积极向上的东西我都欢迎！</p>
<p>最最后，我还想介绍一下make程序的设计开发者。</p>
<p>首当其冲的是：Richard Stallman</p>
<p>开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页：<a href="http://www.stallman.org/%E3%80%82">http://www.stallman.org/。</a></p>
<p>第二位是：Roland McGrath</p>
<p>个人主页是：<a href="http://www.frob.com/~roland/">http://www.frob.com/~roland/</a>，下面是他的一些事迹：</p>
<ol>
<li>合作编写了并维护GNU make。</li>
<li>和Thomas Bushnell一同编写了GNU Hurd。</li>
<li>编写并维护着GNU C library。</li>
<li>合作编写并维护着部分的GNU Emacs。</li>
</ol>
<p>在此，向这两位开源项目的斗士致以最真切的敬意。</p>
]]></content>
  </entry>
  <entry>
    <title>《汇编语言程序设计》读后总结</title>
    <url>/2021/08/professional-assembly-language/</url>
    <content><![CDATA[<span id="more"></span>
<p>主要的内容：</p>
<ol>
<li>为什么要学汇编</li>
<li>《汇编语言程序设计》内容总结</li>
<li>与王爽版本（国内教材）的对比</li>
<li>学习汇编的一些建议</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>calibre python 接口</title>
    <url>/2021/09/calibre-python-api/</url>
    <content><![CDATA[<p><code>Calibre</code>提供了一系列的<code>python</code>接口，通过这些接口，可以实现对<code>Calibre</code>数据库的批量操作。</p>
<span id="more"></span>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<p>在<a href="https://calibre-ebook.com/zh_CN/download">Calibre下载页面</a>下载对应系统的安装包安装即可。安装完成之后，<code>Calibre</code>安装目录会有对应的shell和python库。如果是Linux系统，可以直接通过包管理器安装Calibre。</p>
<p>以Ubuntu为例，安装完毕之后，<code>Calibre</code>相关的文件在<code>/usr/lib/calibre</code>目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@localhost$ </span><span class="language-bash"><span class="built_in">ls</span> -l /usr/lib/calibre/</span></span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x 14 root root 4096 Jan 27  2020 calibre</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 27  2020 css_selectors</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 27  2020 duktape</span><br><span class="line">drwxr-xr-x  8 root root 4096 Jan 27  2020 html5lib</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 27  2020 lzma</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 27  2020 odf</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 27  2020 regex</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jan 27  2020 templite</span><br><span class="line">drwxr-xr-x  3 root root 4096 Jan 27  2020 tinycss</span><br></pre></td></tr></table></figure>
<p>以下的说明都以Ubuntu为例。</p>
<h2 id="Calibre-shell命令"><a class="header-anchor" href="#Calibre-shell命令">¶</a>Calibre shell命令</h2>
<p><code>Calibre</code>提供了一系列的shell命令，而这些命令其实是python脚本。通过阅读官方编写的python脚本，可以学习calibre的python接口。<a href="https://manual.calibre-ebook.com/generated/en/cli-index.html">cli-index.html</a>列出了<code>Calibre</code>提供的所有shell指令。我希望通过脚本批量修改书籍的metadata，所以需要关注calibredb命令的实现。</p>
<ul>
<li><a href="https://manual.calibre-ebook.com/generated/en/calibre.html">calibre</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/calibre-customize.html">calibre-customize</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/calibre-debug.html">calibre-debug</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/calibre-server.html">calibre-server</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/calibre-smtp.html">calibre-smtp</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/calibredb.html">calibredb</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/ebook-convert.html">ebook-convert</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/ebook-edit.html">ebook-edit</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/ebook-meta.html">ebook-meta</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/ebook-polish.html">ebook-polish</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/ebook-viewer.html">ebook-viewer</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/fetch-ebook-metadata.html">fetch-ebook-metadata</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/lrf2lrs.html">lrf2lrs</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/lrfviewer.html">lrfviewer</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/lrs2lrf.html">lrs2lrf</a></li>
<li><a href="https://manual.calibre-ebook.com/generated/en/web2disk.html">web2disk</a></li>
</ul>
<h2 id="Calibre-python-接口"><a class="header-anchor" href="#Calibre-python-接口">¶</a>Calibre python 接口</h2>
<p>calibre提供了python接口的文档，但是感觉不全。与安装目录提供的文件比较，很多东西文档没有介绍。所以不参考Calibre提供的python文档，直接阅读库的源代码。</p>
<p><a href="https://manual.calibre-ebook.com/py-modindex.html">https://manual.calibre-ebook.com/py-modindex.html</a></p>
<h2 id="calibredb"><a class="header-anchor" href="#calibredb">¶</a>calibredb</h2>
<p>通过阅读calibredb的<a href="https://manual.calibre-ebook.com/generated/en/calibredb.html">帮助网页</a>，发现calibredb实现了对数据库的各种操作。这里我只关心获取metadata以及设置metadata。</p>
<ul>
<li>list</li>
<li>add</li>
<li>remove</li>
<li>add_format</li>
<li>remove_format</li>
<li>show_metadata</li>
<li>set_metadata</li>
<li>export</li>
<li>catalog</li>
<li>saved_searches</li>
<li>add_custom_column</li>
<li>custom_columns</li>
<li>remove_custom_column</li>
<li>set_custom</li>
<li>restore_database</li>
<li>check_library</li>
<li>list_categories</li>
<li>backup_metadata</li>
<li>clone</li>
<li>embed_metadata</li>
<li>search</li>
</ul>
<h3 id="calibredb命令的实现"><a class="header-anchor" href="#calibredb命令的实现">¶</a>calibredb命令的实现</h3>
<p>通过which命令确定calibredb命令的位置，cat即可。通过阅读发现，calibredb是对cli命令的进一步封装。从脚本也可以看出，calibre所有的python文件都位于/usr/lib/calibre下面（第10行）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2.7</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">This is the standard runscript for all of calibre&#x27;s tools.</span></span><br><span class="line"><span class="string">Do not modify it unless you know what you are doing.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line">path = os.environ.get(<span class="string">&#x27;CALIBRE_PYTHON_PATH&#x27;</span>, <span class="string">&#x27;/usr/lib/calibre&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.insert(<span class="number">0</span>, path)</span><br><span class="line"></span><br><span class="line">sys.resources_location = os.environ.get(<span class="string">&#x27;CALIBRE_RESOURCES_PATH&#x27;</span>, <span class="string">&#x27;/usr/share/calibre&#x27;</span>)</span><br><span class="line">sys.extensions_location = os.environ.get(<span class="string">&#x27;CALIBRE_EXTENSIONS_PATH&#x27;</span>, <span class="string">&#x27;/usr/lib/calibre/calibre/plugins&#x27;</span>)</span><br><span class="line">sys.executables_location = os.environ.get(<span class="string">&#x27;CALIBRE_EXECUTABLES_PATH&#x27;</span>, <span class="string">&#x27;/usr/bin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> calibre.library.cli <span class="keyword">import</span> main</span><br><span class="line">sys.exit(main())</span><br></pre></td></tr></table></figure>
<p>下面是cli.py中main()函数的实现。不难看出，根据子命令构造出对应的函数名（<code>command</code>变量），然后调用。例如子命令<code>list</code>会调用函数<code>command_list</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=sys.argv</span>):</span><br><span class="line">    parser = option_parser()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">2</span>:</span><br><span class="line">        parser.print_help()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> COMMANDS:</span><br><span class="line">        <span class="keyword">if</span> args[<span class="number">1</span>] == <span class="string">&#x27;--version&#x27;</span>:</span><br><span class="line">            parser.print_version()</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        parser.print_help()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    command = <span class="built_in">eval</span>(<span class="string">&#x27;command_&#x27;</span>+args[<span class="number">1</span>])</span><br><span class="line">    dbpath = prefs[<span class="string">&#x27;library_path&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> command(args[<span class="number">2</span>:], dbpath)</span><br></pre></td></tr></table></figure>
<h2 id="编写脚本"><a class="header-anchor" href="#编写脚本">¶</a>编写脚本</h2>
<h3 id="引入calibre"><a class="header-anchor" href="#引入calibre">¶</a>引入calibre</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2.7</span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line">path = os.environ.get(<span class="string">&#x27;CALIBRE_PYTHON_PATH&#x27;</span>, <span class="string">&#x27;/usr/lib/calibre&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.insert(<span class="number">0</span>, path)</span><br><span class="line"></span><br><span class="line">sys.resources_location = os.environ.get(<span class="string">&#x27;CALIBRE_RESOURCES_PATH&#x27;</span>, <span class="string">&#x27;/usr/share/calibre&#x27;</span>)</span><br><span class="line">sys.extensions_location = os.environ.get(<span class="string">&#x27;CALIBRE_EXTENSIONS_PATH&#x27;</span>, <span class="string">&#x27;/usr/lib/calibre/calibre/plugins&#x27;</span>)</span><br><span class="line">sys.executables_location = os.environ.get(<span class="string">&#x27;CALIBRE_EXECUTABLES_PATH&#x27;</span>, <span class="string">&#x27;/usr/bin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> calibre.db.legacy <span class="keyword">import</span> LibraryDatabase</span><br></pre></td></tr></table></figure>
<h3 id="打开数据库"><a class="header-anchor" href="#打开数据库">¶</a>打开数据库</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db = LibraryDatabase(<span class="string">&quot;/path/to/calibre-library&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="db常用API"><a class="header-anchor" href="#db常用API">¶</a>db常用API</h3>
<p>更多API请打开文件<code>/usr/lib/calibre/calibre/db/legacy.py</code>查看。</p>
<table>
    <colgroup><col style="width: 339.0px;"><col style="width: 762.0px;"></colgroup>
    <tbody>
        <tr>
            <th>API</th>
            <th>说明</th>
        </tr><tr>
            <td>db.get_data_as_dict()</td>
            <td>返回数据库所有书籍的信息，格式是字典。<br>数据库较大时，此函数非常慢。</td>
        </tr><tr>
            <td>db.all_ids()</td>
            <td>返回所有书籍的id。相对来说比较快。</td>
        </tr><tr>
            <td>db.get_metadata(id, index_is_id=True)</td>
            <td>返回指定id的metadata，数据类型是calibre.ebooks.metadata.book.base.Metadata。支持set/get函数。</td>
        </tr><tr>
            <td colspan="1">db.set_metadata(id, metadata, force_changes=True)</td>
            <td colspan="1">更新metadata，第二个参数是get_metadate()的返回值。</td>
        </tr>
    </tbody>
</table>
<p>get_data_as_dict() 返回的字典包含如下索引：</p>
<p>rating、author_sort、isbn、pubdate、series、fmt_mobi、id、size、uuid、title、comments、languages、sort、tags、timestamp、last_modified、authors、publisher、series_index、identifiers、cover、formats。</p>
<h2 id="metadata常用API"><a class="header-anchor" href="#metadata常用API">¶</a>metadata常用API</h2>
<p>每本书的metadata本质上是一个字典，字典包含的索引如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NULL_VALUES = &#123;</span><br><span class="line">                <span class="string">&#x27;user_metadata&#x27;</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">&#x27;cover_data&#x27;</span>   : (<span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line">                <span class="string">&#x27;tags&#x27;</span>         : [],</span><br><span class="line">                <span class="string">&#x27;identifiers&#x27;</span>  : &#123;&#125;,</span><br><span class="line">                <span class="string">&#x27;languages&#x27;</span>    : [],</span><br><span class="line">                <span class="string">&#x27;device_collections&#x27;</span>: [],</span><br><span class="line">                <span class="string">&#x27;author_sort_map&#x27;</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">&#x27;authors&#x27;</span>      : [_(<span class="string">&#x27;Unknown&#x27;</span>)],</span><br><span class="line">                <span class="string">&#x27;author_sort&#x27;</span>  : _(<span class="string">&#x27;Unknown&#x27;</span>),</span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>        : _(<span class="string">&#x27;Unknown&#x27;</span>),</span><br><span class="line">                <span class="string">&#x27;user_categories&#x27;</span> : &#123;&#125;,</span><br><span class="line">                <span class="string">&#x27;author_link_map&#x27;</span> : &#123;&#125;,</span><br><span class="line">                <span class="string">&#x27;language&#x27;</span>     : <span class="string">&#x27;und&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>calibre.ebooks.metadata.book.base.Metadata</code>常用的API如下，更多信息请阅读文件<code>/usr/lib/calibre/calibre/ebooks/metadata/book/base.py</code>查看。</p>
<table>
    <tbody>
        <tr><th>API</th><th>说明</th></tr>
        <tr>
            <td>get('index')</td>
            <td>获取指定索引的值。</td>
        </tr>
        <tr>
            <td>set('index', value)</td>
            <td>设置指定索引的值。主要要类型匹配。例如authors的值是一个list，author_sort的值是一个字符串。</td>
        </tr>
    </tbody>
</table>
<h2 id="示例脚本"><a class="header-anchor" href="#示例脚本">¶</a>示例脚本</h2>
<p>脚本的作用是简单格式化书籍的作者信息。使用脚本之前，需要更改<code>Calibre</code>数据库的路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2.7</span></span><br><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"><span class="comment"># -*- coding=UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, re, time</span><br><span class="line"></span><br><span class="line">path = os.environ.get(<span class="string">&#x27;CALIBRE_PYTHON_PATH&#x27;</span>, <span class="string">&#x27;/usr/lib/calibre&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.insert(<span class="number">0</span>, path)</span><br><span class="line"></span><br><span class="line">sys.resources_location = os.environ.get(<span class="string">&#x27;CALIBRE_RESOURCES_PATH&#x27;</span>, <span class="string">&#x27;/usr/share/calibre&#x27;</span>)</span><br><span class="line">sys.extensions_location = os.environ.get(<span class="string">&#x27;CALIBRE_EXTENSIONS_PATH&#x27;</span>, <span class="string">&#x27;/usr/lib/calibre/calibre/plugins&#x27;</span>)</span><br><span class="line">sys.executables_location = os.environ.get(<span class="string">&#x27;CALIBRE_EXECUTABLES_PATH&#x27;</span>, <span class="string">&#x27;/usr/bin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> calibre.db.legacy <span class="keyword">import</span> LibraryDatabase</span><br><span class="line"></span><br><span class="line">db = LibraryDatabase(<span class="string">&quot;/path/to/calibre_path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_authors</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    metadata = db.get_metadata(<span class="built_in">id</span>, index_is_id=<span class="literal">True</span>)</span><br><span class="line">    old_authors = metadata.get(<span class="string">&#x27;authors&#x27;</span>)</span><br><span class="line">    new_authors = []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;id = &quot;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>) + <span class="string">&quot;, title = &quot;</span> + metadata.get(<span class="string">&#x27;title&#x27;</span>) + <span class="string">&quot;, old authors:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> author <span class="keyword">in</span> old_authors:</span><br><span class="line">        <span class="built_in">print</span>(author)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除括号中的内容</span></span><br><span class="line">    <span class="keyword">for</span> author <span class="keyword">in</span> old_authors:</span><br><span class="line">        author = re.sub(<span class="string">u&quot;\\(.*?\\)|\\[.*?]|\\（.*?）|\\【.*?】&quot;</span>, <span class="string">&quot;&quot;</span>, author)</span><br><span class="line">        author = author.replace(<span class="string">u&#x27;•&#x27;</span>, <span class="string">u&#x27;·&#x27;</span>)</span><br><span class="line">        new_authors.append(author)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用逗号分隔不同作者</span></span><br><span class="line">    old_authors = new_authors</span><br><span class="line">    new_authors = []</span><br><span class="line">    <span class="keyword">for</span> author <span class="keyword">in</span> old_authors:</span><br><span class="line">        split_authors = re.split(<span class="string">u&#x27;,|、|，&#x27;</span>, author)</span><br><span class="line">        <span class="keyword">while</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">in</span> split_authors:</span><br><span class="line">            split_authors.remove(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        new_authors += split_authors</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果所有信息都被删除了，则不更改</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(new_authors) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果作者信息没有发现变化，则不更改</span></span><br><span class="line">    old_authors = metadata.get(<span class="string">&#x27;authors&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (old_authors == new_authors):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;new authors:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> author <span class="keyword">in</span> new_authors:</span><br><span class="line">        <span class="built_in">print</span>(author)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    metadata.<span class="built_in">set</span>(<span class="string">&#x27;authors&#x27;</span>,     new_authors)</span><br><span class="line">    metadata.<span class="built_in">set</span>(<span class="string">&#x27;author_sort&#x27;</span>, new_authors[<span class="number">0</span>])</span><br><span class="line">    db.set_metadata(<span class="built_in">id</span>, metadata, force_changes=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_format_authors</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    authors = <span class="string">&#x27;pk&#x27;</span></span><br><span class="line">    metadata = db.get_metadata(<span class="built_in">id</span>, index_is_id=<span class="literal">True</span>)</span><br><span class="line">    authors_list = [authors, <span class="string">&quot;pk2&quot;</span>]</span><br><span class="line">    metadata.<span class="built_in">set</span>(<span class="string">&#x27;authors&#x27;</span>,     authors_list)</span><br><span class="line">    metadata.<span class="built_in">set</span>(<span class="string">&#x27;author_sort&#x27;</span>, authors_list[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;set &quot;</span> + <span class="built_in">str</span>(<span class="built_in">id</span>) + <span class="string">&quot; authors to &quot;</span> + <span class="built_in">str</span>(authors_list))</span><br><span class="line">    db.set_metadata(<span class="built_in">id</span>, metadata, force_changes=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    all_ids = db.all_ids()</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> all_ids:</span><br><span class="line">        format_authors(<span class="built_in">id</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>自己动手编译Linux内核</title>
    <url>/2021/09/compile-linux-kenrel/</url>
    <content><![CDATA[<p>在学习内核驱动模块的时候，需要打开内核的一些调试选项。但是发行版本自带的内核可能会关闭这些调试选项，所以需要自己动手编译内核。这里总结一下编译、安装内核的方法和步骤。</p>
<span id="more"></span>
<h2 id="下载内核源代码"><a class="header-anchor" href="#下载内核源代码">¶</a>下载内核源代码</h2>
<p>首先使用命令<code>uname -r</code>确定现在运行的内核版本，再到<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/">kernel.org</a>下载一个版本接近的内核。这里以<code>2.6.27.57</code>为例，将下载好的源码包放在<code>/usr/src</code>目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost src]$ uname -r</span><br><span class="line">2.6.27.41-170.2.117.fc10.i686</span><br><span class="line">[pk@localhost src]$ pwd</span><br><span class="line">/usr/src</span><br><span class="line">[pk@localhost src]$ ls</span><br><span class="line">kernels  linux-2.6.27.57.tar.bz2</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h2>
<p>解压源码包，并将现在运行kernel的<code>.config</code>文件拷贝进来，再进入menuconfig，打开自己需要的选项，关闭自己不需要的选项。<code>.config</code>文件可以在<code>/lib/modules/$(uname -r)/build</code>目录找到。配置的具体过程，略。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost src]$ sudo tar -xf linux-2.6.27.57.tar.bz2</span><br><span class="line">[sudo] password for pk:</span><br><span class="line">[pk@localhost src]$ cd linux-2.6.27.57</span><br><span class="line">[pk@localhost linux-2.6.27.57]$ sudo cp /usr/src/kernels/$(uname -r)/.config .</span><br><span class="line">[pk@localhost linux-2.6.27.57]$ make menuconfig</span><br></pre></td></tr></table></figure>
<h2 id="编译和安装"><a class="header-anchor" href="#编译和安装">¶</a>编译和安装</h2>
<p>配置完成之后，依次执行下面的命令编译、安装。<code>make install</code>会将编译好的kernel镜像、Symbol等文件安装到/boot目录，并自动配置好Grub。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make -j4</span><br><span class="line">sudo make modules modules_install -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="尝试新的内核"><a class="header-anchor" href="#尝试新的内核">¶</a>尝试新的内核</h2>
<p>重启系统，在<code>Grub</code>选项菜单里，选择新的内核启动系统。进入终端，使用命令<code>uname -r</code>确定新的内核安装成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[pk@localhost ~]$ uname -r</span><br><span class="line">2.6.27.57</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2021/09/git-command/</url>
    <content><![CDATA[<p>根据使用场景，汇总列出相应的git指令，便于查阅。主要参考了《<a href="https://git-scm.com/book/zh/v2">Pro Git</a>》。</p>
<span id="more"></span>
<h2 id="获取帮助"><a class="header-anchor" href="#获取帮助">¶</a>获取帮助</h2>
<ul>
<li>仔细查看git给出的输出提示
<ul>
<li>如果不知道下一步应该执行什么命令，不妨试试<code>git status</code></li>
</ul>
</li>
<li>git [command] -h</li>
<li>git help [command]</li>
<li><a href="https://git-scm.com/docs">在线手册</a></li>
<li>Google</li>
</ul>
<h2 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h2>
<ul>
<li>工作区</li>
<li>暂存区（index or stage）</li>
<li>版本库（.git目录）</li>
<li>git是记录文件的快照，而不是差异</li>
<li>git对象：commit对象、tree对象、blob对象、tag对象</li>
<li>SHA1
<ul>
<li><a href="#sha1%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95">SHA1的生成方法</a></li>
</ul>
</li>
</ul>
<h2 id="获取仓库"><a class="header-anchor" href="#获取仓库">¶</a>获取仓库</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init</td>
<td>在当前目录初始化一个空的仓库。</td>
</tr>
<tr>
<td>git init --bare</td>
<td>初始化一个裸仓库。</td>
</tr>
<tr>
<td>git clone url</td>
<td>从服务器克隆一个仓库。</td>
</tr>
<tr>
<td>git clone url --bare</td>
<td>克隆一个裸仓库。</td>
</tr>
<tr>
<td>git clone url -b branch</td>
<td>克隆仓库并切换到指定branch。</td>
</tr>
<tr>
<td>git clone url dir</td>
<td>指定仓库的文件名。</td>
</tr>
</tbody>
</table>
<h2 id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git config [–system/–global]</td>
<td>git config默认配置所在的仓库。<br>–system为系统中所有的用户配置，<br>–global为当前用户的所有仓库配置。<br>优先级local&gt;global&gt;system。</td>
</tr>
<tr>
<td>git config [–system/–global] -e</td>
<td>打开相应的配置文件，手动编辑。</td>
</tr>
<tr>
<td>git config --global <a href="http://user.name">user.name</a> “username”</td>
<td>设置用户名</td>
</tr>
<tr>
<td>git config --global user.email “name@host”</td>
<td>设置邮箱</td>
</tr>
<tr>
<td>git config --global core.editor vi</td>
<td>设置默认的编辑器</td>
</tr>
<tr>
<td>git config --global core.autocrlf true</td>
<td>提交时：回车换行 -&gt; 换行，检出时：换行 -&gt; 回车换行。<br>windows系统建议设置为true。</td>
</tr>
<tr>
<td>git config --global core.autoctlf input</td>
<td>提交时：回车换行 -&gt; 换行，检出时：不转换。<br>Linux系统建议设置为input。</td>
</tr>
<tr>
<td>git config remote.name.push refs/heads/*:refs/for/*</td>
<td>push代码时，推送到服务器的refs/for分支。name是服务器的名字。</td>
</tr>
<tr>
<td>git config --global <a href="http://alias.co">alias.co</a> checkout</td>
<td>设置checkout子命令的别名为co</td>
</tr>
<tr>
<td>git config --global <a href="http://alias.br">alias.br</a> branch</td>
<td>设置branch子命令的别名为br</td>
</tr>
<tr>
<td>git config --global <a href="http://alias.ci">alias.ci</a> commit</td>
<td>设置commit子命令的别名为ci</td>
</tr>
<tr>
<td>git config --global <a href="http://alias.st">alias.st</a> status</td>
<td>设置status子命令的别名为st</td>
</tr>
<tr>
<td>git config --global alias.unstage ‘reset HEAD --’</td>
<td>设置unstage别名，取消暂存指定文件<br>git unstage filename</td>
</tr>
<tr>
<td>git config --global alias.visual ‘!gitk’</td>
<td>设置别名调用外部命令，需要添加一个感叹号</td>
</tr>
<tr>
<td>git config --global core.quotepath false</td>
<td>控制路径的显示格式。设置为false，则可以正常显示中文。</td>
</tr>
</tbody>
</table>
<h2 id="文件状态变化周期"><a class="header-anchor" href="#文件状态变化周期">¶</a>文件状态变化周期</h2>
<p><code>git status</code>查看当前仓库的状态。</p>
<p><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt=""></p>
<h2 id="追踪文件"><a class="header-anchor" href="#追踪文件">¶</a>追踪文件</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git add filename</td>
<td>将指定文件添加到版本库。</td>
</tr>
<tr>
<td>git add .</td>
<td>将当前目录有修改或未追踪的文件添加到版本库。</td>
</tr>
<tr>
<td>git add -A</td>
<td>将当前仓库有修改或未追踪的文件添加到版本库。</td>
</tr>
<tr>
<td>git add -f</td>
<td>忽略.gitignore文件</td>
</tr>
</tbody>
</table>
<h2 id="提交修改"><a class="header-anchor" href="#提交修改">¶</a>提交修改</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git commit</td>
<td>将暂存区的内容提交到版本库，会打开默认编辑器编辑提交说明。</td>
</tr>
<tr>
<td>git commit -m</td>
<td>在命令行中指定提交说明，而不是进入编辑器。</td>
</tr>
<tr>
<td>git commit --amend</td>
<td>对最近的一笔提交进行修改（追加修改）</td>
</tr>
<tr>
<td>git commit -s</td>
<td>在提交记录中加入“Signed-off-by:”</td>
</tr>
<tr>
<td>git commit --allow-empty</td>
<td>允许空白提交</td>
</tr>
<tr>
<td>git commit --reset-author</td>
<td>同步修改作者的ID</td>
</tr>
<tr>
<td>git commit --amend</td>
<td>向最后一笔修改追加修改</td>
</tr>
</tbody>
</table>
<h2 id="查看修改记录"><a class="header-anchor" href="#查看修改记录">¶</a>查看修改记录</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git log</td>
<td>按时间先后显示当前分支的提交记录，包含提交ID、作者、时间、提交说明等内容。</td>
</tr>
<tr>
<td>git log -p</td>
<td>显示每次提交修改的内容。</td>
</tr>
<tr>
<td>git log --oneline</td>
<td>一行只显示一个提交，默认包含提交ID和提交说明。</td>
</tr>
<tr>
<td>git log --graph</td>
<td>图形化显示，可以直观显示分支切换和合并，通过与<code>--oneline</code>一起使用。</td>
</tr>
<tr>
<td>git log --stat</td>
<td>显示简略统计信息。</td>
</tr>
<tr>
<td>git log -[n]</td>
<td>仅显示最近的<code>n</code>条提交</td>
</tr>
<tr>
<td>git log --after=“2021-06-01”</td>
<td>查看从2021年6月1日开始的提交</td>
</tr>
<tr>
<td>git log --before=“2021-06-01”</td>
<td>查看从2021年6月1日之前的提交</td>
</tr>
<tr>
<td>git log --grep “text”</td>
<td>仅显示提交说明包含<code>text</code>字符串的提交</td>
</tr>
<tr>
<td>git log --author=“author”</td>
<td>仅显示指定作者的提交</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看本地仓库的操作记录。找回修改的绝妙办法。</td>
</tr>
</tbody>
</table>
<h2 id="查看修改内容"><a class="header-anchor" href="#查看修改内容">¶</a>查看修改内容</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git diff</td>
<td>查看工作区和暂存区的差异</td>
</tr>
<tr>
<td>git diff HEAD</td>
<td>查看工作区和版本库的差异</td>
</tr>
<tr>
<td>git diff --cached</td>
<td>查看暂存区和版本库的差异</td>
</tr>
<tr>
<td>git show ref</td>
<td>查看指定提交的修改内容。<code>ref</code>可以是commit id、tag、分支名等等。</td>
</tr>
</tbody>
</table>
<h2 id="patch"><a class="header-anchor" href="#patch">¶</a>patch</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git diff &gt; xxx.patch</td>
<td>如果修改没有提交，使用此方法。</td>
</tr>
<tr>
<td>git apply xxx.patch</td>
<td>应用patch</td>
</tr>
<tr>
<td>git format-patch -[n]</td>
<td>将最近n笔提交生成patch文件</td>
</tr>
<tr>
<td>git am xxx.patch</td>
<td>应用format-patch生成的patch文件，会直接产生一笔提交，无需add/commit。</td>
</tr>
</tbody>
</table>
<h2 id="分支"><a class="header-anchor" href="#分支">¶</a>分支</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git branch</td>
<td>列出仓库的所有本地分支，当前所在分支会用星号标出来</td>
</tr>
<tr>
<td>git branch [-v</td>
<td>-vv]</td>
</tr>
<tr>
<td>git branch -a</td>
<td>列出所有分支，包括远程分支，与-v搭配更香</td>
</tr>
<tr>
<td>git branch [name]</td>
<td>创建新分支，指向当前commit</td>
</tr>
<tr>
<td>git branch [name] [ref]</td>
<td>在指定commit创建新分支</td>
</tr>
<tr>
<td>git checkout [name]</td>
<td>切换到指定分支，会更改工作区的内容</td>
</tr>
<tr>
<td>git checkout -b [name] [ref]</td>
<td>创建新分支，并切换到新分支。ref可选。</td>
</tr>
<tr>
<td>git checkout -b [name] [remote]/[name]</td>
<td>为远程分支创建本地分支，并追踪远程分支</td>
</tr>
<tr>
<td>git branch -u [remote/branch]</td>
<td>设置当前所在分支的上游分支</td>
</tr>
<tr>
<td>git branch -u [remote/branch] [branch]</td>
<td>设置指定分支的上游分支</td>
</tr>
<tr>
<td>git merge [name]</td>
<td>将指定分支合并到当前分支</td>
</tr>
<tr>
<td>git branch -d [name]</td>
<td>删除已经merge的指定分支。-D强制删除</td>
</tr>
<tr>
<td>git push [remote] --delete [name]</td>
<td>删除远程分支</td>
</tr>
</tbody>
</table>
<h2 id="tag"><a class="header-anchor" href="#tag">¶</a>tag</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git tag</td>
<td>列出所有的标签</td>
</tr>
<tr>
<td>git tag -l ‘xxx’</td>
<td>按照通配符列出匹配的标签</td>
</tr>
<tr>
<td>git tag -a [tagname] -m “tag msg”</td>
<td>在HEAD指向的提交创建<code>附注</code>标签</td>
</tr>
<tr>
<td>git tag [tagname]</td>
<td>在HEAD指向的提交创建<code>轻量</code>标签，不使用-a、-s、-m选项，只需提供标签名字</td>
</tr>
<tr>
<td>git tag [tagname] [ref]</td>
<td>在指定提交创建一个标签</td>
</tr>
<tr>
<td>git tag -d [tagname]</td>
<td>删除指定标签</td>
</tr>
<tr>
<td>git push <remote> [tagname]</td>
<td>推送指定tag到远程服务器</td>
</tr>
<tr>
<td>git push <remote> --tags</td>
<td>推送所有tag到远程服务器</td>
</tr>
</tbody>
</table>
<h2 id="remote"><a class="header-anchor" href="#remote">¶</a>remote</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git remote -v</td>
<td>查看远程仓库的简写及其对应的URL</td>
</tr>
<tr>
<td>git remote show <remote></td>
<td>查看远程仓库更详细的信息</td>
</tr>
<tr>
<td>git remote add <shortname> <url></td>
<td>添加一个远程仓库</td>
</tr>
<tr>
<td>git remote remove <remote></td>
<td>删除一个远程仓库</td>
</tr>
<tr>
<td>git remote rename <old> <new></td>
<td>重命名远程仓库</td>
</tr>
<tr>
<td>git fetach <remote></td>
<td>从远程仓库下载本地没有的数据，不会自动merge</td>
</tr>
<tr>
<td>git pull <remote></td>
<td>从远程仓库下载本地没有的数据，并自动merge</td>
</tr>
<tr>
<td>git push <remote> <branch></td>
<td>将指定分支推送到远程服务器。<br>默认推送到同名分支，可用冒号指定推送到远程分支</td>
</tr>
<tr>
<td>git push <remote> [tagname]</td>
<td>推送指定tag到远程服务器</td>
</tr>
<tr>
<td>git push <remote> --tags</td>
<td>推送所有tag到远程服务器</td>
</tr>
</tbody>
</table>
<h2 id="选择提交"><a class="header-anchor" href="#选择提交">¶</a>选择提交</h2>
<p>选择单个提交</p>
<ul>
<li>40个字符的SHA1</li>
<li>SHA1的前几个字符（至少4个）且没有歧义</li>
<li>分支名，分支的最新提交</li>
<li>tag</li>
<li>父提交
<ul>
<li>xxxx^：第一父提交</li>
<li>xxxx^2：第二父提交，仅merge提交才有</li>
</ul>
</li>
<li>祖先提交
<ul>
<li>xxxx~：第一父提交，等价于xxxx^</li>
<li>xxxx~~或xxxx~2：第一父提交的第一父提交</li>
</ul>
</li>
</ul>
<p>提交区间</p>
<ul>
<li>双点：选出在一个分支中而不在另一个分支中的提交
<ul>
<li>master…experiment：在 experiment 分支中而不在 master 分支中的提交</li>
<li>origin/master…HEAD：在当前分支中而不在远程 origin 中的提交</li>
</ul>
</li>
<li>三点：两个引用<code>之一</code>包含但又不被两者同时包含的提交</li>
</ul>
<h2 id="rebase"><a class="header-anchor" href="#rebase">¶</a>rebase</h2>
<ul>
<li>将提交到某一分支上的所有修改都<code>移</code>至另一分支上</li>
<li>变基完成之后，需要快进merge</li>
<li>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git rebase [basebranch]</td>
<td>将当前branch的修改都rebase到<code>basebranch</code></td>
</tr>
<tr>
<td>git rebase [basebranch] [topicbranch]</td>
<td>将<code>topicbranch</code>的修改rebase到<code>basebranch</code></td>
</tr>
<tr>
<td>git rebase --onto [newbase] [basebranch] [topicbranch]</td>
<td>相比上一个，rebase的目标分支由–onto选项指定</td>
</tr>
<tr>
<td>git rebase -i</td>
<td>交互式变基，主要功能有改写commit msg、追加修改、重新排序提交、压缩提交、拆分提交。<br>不要对服务器上的修改进行交互式变基。</td>
</tr>
<tr>
<td>git rebase --continue</td>
<td>继续变基</td>
</tr>
</tbody>
</table>
<h2 id="cherry-pick"><a class="header-anchor" href="#cherry-pick">¶</a>cherry-pick</h2>
<h2 id="reset与checkout"><a class="header-anchor" href="#reset与checkout">¶</a>reset与checkout</h2>
<p>为了更好的理解reset和checkout，首先需要明确，git所有的命令都是操作三棵树。</p>
<table>
<thead>
<tr>
<th>树</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEAD</td>
<td>上一次提交的快照，下一次提交的父结点。该分支上的最后一次提交的快照</td>
</tr>
<tr>
<td>Index</td>
<td>预期的下一次提交的快照</td>
</tr>
<tr>
<td>Working Directory</td>
<td>沙盒</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>HEAD</th>
<th>Index</th>
<th>Workdir</th>
<th>WD Safe?</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Commit level</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset --soft [commit]</td>
<td>REF</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>仅移动HEAD分支的指向，不改变暂存区和工作区<br>撤销commit，回滚到了git commit之前</td>
</tr>
<tr>
<td>reset [commit]</td>
<td>REF</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>移动HEAD分支的指向，使索引看起来像HEAD，不改变工作区<br>回滚到了git add和git commit之前</td>
</tr>
<tr>
<td>reset --hard [commit]</td>
<td>REF</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>移动HEAD分支的指向，使索引看起来像HEAD，强制更改工作目录。</td>
</tr>
<tr>
<td>checkout [commit]</td>
<td>HEAD</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>移动HEAD自身来指向另一个分支，并更新暂存区和工作区。</td>
</tr>
<tr>
<td>File Level</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset [commit] – [paths]</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
<td>从[commit]复制指定文件到暂存区</td>
</tr>
<tr>
<td>checkout [commit] – [paths]</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>从指定[commit]复制文件到暂存区和工作区</td>
</tr>
</tbody>
</table>
<h2 id="实用工具"><a class="header-anchor" href="#实用工具">¶</a>实用工具</h2>
<h3 id="stash"><a class="header-anchor" href="#stash">¶</a>stash</h3>
<h3 id="clean"><a class="header-anchor" href="#clean">¶</a>clean</h3>
<h3 id="blame"><a class="header-anchor" href="#blame">¶</a>blame</h3>
<h3 id="bisect"><a class="header-anchor" href="#bisect">¶</a>bisect</h3>
<h3 id="bundle"><a class="header-anchor" href="#bundle">¶</a>bundle</h3>
<h2 id="submodule"><a class="header-anchor" href="#submodule">¶</a>submodule</h2>
<h2 id="底层命令"><a class="header-anchor" href="#底层命令">¶</a>底层命令</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git cat-file -t</td>
<td></td>
</tr>
<tr>
<td>git cat-file -p</td>
<td></td>
</tr>
<tr>
<td>git rev-parse --show-toplevel</td>
<td>显示工作区根目录</td>
</tr>
<tr>
<td>git rev-parse --show-prefix</td>
<td>相对于工作区根目录的相对目录</td>
</tr>
<tr>
<td>git rev-parse --show-cdup</td>
<td>显示从当前目录后退到工作区的根的深度</td>
</tr>
<tr>
<td>git ls-tree</td>
<td></td>
</tr>
<tr>
<td>git ls-files</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="SHA1的生成方法"><a class="header-anchor" href="#SHA1的生成方法">¶</a>SHA1的生成方法</h3>
<h4 id="commit对象"><a class="header-anchor" href="#commit对象">¶</a>commit对象</h4>
<ol>
<li>计算提交信息包含的字符数
<ul>
<li>git cat-file commit HEAD | wc -c</li>
</ul>
</li>
<li>在提交信息的前面加上<code>commit &lt;leng&gt;&lt;null&gt;</code>
<ul>
<li>&lt;leng&gt; 是第一步计算出来的长度</li>
<li>&lt;null&gt; 是空字符</li>
<li>(printf “commit &lt;leng&gt;\000”; git cat-file commit HEAD) | sha1sum</li>
</ul>
</li>
</ol>
<h4 id="blob对象"><a class="header-anchor" href="#blob对象">¶</a>blob对象</h4>
<ol>
<li>计算文件包含的字符数
<ul>
<li>git cat-file blob HEAD:filename | wc -c</li>
</ul>
</li>
<li>在提交信息的前面加上<code>blob &lt;leng&gt;&lt;null&gt;</code>
<ul>
<li>&lt;leng&gt; 是第一步计算出来的长度</li>
<li>&lt;null&gt; 是空字符</li>
<li>(printf “blob &lt;leng&gt;\000”; git cat-file blob HEAD:filename) | sha1sum</li>
</ul>
</li>
</ol>
<h4 id="tree对象"><a class="header-anchor" href="#tree对象">¶</a>tree对象</h4>
<ol>
<li>计算tree包含的字符数
<ul>
<li>git cat-file tree HEAD^{tree} | wc -c</li>
</ul>
</li>
<li>在提交信息的前面加上<code>tree &lt;leng&gt;&lt;null&gt;</code>
<ul>
<li>&lt;leng&gt; 是第一步计算出来的长度</li>
<li>&lt;null&gt; 是空字符</li>
<li>(printf “tree &lt;leng&gt;\000”; git cat-file tree HEAD^{tree}) | sha1sum</li>
</ul>
</li>
</ol>
<h2 id="技巧"><a class="header-anchor" href="#技巧">¶</a>技巧</h2>
<h3 id="命令提示符显示分支"><a class="header-anchor" href="#命令提示符显示分支">¶</a>命令提示符显示分支</h3>
<p>在<code>PS1</code>环境变量中加入如下内容，一般是放在<code>\w</code>或<code>\W</code>的后面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\[\033[36m\]`__git_ps1`\[\033[0m\]</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pk@localhost:blog (master)$</span><br></pre></td></tr></table></figure>
<p>在shell执行如下命令，会在<code>~/.bashrc</code>追加一条命令，这条指令会在现有的<code>PS1</code>后面追加<code>__git_ps1</code>。避免了手工修改<code>PS1</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PS1=&quot;$(echo $PS1 | sed &quot;s/\\\\\\\$[ \t]*$//g&quot;)\[\033[36m\]&quot;\`__git_ps1\`&quot;\[\033[0m\]\\$ &quot;&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>linux capabilities</title>
    <url>/2021/09/linux-capabilities/</url>
    <content><![CDATA[<p>linux <code>capability</code>相关的内容。</p>
<span id="more"></span>
<ol>
<li><code>capability</code>是什么</li>
<li>手册 <a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities.7.html</a></li>
<li>capset() capget() 系统调用</li>
<li>setcap 指令</li>
<li>systemd设置service的cap</li>
<li>查看进程的cap，cat /proc/[pid]/status | grep Cap，capsh 指令</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>博客自动更新updated时间</title>
    <url>/2021/09/update-updated-time-on-commit/</url>
    <content><![CDATA[<p>提交博客的时候自动修改更新时间。</p>
<span id="more"></span>
<p><code>hexo</code>博客在Markdown文件的前方，可以指定博客的发表时间和更新时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: xxxxxxxx</span><br><span class="line">date: 2021-09-09 23:04:19</span><br><span class="line">updated: 2021-09-09 23:04:19</span><br></pre></td></tr></table></figure>
<p>有时更新博客之后，会忘记更新<code>updated</code>字段。所以考虑使用<code>git hooks</code>自动化完成此任务。阅读<a href="https://www.git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">git hooks文档</a>后，发现<code>pre-commit</code>脚本可以很好的完成此任务，<code>pre-commit</code>脚本会在输入commit msg之前被执行。</p>
<p>还有一个问题，需要在脚本中拿到本次提交的文件列表。经过一番<a href="https://stackoverflow.com/questions/12170523/pre-commit-hooks-getting-partial-committed-file-list">搜索</a>，命令<code>git diff --cached --name-only</code>可以拿到这项信息。</p>
<p>经过上述的准备之后，简单组合之后，脚本就出来了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$1</span> file name</span></span><br><span class="line">function update_updated_time()</span><br><span class="line">&#123;</span><br><span class="line">    local file_name=$1</span><br><span class="line">    if [ ! &quot;$file_name&quot; ]; then</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    updated_time=$(date +&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">    sed -i &quot;1,10s/^updated.*$/updated: $&#123;updated_time&#125;/&quot; $file_name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for file in $(git diff --cached --name-only)</span><br><span class="line">do</span><br><span class="line">    update_updated_time $file</span><br><span class="line">    git add $file</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>使用strace监控系统调用</title>
    <url>/2021/09/use-strace-monitor-syscall/</url>
    <content><![CDATA[<p><code>strace</code>用来获取系统调用的参数和返回值，无论程序是以什么样的方式编译。被跟踪的程序可以是从strace命令运行的，也可以是系统上已经运行的进程，这需要适当的权限。程序无需重新编译，可以直接使用<code>strace</code>调试。可谓是调试工具中的一把瑞士军刀。</p>
<span id="more"></span>
<h2 id="strace安装"><a class="header-anchor" href="#strace安装">¶</a>strace安装</h2>
<p>根据自己的Linux发现版本，选择相应的命令安装即可。也可以从<a href="https://github.com/strace/strace">strace仓库</a>下载release包，编译安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install strace   # centos</span><br><span class="line">apt-get install strace  # ubuntu</span><br></pre></td></tr></table></figure>
<h2 id="strace基本使用方法"><a class="header-anchor" href="#strace基本使用方法">¶</a>strace基本使用方法</h2>
<p><code>strace</code>的使用方法非常简单，只需加上要跟踪的程序名即可。假如要查看<code>pwd</code>程序发出的系统调用，只需执行指令<code>strace pwd</code>即可，输出如下面所示（进行了删减）。每一行表示一个系统调用，每一行由等号分割为两部分。等号左边是系统调用及其对应的参数，等号右边是系统调用的返回值。如果系统调用出错，还会显示对应的<code>errno</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">strace <span class="built_in">pwd</span></span></span><br><span class="line">execve(&quot;/usr/bin/pwd&quot;, [&quot;pwd&quot;], 0x7ffd6a32df00 /* 32 vars */) = 0</span><br><span class="line">brk(NULL)                               = 0x14fd000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7bc2fd5000</span><br><span class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">......</span><br><span class="line">open(&quot;/usr/lib/locale/locale-archive&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=106176928, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 106176928, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7bbc4a4000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">getcwd(&quot;/root&quot;, 4096)                   = 6</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7bc2fd4000</span><br><span class="line">write(1, &quot;/root\n&quot;, 6/root</span><br><span class="line">)                  = 6</span><br><span class="line">close(1)                                = 0</span><br><span class="line">munmap(0x7f7bc2fd4000, 4096)            = 0</span><br><span class="line">close(2)                                = 0</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<h2 id="高级strace参数"><a class="header-anchor" href="#高级strace参数">¶</a>高级strace参数</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>统计每个系统调用的时间、调用和错误</td>
</tr>
<tr>
<td>-d</td>
<td>显示strace的一些调试输出</td>
</tr>
<tr>
<td>-e</td>
<td>指定输出的过滤表达式</td>
</tr>
<tr>
<td>-f</td>
<td>在创建子进程的时候跟踪它们</td>
</tr>
<tr>
<td>-ff</td>
<td>如果写入到输出文件，则把每个子进程写入到单独的文件中</td>
</tr>
<tr>
<td>-i</td>
<td>显示执行系统调用时的指令指针</td>
</tr>
<tr>
<td>-o</td>
<td>把输出写入到指定文件</td>
</tr>
<tr>
<td>-p</td>
<td>附加到由PID指定的现有进程</td>
</tr>
<tr>
<td>-q</td>
<td>抑制关于附加和分离的消息</td>
</tr>
<tr>
<td>-r</td>
<td>对每个系统调用显示一个相对的时间戳</td>
</tr>
<tr>
<td>-t</td>
<td>把时间添加到每一行</td>
</tr>
<tr>
<td>-tt</td>
<td>把时间添加到每一行，包括微秒</td>
</tr>
<tr>
<td>-ttt</td>
<td>添加epoch形式的时间（从1970年1月1日开始的秒数），包括微秒</td>
</tr>
<tr>
<td>-T</td>
<td>显示每个系统调用花费的时间</td>
</tr>
<tr>
<td>-v</td>
<td>显示不经省略的系统调用信息</td>
</tr>
<tr>
<td>-x</td>
<td>以十六进制格式显示所有非ASCII字符</td>
</tr>
<tr>
<td>-xx</td>
<td>以十六进程格式显示所有字符串</td>
</tr>
<tr>
<td>-s</td>
<td>字符串的长度，超过的字符串会显示为<code>...</code></td>
</tr>
</tbody>
</table>
<p>其中<code>-e</code>参数非常有用，可以过滤指定的系统调用。常见用法如下。更多用法请参考<a href="https://man7.org/linux/man-pages/man1/strace.1.html">man手册</a>。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e trace=read,getpid</td>
<td>只跟踪指定的系统调用</td>
</tr>
<tr>
<td>-e trace=!read</td>
<td>不跟踪read系统调用</td>
</tr>
<tr>
<td>-e trace=network</td>
<td>跟踪网络相关的系统调用</td>
</tr>
<tr>
<td>-e trace=signal</td>
<td>跟踪信号相关的系统调用</td>
</tr>
<tr>
<td>-e trace=ipc</td>
<td>跟踪IPC相关的系统调用</td>
</tr>
</tbody>
</table>
<p><code>-p</code>参数附加到现在正在运行的程序，对调试后台程序非常有用。当然，这需要相应的权限。</p>
<h2 id="strace工作原理"><a class="header-anchor" href="#strace工作原理">¶</a>strace工作原理</h2>
<p>使用<code>ptrace()</code>系统调用，可以在子进程调用系统调用时暂停子进程，这时可以读取子进程相关寄存器的值，从而确定子进程调用的系统调用和相关参数。</p>
<p>相关资料：</p>
<ul>
<li>strace源代码 <a href="https://github.com/strace/strace">https://github.com/strace/strace</a></li>
<li>strace手册 <a href="https://man7.org/linux/man-pages/man1/strace.1.html">https://man7.org/linux/man-pages/man1/strace.1.html</a></li>
<li>ptrace手册 <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">https://man7.org/linux/man-pages/man2/ptrace.2.html</a></li>
<li>ptrace系统调用示例 <a href="https://www.linuxjournal.com/article/6100?page=0,0">https://www.linuxjournal.com/article/6100?page=0,0</a>
<ul>
<li>中译版本 <a href="https://www.cnblogs.com/catch/p/3476280.html">https://www.cnblogs.com/catch/p/3476280.html</a></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>gerrit服务搭建与维护</title>
    <url>/2021/10/gerrit/</url>
    <content><![CDATA[<p>Gerrit是Google编写的一个免费、开放源代码的代码审查软件。也可以将Gerrit当作本地的git服务器使用。本文介绍如何安装并维护Gerrit服务。</p>
<span id="more"></span>
<h2 id="文档"><a class="header-anchor" href="#文档">¶</a>文档</h2>
<p>Gerrit提供了非常丰富的<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/3.4.1/index.html">文档</a>，包含了安装、使用、管理等方方面面。本文绝大部分参考了官方文档。</p>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<h3 id="JDK"><a class="header-anchor" href="#JDK">¶</a>JDK</h3>
<p>在安装Gerrit之后，系统需要安装好OracleJDK，不能是OpenJDK。目前最新版的Gerrit（3.4.1）需要JDK11。可以从以下站点下载JDK。</p>
<ul>
<li><a href="https://www.injdk.cn/">https://www.injdk.cn/</a></li>
<li><a href="https://mirrors.huaweicloud.com/java/jdk/">https://mirrors.huaweicloud.com/java/jdk/</a></li>
<li><a href="https://www.oracle.com/java/technologies/downloads/#java11">https://www.oracle.com/java/technologies/downloads/#java11</a></li>
</ul>
<p>JDK解压好之后，设置相关的环境变量。使用命令<code>java --version</code>测试安装是否成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk-11.0.12</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<h3 id="Gerrit"><a class="header-anchor" href="#Gerrit">¶</a>Gerrit</h3>
<p><a href="https://www.gerritcodereview.com/">点击进入Gerrit官网</a>，可以下载到最新版的Gerrit。使用如下命令安装Gerrit。更多关于安装的信息可以参考<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/3.4.1/linux-quickstart.html">Gerrit快速安装</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar /path/to/gerrit.war init -d gerrit_path</span><br></pre></td></tr></table></figure>
<h2 id="认证方式"><a class="header-anchor" href="#认证方式">¶</a>认证方式</h2>
<p>Gerrit支持HTTP、OpenID等多种认证方式。这里选择最简单的HTTP。使用如下命令创建一个密码文件，添加一个用户admin，密码是123456。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">htpasswd -b -c /gerrit/gerrit.htpasswd admin 123456</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-b 指定密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c 创建文件</span></span><br></pre></td></tr></table></figure>
<h2 id="设置Gerrit网站"><a class="header-anchor" href="#设置Gerrit网站">¶</a>设置Gerrit网站</h2>
<p>在宝塔面板添加一个网站，并为网站设置HTTP认证，文件选择刚刚创建的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auth_basic            &quot;Restricted&quot;;</span><br><span class="line">auth_basic_user_file /gerrit/gerrit.htpasswd;</span><br></pre></td></tr></table></figure>
<p>添加反向代理，代理到Gerrit的HTTP端口，默认是8080。</p>
<img src="https://image.pkemb.com/image/20211005163738.png" style="zoom: 30%;" />
<h2 id="Gerrit服务设置"><a class="header-anchor" href="#Gerrit服务设置">¶</a>Gerrit服务设置</h2>
<h3 id="端口"><a class="header-anchor" href="#端口">¶</a>端口</h3>
<p>默认情况下，gerrit网页使用8080端口，git服务使用29418端口，可以在<code>$GERRIT_SITE/etc/gerrit.config</code>更改默认的端口。需要在宝塔放开这两个端口，才能正常使用Gerrit提供的服务。</p>
<h3 id="启动参数"><a class="header-anchor" href="#启动参数">¶</a>启动参数</h3>
<p><a href="https://gerrit-documentation.storage.googleapis.com/Documentation/3.4.1/pgm-daemon.html">https://gerrit-documentation.storage.googleapis.com/Documentation/3.4.1/pgm-daemon.html</a></p>
<p><code>$GERRIT_SITE/bin/gerrit.sh</code>脚本中的<code>RUN_ARGS</code>变量。</p>
<h3 id="gerrit-war"><a class="header-anchor" href="#gerrit-war">¶</a>gerrit.war</h3>
<p>gerrit.war既是安装程序，也是一个服务端管理工具。支持<code>init</code>、<code>reindex</code>等子命令。更加详细的信息可以查看官方文档<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/3.4.1/pgm-index.html">Server Side Administrative Tools</a>。</p>
<h3 id="导入现有git仓库"><a class="header-anchor" href="#导入现有git仓库">¶</a>导入现有git仓库</h3>
<p>首先在Gerrit上创建一个仓库，不要创建一个空的初始化提交。</p>
<img src="https://image.pkemb.com/image/20211005164654.png"  style="zoom: 30%;"/>
<p>假设git仓库存储在<code>/gerrit/git</code>目录中，执行下列命令导入现有仓库的提交。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --mirror url</span><br><span class="line">cd xxxxx.git</span><br><span class="line">git push --mirror file:///gerrit/git/xxxxx.git</span><br></pre></td></tr></table></figure>
<h3 id="设置邮件"><a class="header-anchor" href="#设置邮件">¶</a>设置邮件</h3>
<p>示例是使用的office365的邮件服务。如果是其他的邮件服务，设置不完全一样。有关<code>sendemail</code>的更多设置，可以参考<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/3.4.1/config-gerrit.html#sendemail">官方文档</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GERRIT_SITE=/gerrit</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config sendemail.enable true</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config sendemail.smtpServer smtp.office365.com</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config sendemail.smtpServerPort 587</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config sendemail.smtpEncryption TLS</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config sendemail.sslVerify true</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config sendemail.smtpUser user@host</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config sendemail.smtpPass password</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config sendemail.from CodeReview&lt;user@host&gt;</span><br></pre></td></tr></table></figure>
<h3 id="仓库的URL"><a class="header-anchor" href="#仓库的URL">¶</a>仓库的URL</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GERRIT_SITE=/gerrit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用HTTP协议<span class="built_in">clone</span>仓库的URL</span></span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config gerrit.gitHttpUrl http://gerrit.pk.inc:8080</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用SSH协议<span class="built_in">clone</span>仓库的URL</span></span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config gerrit.canonicalGitUrl ssh://gerrit.pk.inc:29418</span><br></pre></td></tr></table></figure>
<h2 id="开机启动"><a class="header-anchor" href="#开机启动">¶</a>开机启动</h2>
<p>这里使用systemd来管理gerrit服务。在<code>/lib/systemd/system</code>目录在创建文件<code>gerrit.service</code>，并输入以下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">SourcePath=/etc/rc.d/init.d/gerrit</span><br><span class="line">Description=LSB: Start/stop Gerrit Code Review</span><br><span class="line">Before=runlevel2.target</span><br><span class="line">Before=runlevel3.target</span><br><span class="line">Before=runlevel4.target</span><br><span class="line">Before=runlevel5.target</span><br><span class="line">Before=shutdown.target</span><br><span class="line">After=nss-lookup.target</span><br><span class="line">After=remote-fs.target</span><br><span class="line">After=network-online.target</span><br><span class="line">After=synchrony.service</span><br><span class="line">Conflicts=shutdown.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Restart=no</span><br><span class="line">TimeoutSec=5min</span><br><span class="line">IgnoreSIGPIPE=no</span><br><span class="line">KillMode=process</span><br><span class="line">GuessMainPID=no</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">ExecStart=/gerrit/bin/gerrit.sh start</span><br><span class="line">ExecStop=/gerrit/bin/gerrit.sh stop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>然后就可以使用systemctl命令来管理Gerrit服务了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启动</span></span><br><span class="line">systemctl enable gerrit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动启动Gerrit</span></span><br><span class="line">systemctl start gerrit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动停止Gerrit</span></span><br><span class="line">systemctl stop gerrit</span><br></pre></td></tr></table></figure>
<h2 id="备份与还原"><a class="header-anchor" href="#备份与还原">¶</a>备份与还原</h2>
<h3 id="备份"><a class="header-anchor" href="#备份">¶</a>备份</h3>
<p>备份的方法很简单，停止gerrit服务，然后将整个站点目录打包即可。下面是一个示例的备份脚本，在宝塔面板添加一个定时任务，定时运行此脚本即可。</p>
<blockquote>
<p>如果数据库MySQL等外部数据库，而不是内置的db2，则还需要备份数据库。以下脚本没有备份数据库。</p>
</blockquote>
<blockquote>
<p>git仓库保存在/gerrit/git目录下，所以这个脚本会一起备份。如果git仓库在不同的目录，需要修改脚本，同时备份git仓库。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">backup gerrit site</span></span><br><span class="line"></span><br><span class="line">BACKUP_DIR=&quot;/backups/gerrit&quot;</span><br><span class="line">GERRIT_SITE=&quot;/gerrit&quot;</span><br><span class="line"></span><br><span class="line">LOCK_FILE=&quot;/tmp/gerrit_bakcup_lock&quot;</span><br><span class="line"></span><br><span class="line">[ -d $BACKUP_DIR ] || mkdir -p $BACKUP_DIR</span><br><span class="line"></span><br><span class="line">function LOG()</span><br><span class="line">&#123;</span><br><span class="line">        if [ $# = 0 ]; then</span><br><span class="line">                return</span><br><span class="line">        fi</span><br><span class="line">        echo -n `date +&quot;%Y-%m-%d %H:%M:%S&quot;`</span><br><span class="line">        echo -n &quot; &quot;</span><br><span class="line">        echo $*</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while [ -f $LOCK_FILE ]</span><br><span class="line">do</span><br><span class="line">        LOG &quot;lock file exist, wait...&quot;</span><br><span class="line">        sleep 1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">touch $LOCK_FILE</span><br><span class="line"></span><br><span class="line">LOG &quot;stop gerrit service...&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="variable">$GERRIT_SITE</span>/bin/gerrit.sh stop</span></span><br><span class="line">systemctl stop gerrit</span><br><span class="line">sync</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line">LOG &quot;tar gerrit site...&quot;</span><br><span class="line">FILE_NAME=gerrit_backup_$(date +&quot;%Y%m%d-%H%M%S&quot;).tar.gz</span><br><span class="line">tar -czf $FILE_NAME $GERRIT_SITE</span><br><span class="line">if [ $? != 0 ]; then</span><br><span class="line">        LOG &quot;tar fail, please check...&quot;</span><br><span class="line">        rm -rfv $FILE_NAME</span><br><span class="line">        rm -rf  $LOCK_FILE</span><br><span class="line">        exit 1</span><br><span class="line">fi</span><br><span class="line">mv $FILE_NAME $BACKUP_DIR</span><br><span class="line"></span><br><span class="line">LOG &quot;start gerrit service...&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="variable">$GERRIT_SITE</span>/bin/gerrit.sh start</span></span><br><span class="line">systemctl start gerrit</span><br><span class="line"></span><br><span class="line">LOG &quot;start sync backup file to cloud...&quot;</span><br><span class="line">/root/bin/rsync_bakcup.sh</span><br><span class="line"></span><br><span class="line">rm -rf $LOCK_FILE</span><br></pre></td></tr></table></figure>
<h3 id="还原"><a class="header-anchor" href="#还原">¶</a>还原</h3>
<p>将备份好的压缩包解压之后，即可使用<code>$GERRIT_SITE/bin/gerrit.bin start</code>启动服务。由于<code>etc/gerrit.config</code>中存在一个叫做<code>gerrit.serverId</code>的设置。建议在那一台服务器备份的，就在那一台服务器还原。还原之后，最好检查一下<code>etc/gerrit.config</code>中的相关设置是否有效。</p>
<h2 id="升级"><a class="header-anchor" href="#升级">¶</a>升级</h2>
<p>如果gerrit有新版本了，可以使用gerrit.war的init命令来升级gerrit。升级的注意事项：</p>
<ol>
<li>升级之前建议手工启动一次备份脚本。避免升级失败，导致服务奔溃或数据丢失。</li>
<li>当版本号跨度较大时，不建议一次性升级。建议分多次升级。</li>
<li>升级之前，可以阅读一下目标版本的release note。例如3.3的是<a href="https://www.gerritcodereview.com/3.3.html">3.3.html</a>。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GERRIT_SITE=/gerrit</span><br><span class="line">systemctl stop gerrit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或使用原生的停止脚本</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="variable">$GERRIT_SITE</span>/bin/gerrit.sh stop</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-b 表示批处理，不使用交互模式</span></span><br><span class="line">java -jar path/to/gerrit_new_version.war init -d $&#123;GERRIT_SITE&#125; -b</span><br></pre></td></tr></table></figure>
<h2 id="插件"><a class="header-anchor" href="#插件">¶</a>插件</h2>
<p>从<a href="https://gerrit-ci.gerritforge.com/">https://gerrit-ci.gerritforge.com</a>下载插件，放入目录<code>$GERRIT_SITE/plugins</code>，重新Gerrit即可。</p>
<h2 id="集成gitweb"><a class="header-anchor" href="#集成gitweb">¶</a>集成gitweb</h2>
<p>官方文档<a href="https://gerrit-documentation.storage.googleapis.com/Documentation/3.4.1/config-gitweb.html">Gitweb Integration</a>提供了两种集成gitweb的方法。一种是内置式，由gerrit来管理的gitweb。一种是外挂式，手工管理的gitweb。我这里选择第二种方式，gitweb的搭建可以参考<a href="https://pkemb.com/2021/10/gitweb/">在宝塔面板使用nginx搭建Gitweb服务</a>。搭建好gitweb之后，使用如下命令设置Gerrit，然后重启即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GERRIT_SITE=/gerrit</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config gitweb.type gitweb</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config --unset gitweb.cgi</span><br><span class="line">git config -f $GERRIT_SITE/etc/gerrit.config gitweb.url http://gitweb.pk.inc</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>在宝塔面板使用nginx搭建Gitweb服务</title>
    <url>/2021/10/gitweb/</url>
    <content><![CDATA[<p>为了更加方便的访问服务器上的git仓库，搭建<code>Gitweb</code>服务。<code>Gitweb</code>是一个Git网络接口。它是用Perl编写的，可以用作CGI脚本。它允许使用Web浏览器浏览git仓库。本文介绍如何在宝塔面板下使用<code>nginx</code>搭建<code>Gitweb</code>服务。</p>
<span id="more"></span>
<h2 id="软件安装"><a class="header-anchor" href="#软件安装">¶</a>软件安装</h2>
<h3 id="Gitweb"><a class="header-anchor" href="#Gitweb">¶</a>Gitweb</h3>
<p>安装git时，默认会安装Gitweb。如果没有，可以使用包管理器安装。</p>
<p>Ubuntu：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install gitweb</span><br></pre></td></tr></table></figure>
<p>CentOS：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gitweb</span><br></pre></td></tr></table></figure>
<p>gitweb安装完成之后，需要确定<code>gitweb.cgi</code>所在的路径。从<code>locate</code>命令的输出结果看，gitweb所在的目录是<code>/usr/local/git/share/gitweb</code>。记住这个路径，后面会用到。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# updatedb</span><br><span class="line">[root@localhost ~]# locate gitweb.cgi</span><br><span class="line">/usr/local/git/share/gitweb/gitweb.cgi</span><br></pre></td></tr></table></figure>
<h3 id="设置projectroot"><a class="header-anchor" href="#设置projectroot">¶</a>设置projectroot</h3>
<p>更改<code>/ect/gitweb.conf</code>，将<code>$projectroot</code>设置为git仓库所在的目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">our $projectroot = &quot;/path/to/gitrepo&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="fastcgi"><a class="header-anchor" href="#fastcgi">¶</a>fastcgi</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install fcgi-devel spawn-fcgi</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install fcgiwrap spawn-fcgi</span><br></pre></td></tr></table></figure>
<h3 id="fastcgi-wrapper"><a class="header-anchor" href="#fastcgi-wrapper">¶</a>fastcgi-wrapper</h3>
<blockquote>
<p>Ubuntu可以跳过此步。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/gnosek/fcgiwrap.git</span><br><span class="line">cd fcgiwrap</span><br><span class="line">autoconf -i</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>启动fastcgi-wrapper。可以任意选择一个空闲的端口，需要在宝塔面板放开端口。注意根据实际情况更改<code>fcgiwrap</code>的路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spawn-fcgi -f /usr/local/sbin/fcgiwrap -p 8050</span><br></pre></td></tr></table></figure>
<h2 id="设置Gitweb网站"><a class="header-anchor" href="#设置Gitweb网站">¶</a>设置Gitweb网站</h2>
<p>在宝塔面板新建一个网站，更改网站设置。将<code>index</code>更改为<code>gitweb.cgi</code>，<code>root</code>更改为gitweb所在的路径。当访问cgi结尾的文件时，通过<code>fastcgi-wrapper</code>响应，注意这里的<code>8050</code>端口。保存设置，就可以访问网站了。</p>
<img src="https://image.pkemb.com/image/20211005101200.png"/>
<h2 id="fastcgi-wrapper开机自启动"><a class="header-anchor" href="#fastcgi-wrapper开机自启动">¶</a>fastcgi-wrapper开机自启动</h2>
<p>如果要访问<code>gitweb</code>网站，<code>fcgiwrap</code>一定要处于开启状态。为了保证服务器重启之后gitweb还能正常访问，需要添加开机自启动。这里选择使用systemd来完成。新增文件<code>/lib/systemd/system/fcgi.service</code>，并在文件写入以下内容，保存退出。</p>
<blockquote>
<p>根据实际情况修改<code>spawn-fcgi</code>和<code>fcgiwrap</code>的路径。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=fastcgi-wrapper</span><br><span class="line">After=network.target</span><br><span class="line">Conflicts=shutdown.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=1</span><br><span class="line">ExecStart=/usr/bin/spawn-fcgi -f /usr/local/sbin/fcgiwrap -p 8050</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>然后就可以使用systemctl来管理<code>fcgi</code>服务了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启动</span></span><br><span class="line">systemctl enable fcgi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动启动</span></span><br><span class="line">systemctl start fcgi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止服务</span></span><br><span class="line">systemctl stop fcgi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看服务状态</span></span><br><span class="line">systemctl status fcgi</span><br></pre></td></tr></table></figure>
<h2 id="Gitweb美化"><a class="header-anchor" href="#Gitweb美化">¶</a>Gitweb美化</h2>
<p>从网站<a href="http://kogakure.github.io/gitweb-theme/">gitweb-theme</a>下载主题文件，将解压后的文件放入<code>/usr/local/git/share/gitweb/static</code>目录。注意备份原始文件。</p>
<h2 id="修复中文乱码"><a class="header-anchor" href="#修复中文乱码">¶</a>修复中文乱码</h2>
<h3 id="中文路径乱码"><a class="header-anchor" href="#中文路径乱码">¶</a>中文路径乱码</h3>
<p>打开一些中文目录或文件时，网页会乱码。修改<code>gitweb.cgi</code>文件，将所有的<code>file_name=&gt;&quot;$basedir$t-&gt;&#123;'name'&#125;&quot;</code>替换为<code>file_name=&gt;&quot;$basedir&quot;.to_utf8($t-&gt;&#123;'name'&#125;)</code>。可以使用下面的sed命令完成替换。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/&#x27;file_name\=\&gt;\&quot;\$basedir\$t-\&gt;&#123;\&#x27;name\&#x27;&#125;\&quot;/file_name\=\&gt;\&quot;\$basedir\&quot;.to_utf8\(\$t-\&gt;&#123;\&#x27;name\&#x27;&#125;\)&#x27;/g&#x27; /usr/local/git/share/gitweb/gitweb.cgi</span><br></pre></td></tr></table></figure>
<h3 id="中文内容乱码"><a class="header-anchor" href="#中文内容乱码">¶</a>中文内容乱码</h3>
<p>点击<code>raw</code>按钮查看文件的内容，中文显示为乱码。更改<code>gitweb.cgi</code>，将</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">our</span> <span class="variable">$default_text_plain_charset</span>  = <span class="keyword">undef</span>;</span><br></pre></td></tr></table></figure>
<p>更改为</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">our</span> <span class="variable">$default_text_plain_charset</span>  = <span class="string">&#x27;utf8&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="最终效果"><a class="header-anchor" href="#最终效果">¶</a>最终效果</h2>
<img src="https://image.pkemb.com/image/20211005123655.png"/>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://blog.csdn.net/chenjh213/article/details/49074877">https://blog.csdn.net/chenjh213/article/details/49074877</a></li>
<li><a href="https://blog.csdn.net/fromcaolei/article/details/78530059">https://blog.csdn.net/fromcaolei/article/details/78530059</a></li>
<li><a href="https://git.wiki.kernel.org/index.php/Gitweb">https://git.wiki.kernel.org/index.php/Gitweb</a></li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建局域网DNS服务器</title>
    <url>/2021/10/local-dns-server/</url>
    <content><![CDATA[<p>局域网有非常多的机器时，使用IP远程登录非常容易搞混。最好的解决方法是搭建一个局域网的DNS服务器，使用不同的域名指向不同的机器。使用域名的好处远不止这一个，还有很多其他的好处。例如当IP地址发生变化时，只需要更改DNS服务器的设置即可。</p>
<span id="more"></span>
<h2 id="DNS简介"><a class="header-anchor" href="#DNS简介">¶</a>DNS简介</h2>
<p>Domain Name System, 更加详细的介绍参考以下链接。</p>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">DNS原理入门</a></li>
<li><a href="https://zh.wikipedia.org/zh-hans/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">wiki</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc1034">RFC 1034 DOMAIN NAMES - CONCEPTS AND FACILITIES</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc1035">RFC 1035 DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION</a></li>
</ul>
<h2 id="DNS软件"><a class="header-anchor" href="#DNS软件">¶</a>DNS软件</h2>
<p>下面列出了常见的DNS软件。本次搭建选用<code>dnsmasq</code>，专门争对小型局域网设计，资源占用低，易配置。</p>
<ul>
<li><a href="https://www.isc.org/bind/">BIND</a>（Berkeley Internet Name Domain），使用最广的DNS软件</li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=DJBDNS&amp;action=edit&amp;redlink=1">DJBDNS</a>（Dan J Bernstein’s DNS implementation）</li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=MaraDNS&amp;action=edit&amp;redlink=1">MaraDNS</a></li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=Name_Server_Daemon&amp;action=edit&amp;redlink=1">Name Server Daemon</a>（Name Server Daemon）</li>
<li><a href="https://zh.wikipedia.org/wiki/PowerDNS">PowerDNS</a></li>
<li><a href="https://thekelleys.org.uk/dnsmasq/doc.html">Dnsmasq</a></li>
</ul>
<h3 id="dnsmasq"><a class="header-anchor" href="#dnsmasq">¶</a>dnsmasq</h3>
<p>下面列出了dnsmasq相关的网页。</p>
<ul>
<li>主页：<a href="https://thekelleys.org.uk/dnsmasq/doc.html">https://thekelleys.org.uk/dnsmasq/doc.html</a></li>
<li>man page：<a href="https://thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html">https://thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html</a></li>
<li>配置文件示例：<a href="https://thekelleys.org.uk/dnsmasq/docs/dnsmasq.conf.example">https://thekelleys.org.uk/dnsmasq/docs/dnsmasq.conf.example</a>
<ul>
<li>中文版：<a href="https://www.cnblogs.com/studio313/p/6278698.html">https://www.cnblogs.com/studio313/p/6278698.html</a></li>
</ul>
</li>
<li>维基百科：<a href="https://zh.wikipedia.org/wiki/Dnsmasq">https://zh.wikipedia.org/wiki/Dnsmasq</a></li>
</ul>
<h2 id="dnsmasq安装"><a class="header-anchor" href="#dnsmasq安装">¶</a>dnsmasq安装</h2>
<p><code>dnsmasq</code>只支持Linux系统，直接使用发行版本自带的包管理器安装即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// ubuntu</span><br><span class="line">apt-get install dnsmasq</span><br><span class="line">// cent-os</span><br><span class="line">yum -y install dnsmasq</span><br></pre></td></tr></table></figure>
<p>考虑到DNS服务器最好是24小时开机，所以安装dnsmasq的最佳位置是路由器。巧了，路由器直接集成了dnsmasq，不用安装，直接使用即可。</p>
<p>需要注意的是，路由器出厂自带的固件可能不支持更改dnsmasq的配置文件，需要刷第三方的老毛子或梅林固件。关于这部分的内容，可以搜索引擎找到更详细的内容，这里不展开了。下面以华硕AX86U、梅林386.2为例。</p>
<h2 id="dnsmasq配置"><a class="header-anchor" href="#dnsmasq配置">¶</a>dnsmasq配置</h2>
<h3 id="ssh登录路由器"><a class="header-anchor" href="#ssh登录路由器">¶</a>ssh登录路由器</h3>
<p>路由器的web界面没有找到dnsmasq的配置页面，所以只能ssh登录路由器，直接更改配置文件。需要先进入路由器的web管理页面，在<code>系统管理 -&gt; 系统设置</code>页面，打开ssh登录。</p>
<img src="https://image.pkemb.com/image/20211030112805.png"/>
<h3 id="配置文件路径"><a class="header-anchor" href="#配置文件路径">¶</a>配置文件路径</h3>
<p>路由器的rootfs是只读文件系统，所以不能直接更改配置文件<code>/etc/dnsmasq.conf</code>。查看梅林固件的手册，发现可以将自定义配置写在<code>/jffs/configs/dnsmasq.conf.add</code>。<code>/jffs</code>是一个可读写的文件系统，并且重启之后配置文件也不会丢失。</p>
<blockquote>
<p>在网上查找资料时，有个帖子说频繁向jffs文件系统写入数据，容易导致flash损坏，建议将配置文件存储在U盘。个人觉得没有必要，因为配置文件的数据量比较小，而且配置文件存储在U盘，还会增加系统的不稳定性。</p>
</blockquote>
<h3 id="重启服务"><a class="header-anchor" href="#重启服务">¶</a>重启服务</h3>
<p>更改配置文件之后，执行命令<code>service restart_dnsmasq</code>重启服务，配置才会生效。重启之后，<code>/jffs/configs/dnsmasq.conf.add</code>文件的内容都会出现在<code>/etc/dnsmasq.conf</code>。所以可以通过查看<code>/etc/dnsmasq.conf</code>的内容，确认配置是否生效。</p>
<blockquote>
<p>重启命令中的下划线必须要有。</p>
</blockquote>
<h3 id="常用配置"><a class="header-anchor" href="#常用配置">¶</a>常用配置</h3>
<p>下面列出了有关DNS的常用设置。更多设置可以参考<a href="https://thekelleys.org.uk/dnsmasq/docs/dnsmasq.conf.example">dnsmasq.conf.example</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># A, AAAA 和 PTR 记录</span><br><span class="line">#host-record=&lt;name&gt;[,&lt;name&gt;....],[&lt;IPv4-address&gt;],[&lt;IPv6-address&gt;][,&lt;TTL&gt;]</span><br><span class="line"># CNAME 别名记录</span><br><span class="line">#cname=&lt;cname&gt;,&lt;target&gt;[,&lt;TTL&gt;]</span><br><span class="line"># SRV 记录</span><br><span class="line">#srv-host=&lt;_service&gt;.&lt;_prot&gt;.[&lt;domain&gt;],[&lt;target&gt;[,&lt;port&gt;[,&lt;priority&gt;[,&lt;weight&gt;]]]]</span><br><span class="line"># TXT 记录</span><br><span class="line">#txt-record=&lt;name&gt;[[,&lt;text&gt;],&lt;text&gt;]</span><br><span class="line"># PTR 记录</span><br><span class="line">#ptr-record=&lt;name&gt;[,&lt;target&gt;]</span><br><span class="line"># Include all files in a directory which end in .conf</span><br><span class="line">#conf-dir=/etc/dnsmasq.d/,*.conf</span><br></pre></td></tr></table></figure>
<h2 id="更改DNS服务器地址"><a class="header-anchor" href="#更改DNS服务器地址">¶</a>更改DNS服务器地址</h2>
<p>需要将系统的DNS服务器地址更改为自己搭建的DNS服务器（即路由器），域名才能够解析。为了减少配置，可以在路由器设置默认的DNS服务器地址。进入路由器的web管理界面，<code>内部网络(LAN) -&gt; DHCP服务器</code>。</p>
<img src="https://image.pkemb.com/image/20211030130042.png"/>
<p>如果不想使用路由器设置的默认DNS服务器，也可以使用下面的方法自定义系统的DNS服务器。</p>
<h3 id="winsows"><a class="header-anchor" href="#winsows">¶</a>winsows</h3>
<ol>
<li>进入控制面板，网络和Internet，网络和共享中心</li>
<li>点击更改适配器设置</li>
<li>选中当前使用的网卡，右键，选择属性</li>
<li>双击IPv4</li>
<li>自定义DNS服务器地址</li>
<li>在cmd执行命令<code>ipconfig /flushdns</code>刷新DNS</li>
</ol>
<img src="https://image.pkemb.com/image/20211030130258.png"/>
<h3 id="Linux"><a class="header-anchor" href="#Linux">¶</a>Linux</h3>
<p>更改<code>/etc/resolv.conf</code>，增加一条nameserver记录即可，格式如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nameserver x.x.x.x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>某些DHCP客户端可能会修改<code>/etc/resolv.conf</code>，导致系统重启后自定义设置丢失。有关这部分的内容，请参考对应DHCP客户端的手册。</p>
</blockquote>
<h3 id="Android"><a class="header-anchor" href="#Android">¶</a>Android</h3>
<p><em>TODO</em></p>
<h3 id="IOS"><a class="header-anchor" href="#IOS">¶</a>IOS</h3>
<p><em>TODO</em></p>
<h2 id="DNS调试命令"><a class="header-anchor" href="#DNS调试命令">¶</a>DNS调试命令</h2>
<ul>
<li><a href="https://linux.die.net/man/1/nslookup">nslookup</a></li>
<li><a href="https://linux.die.net/man/1/dig">dig</a></li>
</ul>
<blockquote>
<p>windows 系统支持nslookup指令，但是不支持dig。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nslookup baidu.com</span><br><span class="line">Server:         192.168.50.1</span><br><span class="line">Address:        192.168.50.1#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:   baidu.com</span><br><span class="line">Address: 220.181.38.251</span><br><span class="line">Name:   baidu.com</span><br><span class="line">Address: 220.181.38.148</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# dig baidu.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; baidu.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 382</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 1280</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;baidu.com.                     IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">baidu.com.              589     IN      A       220.181.38.148</span><br><span class="line">baidu.com.              589     IN      A       220.181.38.251</span><br><span class="line"></span><br><span class="line">;; Query time: 1 msec</span><br><span class="line">;; SERVER: 192.168.50.1#53(192.168.50.1)</span><br><span class="line">;; WHEN: Sat Oct 30 13:17:40 CST 2021</span><br><span class="line">;; MSG SIZE  rcvd: 70</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>导出Confluence空间为PDF</title>
    <url>/2021/11/export-confluence-space-to-pdf/</url>
    <content><![CDATA[<p>Confluence是一个专业的知识管理与协同软件，我用来记录、管理自己的笔记。同时Confluence还是一个非常复杂的系统，复杂就容易出问题。为了在极端情况下（例如数据库奔溃）还能打开自己的笔记，开发了一个脚本，定时导出Confluence空间为PDF文件。</p>
<span id="more"></span>
<h2 id="资料查找"><a class="header-anchor" href="#资料查找">¶</a>资料查找</h2>
<p>在开发之前，一定要找找是否有类似的工具，能达到相同的目的。</p>
<h3 id="confluence"><a class="header-anchor" href="#confluence">¶</a>confluence</h3>
<p>confluence自身提供了导出为PDF的功能，并且还提供了<a href="https://github.com/atlassian-api/atlassian-python-api">python api</a>，可惜只能导出单个页面为PDF文件，不支持导出整个空间。</p>
<p>如果对空间有管理员权限，进入<code>空间管理-&gt;内容工具-&gt;导出</code>，可以选择导出为HTML、XML或PDF。这个满足需求，可惜没有提供API。在寻找资料时，有帖子说老版本提供了API，但是新版本不支持了。</p>
<img src="https://image.pkemb.com/image/20211113123142.png" style="zoom: 60%;" />
<h3 id="Confluence-Command-Line-Interface"><a class="header-anchor" href="#Confluence-Command-Line-Interface">¶</a>Confluence Command Line Interface</h3>
<p>寻找资料时发现了一个非常牛逼的工具，<a href="https://bobswift.atlassian.net/wiki/spaces/CSOAP/overview">Confluence Command Line Interface</a>，支持非常多的功能，当然也支持导出整个空间为PDF。但是需要配合插件使用，插件需要收费。由于没有找到**插件的方法，所以放弃。</p>
<h2 id="方法1：导出所有页面然后合并"><a class="header-anchor" href="#方法1：导出所有页面然后合并">¶</a>方法1：导出所有页面然后合并</h2>
<p>考虑到<code>confluence</code>提供了导出单个页面为PDF的API，所以导出所有的页面，然后合并为一个PDF文件，也不是什么难事。脚本的主要思路如下，源码请移步<a href="https://github.com/pkemb/tools/blob/master/atlassian/export_all_confluence_page.py">github</a>。</p>
<ol>
<li>get_all_spaces() 获取所有空间的key</li>
<li>get_home_page_of_space() 获取指定空间的homepage id</li>
<li>get_page_child_by_type() 获取指定页面的一级子页面</li>
<li>递归获取页面转化为BytesIO对象，追加到PdfFileMerger对象</li>
<li>PdfFileMerger写入到文件，使用<code>space name</code>作为文件名。</li>
</ol>
<p>需要安装<code>atlassian api</code>和<code>PyPDF2</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install atlassian-python-api</span><br><span class="line">pip install PyPDF2</span><br></pre></td></tr></table></figure>
<p>但是这种方法有以下两个缺点：</p>
<ol>
<li>PDF的大纲没有层次，父页面的大纲和子页面的大纲处于同一级。</li>
<li>在PDF点击目录宏的链接，会跳转到网页，而不是PDF对应的页面。</li>
</ol>
<h2 id="方法2：使用空间管理工具导出"><a class="header-anchor" href="#方法2：使用空间管理工具导出">¶</a>方法2：使用空间管理工具导出</h2>
<p>Confluence的空间管理工具可以很好的导出PDF，但是没有API。但是可以利用无头浏览器，模拟人点击网页，达到导出整个空间为pdf的目的。源码请异步<a href="https://github.com/pkemb/tools/blob/master/atlassian/export_confluence_by_spider.py">github</a>。</p>
<p>需要安装<code>atlassian api</code>、<code>selenium</code>和<code>Chrome webdriver</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install atlassian-python-api</span><br><span class="line">pip install selenium</span><br><span class="line">apt-get install chromium-chromedriver</span><br></pre></td></tr></table></figure>
<h2 id="自定义PDF样式"><a class="header-anchor" href="#自定义PDF样式">¶</a>自定义PDF样式</h2>
<p>confluence支持自定义PDF的样式，包含页眉、页脚、字体、字号等等内容。更加详细的内容可以参考<a href="https://docs.atlassian.com/confluence/docs-713/Customize+Exports+to+PDF">官方文档</a>。</p>
<h3 id="设置PDF字体大小"><a class="header-anchor" href="#设置PDF字体大小">¶</a>设置PDF字体大小</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wiki-content</span> <span class="selector-tag">h1</span></span><br><span class="line">&#123; <span class="attribute">font-size</span>: <span class="number">26pt</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wiki-content</span> <span class="selector-tag">h2</span></span><br><span class="line">&#123; <span class="attribute">font-size</span>: <span class="number">22pt</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wiki-content</span> <span class="selector-tag">h3</span></span><br><span class="line">&#123; <span class="attribute">font-size</span>: <span class="number">16pt</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wiki-content</span> <span class="selector-tag">h4</span></span><br><span class="line">&#123; <span class="attribute">font-size</span>: <span class="number">14pt</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wiki-content</span> <span class="selector-tag">h5</span></span><br><span class="line">&#123; <span class="attribute">font-size</span>: <span class="number">14pt</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wiki-content</span> <span class="selector-tag">h6</span></span><br><span class="line">&#123; <span class="attribute">font-size</span>: <span class="number">14pt</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">p</span>,<span class="selector-tag">li</span>,<span class="selector-tag">td</span>,<span class="selector-tag">table</span>,<span class="selector-tag">tr</span>,<span class="selector-class">.bodytext</span>,<span class="selector-class">.stepfield</span></span><br><span class="line">&#123;     <span class="attribute">font-size</span>: <span class="number">12pt</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/38770934/how-to-export-to-pdf-a-confluence-page-within-a-script">https://stackoverflow.com/questions/38770934/how-to-export-to-pdf-a-confluence-page-within-a-script</a></li>
<li><a href="https://www.cnblogs.com/xioawu-blog/p/12017973.html">https://www.cnblogs.com/xioawu-blog/p/12017973.html</a></li>
<li><a href="https://atlassian-python-api.readthedocs.io/">https://atlassian-python-api.readthedocs.io/</a></li>
<li><a href="https://pythonhosted.org/PyPDF2/">https://pythonhosted.org/PyPDF2/</a></li>
<li><a href="https://confluence.atlassian.com/conf713/customize-exports-to-pdf-1077913092.html">https://confluence.atlassian.com/conf713/customize-exports-to-pdf-1077913092.html</a></li>
<li><a href="https://confluence.atlassian.com/confkb/how-do-i-change-the-font-sizes-in-pdf-export-833938097.html">https://confluence.atlassian.com/confkb/how-do-i-change-the-font-sizes-in-pdf-export-833938097.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>samba服务的搭建与管理</title>
    <url>/2021/11/samba/</url>
    <content><![CDATA[<p><code>Smaba</code>是一个局域网文件共享服务，主要功能是在Linux和Windows之间共享文件。samba使用起来非常的方便，可以用Windows的文件管理器直接打开Samba共享的文件。本文主要介绍了Samba服务的搭建与管理，以及Windows管理Samba连接。</p>
<span id="more"></span>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<p>直接使用包管理器安装即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ubuntu</span></span><br><span class="line">apt-get install samba</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CentOS</span></span><br><span class="line">yum install samba</span><br></pre></td></tr></table></figure>
<h2 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h2>
<p>Samba的配置文件是<code>/etc/samba/smb.conf</code>，配置文件由若干个<code>section</code>组成，每个<code>section</code>包含若干个参数。<code>section</code>开头由<code>section name</code>和方括号构成，例如<code>[section name]</code>。参数类似于<code>name = value</code>。有关配置文件的更多介绍，可以参考<a href="https://www.samba.org/samba/docs/current/man-html/smb.conf.5.html">smb.conf.5</a>。下面列出了主要<code>section</code>及其参数。</p>
<p>除了<code>[global]</code>，每个section都是一个共享资源，共享资源的名字是<code>section</code>的名字。<code>[homes]</code>和<code>[printers]</code>是两个特殊的共享资源，分别用于共享家目录和打印机。</p>
<h3 id="global"><a class="header-anchor" href="#global">¶</a>global</h3>
<p>global section中的参数适用于整个服务，或者是某些未定义参数的默认值。</p>
<h3 id="homes"><a class="header-anchor" href="#homes">¶</a>homes</h3>
<p>共享名会被更改为用户名。如果<code>path</code>参数没有指定，则<code>path</code>默认指向登录用户的家目录。这是为用户共享家目录最快最简单的方法。如果在<code>homes</code>中指定了访客访问权限，则所有主目录都将对所有客户端可见，而无需密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Un-comment the following (and tweak the other settings below to suit)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to <span class="built_in">enable</span> the default home directory shares. This will share each</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user<span class="string">&#x27;s home directory as \\server\username</span></span></span><br><span class="line">[homes]</span><br><span class="line">   comment = Home Directories</span><br><span class="line">   browseable = yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">By default, the home directories are exported read-only. Change the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">next parameter to &#x27;</span>no<span class="string">&#x27; if you want to be able to write to them.</span></span></span><br><span class="line">   read only = no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">File creation mask is set to 0700 for security reasons. If you want to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">create files with group=rw permissions, set next parameter to 0775.</span></span></span><br><span class="line">   create mask = 0600</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Directory creation mask is set to 0700 for security reasons. If you want to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">create dirs. with group=rw permissions, set next parameter to 0775.</span></span></span><br><span class="line">   directory mask = 0700</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">By default, \\server\username shares can be connected to by anyone</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">with access to the samba server.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Un-comment the following parameter to make sure that only &quot;username&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">can connect to \\server\username</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This might need tweaking when using external authentication schemes</span></span></span><br><span class="line">   valid users = %S</span><br></pre></td></tr></table></figure>
<h3 id="printers"><a class="header-anchor" href="#printers">¶</a>printers</h3>
<p><strong>TODO</strong></p>
<h3 id="自定义section"><a class="header-anchor" href="#自定义section">¶</a>自定义section</h3>
<p>可按如下模板新增一个共享文件夹。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[share name]</span><br><span class="line">    comment = 任意注释字符串</span><br><span class="line">    path = /path/to/share</span><br><span class="line">    write list = user1[,user2]</span><br><span class="line">    force group  = group</span><br><span class="line">    force user = user</span><br><span class="line">    create mask = 0664</span><br><span class="line">    valid users = user1[,user2]</span><br><span class="line">    browseable = yes</span><br><span class="line">    read only = No</span><br></pre></td></tr></table></figure>
<h2 id="用户管理"><a class="header-anchor" href="#用户管理">¶</a>用户管理</h2>
<p>可以使用<code>smbpasswd</code>命令管理samba的用户。如果没有打开访客访问，则必须要登录用户才能访问samba服务。常用的选项如下：</p>
<ul>
<li>-a 添加用户。如果不指定用户名，则使用当前登录用户。</li>
<li>-d 关闭用户</li>
<li>-e 使能用户</li>
<li>-x 删除用户</li>
</ul>
<p>命令<code>pdbedit</code>提供了更多管理用户的选项。</p>
<ul>
<li>-L 列出所有的用户</li>
</ul>
<h2 id="服务管理"><a class="header-anchor" href="#服务管理">¶</a>服务管理</h2>
<p>更改配置文件之后，需要重启服务配置才能生效。samba的服务名是<code>smbd</code>，可以用service或systemctl来重启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service smbd restart</span><br><span class="line">systemctl restart smbd</span><br></pre></td></tr></table></figure>
<p>开机自启动samba服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable smbd</span><br></pre></td></tr></table></figure>
<p>samba服务正常运行后，可以使用指令<code>smbstatus</code>查看samba服务的状态，主要包含客户端的连接信息。</p>
<h2 id="Windows管理Samba"><a class="header-anchor" href="#Windows管理Samba">¶</a>Windows管理Samba</h2>
<h3 id="访问Samba"><a class="header-anchor" href="#访问Samba">¶</a>访问Samba</h3>
<p>在Windows文件管理器的地址栏输入<code>\\ip</code>即可访问Samba服务。</p>
<h3 id="管理Samba连接"><a class="header-anchor" href="#管理Samba连接">¶</a>管理Samba连接</h3>
<p>在<code>cmd</code>输入指令<code>net use</code>可以查看当前已建立连接的Samba，需要重点管理<code>远程</code>一列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\admin&gt;net use</span><br><span class="line">会记录新的网络连接。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">状态       本地        远程                      网络</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">OK           W:        \\192.168.50.1\share      Microsoft Windows Network</span><br><span class="line">命令成功完成。</span><br></pre></td></tr></table></figure>
<p>如果想断开某个连接，可以使用<code>net use [远程] /del</code>命令，例如<code>net use \\192.168.50.1\share /del</code>。命令<code>net use * /del</code>删除所有的Samba连接。</p>
<h3 id="Smaba凭据"><a class="header-anchor" href="#Smaba凭据">¶</a>Smaba凭据</h3>
<p>进入<code>控制面板-&gt;用户账户-&gt;管理Windows凭据</code>，则可以看到登录Samba服务所使用的用户名。如果想使用其他用户登录Samba服务，删除凭据后重启访问即可，这时会要求重新输入用户名和密码。</p>
<img src="https://image.pkemb.com/image/20211114231342.png"/>
<img src="https://image.pkemb.com/image/20211114231519.png"/>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ul>
<li><a href="https://www.samba.org/">https://www.samba.org/</a></li>
<li><a href="https://wiki.samba.org/index.php/Main_Page">https://wiki.samba.org/index.php/Main_Page</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Samba">https://zh.wikipedia.org/wiki/Samba</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>sshkey助手</title>
    <url>/2021/12/sshkey_helper/</url>
    <content><![CDATA[<p><code>sshkey_helper.sh</code>：生成<code>ssh key</code>、配置<code>~/.ssh/config</code>、部署<code>key</code>到服务器的小助手，方便快捷。</p>
<span id="more"></span>
<h2 id="ssh-config文件"><a class="header-anchor" href="#ssh-config文件">¶</a>~/.ssh/config文件</h2>
<ul>
<li>参考：<a href="https://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/">Simplify Your Life With an SSH Config File</a></li>
<li>中文：<a href="https://www.cnblogs.com/xjshi/p/9146296.html">.ssh/config 文件的解释算法及配置原则</a></li>
</ul>
<p>简单来说，可以通过<code>~/.ssh/config</code>文件为不同的主机指定不同的<code>key</code>。</p>
<h2 id="设置SSH-Public-Key"><a class="header-anchor" href="#设置SSH-Public-Key">¶</a>设置SSH Public Key</h2>
<p>添加一个<code>SSH Public Key</code>大致可以分为3步：</p>
<ol>
<li>生成一个新的SSH Key</li>
<li>配置<code>~/.ssh/config</code>文件</li>
<li>复制<code>SSH Public Key</code>
<ol>
<li>如果是可登录服务器，粘贴到<code>~/.ssh/authorized_keys</code>文件</li>
<li>如果是不可登录服务器，例如github、gitee等，粘贴到账户设置</li>
</ol>
</li>
</ol>
<p><a href="https://github.com/pkemb/tools/blob/master/shell/sshkey_helper.sh">sshkey_helper.sh</a>整合了以上三个步骤，只需一条命令即可完成三个步骤。当然了，如果是github，还是需要手动复制Key。使用方法如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pk@localhost:$ ./sshkey_helper.sh -h</span><br><span class="line">usage:</span><br><span class="line">    ./sshkey_helper.sh [-h] [-p] user@host[:port]</span><br><span class="line"></span><br><span class="line">    generate ssh key and deploy to host.</span><br><span class="line">    If no port is specified, use port 22.</span><br><span class="line">    key file path: ~/.ssh/id_rsa_&lt;user&gt;_&lt;host&gt;</span><br><span class="line"></span><br><span class="line">-p  don&#x27;t deploy public key, just print it</span><br><span class="line">-h  print this message</span><br></pre></td></tr></table></figure>
<h2 id="命名规则"><a class="header-anchor" href="#命名规则">¶</a>命名规则</h2>
<ul>
<li>key文件：<code>~/.ssh/id_rsa_[hostname]_[USER]_[HOST]</code></li>
<li>key的注释：<code>sshkey_helper_[hostname]_[USER]_[HOST]</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Aria2和AriaNg安装配置教程</title>
    <url>/2022/02/Aria2-and-AriaNg/</url>
    <content><![CDATA[<p><code>Aria2</code>是一个轻量级的命令行下载程序，支持多种协议和多种源。它支持<code>HTTP/HTTPS</code>，<code>FTP</code>，<code>SFTP</code>，<code>BitTorrent</code>和<code>Metalink</code>。Aria2可以通过内置的<code>JSON-RPC</code>和<code>XML-RPC</code>接口进行操作。</p>
<p>AriaNg 是一个让 aria2 更容易使用的现代 Web 前端。AriaNg 使用纯 html &amp; javascript 开发, 所以其不需要任何编译器或运行环境. 您只要将 AriaNg 放在您的 Web 服务器里并在浏览器中打开即可使用。AriaNg 使用响应式布局, 支持各种计算机或移动设备。</p>
<span id="more"></span>
<h2 id="安装Aria2"><a class="header-anchor" href="#安装Aria2">¶</a>安装Aria2</h2>
<p>可以借助脚本<a href="https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/aria2.sh">aria2.sh</a>来安装与管理Aria2。下面是脚本的使用界面，只需输入相应的数字即可完成对应的操作。成功安装后，服务会自动启动，并且打印出服务密码。如果忘记了服务密码，可以通过命令<code>8</code>查看。Aria2默认使用6800端口，如果服务器开启了防火墙，记得打开6800端口。</p>
<p>脚本会从<code>github.com</code>和<code>raw.githubusercontent.com</code>下载安装包和配置文件。如果下载失败，可以在<a href="https://ipaddress.com/">ipaddress.com</a>查询域名对应的IP地址，然后填写到<code>hosts</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Aria2 一键安装管理脚本 [v1.1.10]</span><br><span class="line">  -- Toyo | doub.io/shell-jc4 --</span><br><span class="line"></span><br><span class="line">  1. 升级脚本</span><br><span class="line">————————————</span><br><span class="line">  1. 安装 Aria2</span><br><span class="line">  2. 更新 Aria2</span><br><span class="line">  3. 卸载 Aria2</span><br><span class="line">————————————</span><br><span class="line">  4. 启动 Aria2</span><br><span class="line">  5. 停止 Aria2</span><br><span class="line">  6. 重启 Aria2</span><br><span class="line">————————————</span><br><span class="line">  7. 修改 配置文件</span><br><span class="line">  8. 查看 配置信息</span><br><span class="line">  9. 查看 日志信息</span><br><span class="line"> 10. 配置 自动更新 BT-Tracker服务器</span><br><span class="line">————————————</span><br><span class="line"></span><br><span class="line"> 当前状态: 已安装 并 已启动</span><br><span class="line"></span><br><span class="line"> 请输入数字 [0-10]:</span><br></pre></td></tr></table></figure>
<h2 id="安装AriaNg"><a class="header-anchor" href="#安装AriaNg">¶</a>安装AriaNg</h2>
<p>AriaNg是一个Web前端，所以首先需要新建一个网站。这里借助宝塔来完成，新建一个静态网站即可。</p>
<p>从<a href="https://github.com/mayswind/AriaNg/releases">AriaNg release页面</a>下载最新的软件包，上传到网站的根目录并解压。记得更改文件的权限，使得Nginx或Apache服务有权限访问。如果是使用宝塔，将文件的所有者改为<code>www</code>，所属组改为<code>www</code>即可。</p>
<p>在浏览器输入网站的域名访问AriaNg网站。点击左侧的<code>AriaNa设置</code>，选择<code>RPC</code>标签，填写Aria2服务的信息。如果信息填写正确且Aria2服务已经启动（记得打开6800端口），则<code>Aria2 状态</code>会变为已连接。AriaNg可以同时添加多个Aria2服务。</p>
<p><img src="https://image.pkemb.com/image/202202232048564.png" alt=""></p>
<h2 id="Aria2设置"><a class="header-anchor" href="#Aria2设置">¶</a>Aria2设置</h2>
<p>点击左侧的<code>Aria2设置</code>，可以对Aria2的下载参数进行设置。记得更改下载路径，指向一个有较大空间的挂载点。</p>
<p><img src="https://image.pkemb.com/image/202202232102137.png" alt=""></p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li>Aria2网站：<a href="https://aria2.github.io/">https://aria2.github.io/</a></li>
<li>Aria2源码：<a href="https://github.com/aria2/aria2">https://github.com/aria2/aria2</a></li>
<li>AriaNg网站：<a href="http://ariang.mayswind.net/zh_Hans/">http://ariang.mayswind.net/zh_Hans/</a></li>
<li>AriaNg源码：<a href="https://github.com/mayswind/AriaNg">https://github.com/mayswind/AriaNg</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/02/reqular-expressions/</url>
    <content><![CDATA[<p>正则表达式是经过专门编写的文本字符串，用来匹配字符串集合中符合该模式的所有字符串。</p>
<span id="more"></span>
<h2 id="元字符"><a class="header-anchor" href="#元字符">¶</a>元字符</h2>
<p>在正则表达式中，<code>元字符</code>有特殊的含义。正则表达式的元字符如下。如果需要匹配元字符，需要通过<code>\</code>转义。或者将元字符放在<code>\Q</code>和<code>\E</code>的中间，例如<code>\Q^$\E</code>匹配字符串<code>^$</code>。</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>句点</td>
<td>匹配任意字符</td>
</tr>
<tr>
<td>^</td>
<td>脱字符</td>
<td>行起始锚位符</td>
</tr>
<tr>
<td>$</td>
<td>美元符</td>
<td>行结束锚位符</td>
</tr>
<tr>
<td>*</td>
<td>星号</td>
<td>匹配零次或多次的量词</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
<td>匹配一次或多次的量词</td>
</tr>
<tr>
<td>?</td>
<td>问号</td>
<td>匹配零次或一次的量词</td>
</tr>
<tr>
<td>|</td>
<td>竖线符</td>
<td>选择操作（或）</td>
</tr>
<tr>
<td>(</td>
<td>左括号</td>
<td>分组起始</td>
</tr>
<tr>
<td>)</td>
<td>右括号</td>
<td>分组结束</td>
</tr>
<tr>
<td>{</td>
<td>左花括号</td>
<td>量词或代码块起始</td>
</tr>
<tr>
<td>}</td>
<td>右花括号</td>
<td>量词或代码块结束</td>
</tr>
<tr>
<td>[</td>
<td>左方括号</td>
<td>字符组起始</td>
</tr>
<tr>
<td>]</td>
<td>右方括号</td>
<td>字符组结束</td>
</tr>
<tr>
<td>\</td>
<td>反斜线</td>
<td>对字符转义</td>
</tr>
</tbody>
</table>
<h2 id="字符组"><a class="header-anchor" href="#字符组">¶</a>字符组</h2>
<p>关键点：</p>
<ul>
<li><code>[]</code>表示字符组</li>
<li>字符中间的<code>-</code>表示范围
<ul>
<li>注意<code>[0-9]</code>和<code>[-09]</code>的区别</li>
</ul>
</li>
<li>开头的<code>^</code>表示取反</li>
<li>字符组一定会消耗一个字符</li>
<li>字符组内部的元字符与字符组外部的元字符完全不一样
<ul>
<li>开头的<code>-</code>和字符中间的<code>-</code>有特殊含义，其余字符均匹配自身</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[12]</td>
<td>匹配字符1或2。</td>
</tr>
<tr>
<td>[^12]</td>
<td>不匹配字符1和2</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配数字字符</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配小写字母</td>
</tr>
</tbody>
</table>
<p><strong>常用字符组缩写</strong></p>
<table>
<thead>
<tr>
<th>字符组缩写</th>
<th>字符组</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>[0-9]</td>
<td>数字字符</td>
</tr>
<tr>
<td>\D</td>
<td>[^0-9]</td>
<td>非数字字符</td>
</tr>
<tr>
<td>\s</td>
<td>[ \t\n\r]</td>
<td>空白符</td>
</tr>
<tr>
<td>\S</td>
<td>[^ \t\n\r]</td>
<td>非空白符</td>
</tr>
<tr>
<td>\w</td>
<td>[_a-zA-Z0-9]</td>
<td>单词字符</td>
</tr>
<tr>
<td>\W</td>
<td>[^_a-zA-Z0-9]</td>
<td>非单词字符</td>
</tr>
<tr>
<td>.</td>
<td>[^\n\r]</td>
<td>除行结束符之外的所有字符</td>
</tr>
</tbody>
</table>
<p><strong>POSIX字符组</strong></p>
<table>
<thead>
<tr>
<th>字符组</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[[:alnum:]]</code></td>
<td>匹配字母及数字</td>
</tr>
<tr>
<td><code>[[:alpha:]]</code></td>
<td>匹配字母</td>
</tr>
<tr>
<td><code>[[:ascii:]]</code></td>
<td>匹配ASCII 字符（共128 个）</td>
</tr>
<tr>
<td><code>[[:blank:]]</code></td>
<td>匹配空白字符</td>
</tr>
<tr>
<td><code>[[:ctrl:]]</code></td>
<td>匹配控制字符</td>
</tr>
<tr>
<td><code>[[:digit:]]</code></td>
<td>匹配数字</td>
</tr>
<tr>
<td><code>[[:graph:]]</code></td>
<td>匹配图形字符</td>
</tr>
<tr>
<td><code>[[:lower:]]</code></td>
<td>匹配小写字母</td>
</tr>
<tr>
<td><code>[[:print:]]</code></td>
<td>匹配可打印字符</td>
</tr>
<tr>
<td><code>[[:punct:]]</code></td>
<td>匹配标点符号</td>
</tr>
<tr>
<td><code>[[:space:]]</code></td>
<td>匹配空格字符</td>
</tr>
<tr>
<td><code>[[:upper:]]</code></td>
<td>匹配大写字母</td>
</tr>
<tr>
<td><code>[[:word:]]</code></td>
<td>匹配单词字符</td>
</tr>
<tr>
<td><code>[[:xdigit:]]</code></td>
<td>匹配十六进制数字</td>
</tr>
</tbody>
</table>
<h2 id="捕获分组与后向引用"><a class="header-anchor" href="#捕获分组与后向引用">¶</a>捕获分组与后向引用</h2>
<p>使用<code>()</code>对正则表达式匹配的字符进行分组，分组不会改变正则表达式的匹配。使用<code>\1</code>或<code>$1</code>对分组进行引用。<code>\1</code>表示第一个开括号<code>(</code>的分组，<code>\2</code>表示第二个开括号的分组。</p>
<p>例如正则表达式<code>(\d)\d\1</code>匹配字符串<code>575</code>。第一个<code>\d</code>匹配字符<code>5</code>并加入分组，<code>\1</code>对分组进行引用。</p>
<p><code>(?:)</code>表示分组但是不引用，这会提高正则表达式的性能。</p>
<h2 id="量词"><a class="header-anchor" href="#量词">¶</a>量词</h2>
<p>例如正则表达式：<code>a?</code>。量词<code>?</code>修饰前面的<code>a</code>，表示字符<code>a</code>出现0次或1次。量词也可以用<code>&#123;min,max&#125;</code>表达。</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>0或1次，{0,1}</td>
</tr>
<tr>
<td>+</td>
<td>1或无穷次，{1,}</td>
</tr>
<tr>
<td>*</td>
<td>0或无穷次，{0,}</td>
</tr>
<tr>
<td>{n}</td>
<td>n次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>最少n次，最多m次</td>
</tr>
<tr>
<td>{n,}</td>
<td>最少n次</td>
</tr>
</tbody>
</table>
<p>量词默认使用<code>贪心</code>原则，即尽可能匹配更多的内容。量词首先尝试匹配整个字符串，如果失败则回退一个字符后再次尝试。</p>
<p><code>懒惰</code>是另一种策略，它从目标的起始位置开始尝试寻找匹配，每次检查字符串的一个字符，寻找它要匹配的内容。最后，它会尝试匹配整个字符串。要使用懒惰量词，需要在普通量词后添加<code>?</code>。</p>
<p>占有量词会覆盖整个目标然后尝试寻找匹配内容，但只尝试一次，不会回溯。需要在普通量词后添加<code>+</code>。</p>
<h2 id="选择"><a class="header-anchor" href="#选择">¶</a>选择</h2>
<p>竖线符<code>|</code>表示选择，从多个表达式中选择一个匹配。例如<code>a|ab</code>表示匹配字符<code>a</code>或字符串<code>ab</code>。注意选择和字符数组的区别，字符数组一次只能匹配一个字符，选择根据情况可以匹配多个字符。</p>
<p>可以借助分组，为选择确定一个明确的边界。例如表达式<code>a|bcd</code>和<code>(a|bc)d</code>的区别。</p>
<h2 id="锚位符"><a class="header-anchor" href="#锚位符">¶</a>锚位符</h2>
<p>锚位符用来匹配位置，不消耗任何字符。</p>
<table>
<thead>
<tr>
<th>锚位符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>行起始位置</td>
</tr>
<tr>
<td>$</td>
<td>行结束位置</td>
</tr>
<tr>
<td>\b</td>
<td>单词边界</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界</td>
</tr>
<tr>
<td><code>\&lt;</code></td>
<td>单词开头。旧语法，可能不支持</td>
</tr>
<tr>
<td><code>\&gt;</code></td>
<td>单词结尾。旧语法，可能不支持</td>
</tr>
<tr>
<td>\A</td>
<td>主题词的开始</td>
</tr>
<tr>
<td>\Z</td>
<td>主题词的结尾</td>
</tr>
</tbody>
</table>
<h2 id="环视"><a class="header-anchor" href="#环视">¶</a>环视</h2>
<p>环视是一种非捕获分组，根据某个模式之前或之后的内容匹配其他模式。环视不匹配任何字符，只匹配文本中的<code>特定位置</code>。环视不会占用字符。</p>
<table>
<thead>
<tr>
<th>环视</th>
<th>正则表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>肯定顺序环视</td>
<td>(?=…)</td>
<td>子表达式<code>能</code>够匹配<code>右侧</code>文本</td>
</tr>
<tr>
<td>否定顺序环视</td>
<td>(?!..)</td>
<td>子表达式<code>不能</code>匹配<code>右侧</code>文本</td>
</tr>
<tr>
<td>肯定逆序环视</td>
<td>(?&lt;=…)</td>
<td>子表达式<code>能</code>够匹配<code>左侧</code>文本</td>
</tr>
<tr>
<td>否定逆序环视</td>
<td>(?&lt;!..)</td>
<td>子表达式<code>不能</code>够匹配<code>左侧</code>文本</td>
</tr>
</tbody>
</table>
<p>考虑字符串<code>see Jeffs book</code>，正则表达式<code>(?=s\b)</code>匹配<code>f</code>和<code>s</code>中间的位置，因为这个位置右侧包含字符串<code>s\b</code>。</p>
<p>考虑任意一个位置，如果对右边的字符有要求，可以使用肯定顺序环视（枚举）或否定逆序环视（排除）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(?=s\b)   # 只能匹配 f 和 s 中间的位置</span><br><span class="line">(?&lt;!s\b)  # 空格和 b 中间的位置不能匹配，其余位置均可以匹配。f 和 s 中间的位置也能匹配。</span><br></pre></td></tr></table></figure>
<p>如果对左边的字符有要求，可以使用肯定逆序环视（枚举）或否定顺序环视（排除）。</p>
<h2 id="学习资料"><a class="header-anchor" href="#学习资料">¶</a>学习资料</h2>
<ul>
<li>学习正则表达式，Michael Fitzgerald
<ul>
<li><a href="https://book.douban.com/subject/22601258/">https://book.douban.com/subject/22601258/</a></li>
<li>内容比较简单，适合零基础入门</li>
</ul>
</li>
<li>精通正则表达式(第三版)，Jeffrey E.F.Friedl
<ul>
<li><a href="https://book.douban.com/subject/11589967/">https://book.douban.com/subject/11589967/</a></li>
<li>内容比较深入，适合进阶学习</li>
</ul>
</li>
<li><a href="https://share.pkemb.com/books/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">电子版PDF</a></li>
</ul>
<h2 id="Python使用正则表达式"><a class="header-anchor" href="#Python使用正则表达式">¶</a>Python使用正则表达式</h2>
<p>参考：<a href="https://docs.python.org/zh-cn/3/library/re.html">https://docs.python.org/zh-cn/3/library/re.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">reg_expre = re.<span class="built_in">compile</span>(<span class="string">&#x27;(?P&lt;key1&gt;\d&#123;3&#125;)-?(?P&lt;key2&gt;\d&#123;4&#125;)&#x27;</span>)</span><br><span class="line">m = reg_expre.<span class="keyword">match</span>(<span class="string">&quot;123-4567&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> m:</span><br><span class="line">    <span class="built_in">print</span>(m.groupdict())    <span class="comment"># (&#x27;123&#x27;, &#x27;4567&#x27;)</span></span><br><span class="line">    <span class="built_in">print</span>(m.groups())       <span class="comment"># &#123;&#x27;key1&#x27;: &#x27;123&#x27;, &#x27;key2&#x27;: &#x27;4567&#x27;&#125;</span></span><br><span class="line">    <span class="built_in">print</span>(m.group(<span class="number">1</span>))       <span class="comment"># &#x27;123&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(m.group(<span class="string">&#x27;key2&#x27;</span>))  <span class="comment"># &#x27;4567&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>使用全志H6 Android9.0 SDK启动OrangePi 3 LTS</title>
    <url>/2022/03/boot-orangepi3lts-from-h6-android9.0-sdk/</url>
    <content><![CDATA[<p><code>Orange Pi</code>提供了芯片厂商释放的原始<code>H6 Android9.0 SDK</code>，但没有提供<code>Orange Pi3 LTS</code>的适配代码，所以原始SDK编译出来的镜像不能在<code>Orange Pi3 LTS</code>上正常启动。本文来教你如何突破这一限制。</p>
<span id="more"></span>
<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2>
<p>前段时间决定学习Android系统，这就肯定需要一块开发板么，纸上谈兵是不行的。经过一番搜索，要么适配的Android系统版本太低（5或6），要么价格太贵了。经过艰苦的搜索，发现了<code>Orange Pi3 LST</code>这么一款开发板，适配Android9.0，官方店铺价格<code>￥229</code>加8元运费，价格亲民，<s>吃灰也不心疼</s>。马上下单！</p>
<p><a href="http://www.orangepi.cn/downloadresourcescn/">Orange Pi官网</a>提供了相关资料的百度云下载地址，在经历几天几夜的挂机下载后，终于将需要的文件都下载下来了。打开用户手册<code>OrangePi_3_LTS_H6_用户手册_v1.8.pdf</code>，通读一遍。在接近结束的时候，发现了下面一段话。真的是吐血的心都有了，只提供芯片原厂释放的原始SDK！！！不提供适配代码！！！</p>
<p><img src="https://image.pkemb.com/image/202203212150948.png" alt=""></p>
<p>不撞南墙不回头，按照用户手册的指导搭建好编译环境，经过一个下午的漫长等待，终于编译好了原始Android SDK。烧录到TF卡，上电，直接GG，SDRAM初始化失败。想到只有一个编译好的Android img，不能自己编译，万一耽误以后学习咋办，这个问题还是要尝试解决的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[218]HELLO! BOOT0 is starting!</span><br><span class="line">[222]boot0 commit : de6e50bf43bb48975c66a88b58eef6a7460bf0ef</span><br><span class="line"></span><br><span class="line">[241]set pll start</span><br><span class="line">[244]set pll end</span><br><span class="line">......</span><br><span class="line">[585]MP_PGSR0 IS = 0040005d</span><br><span class="line">[588]BYTE0 GATE ERRO IS = 00000003</span><br><span class="line">[591]BYTE1 GATE ERRO IS = 00000003</span><br><span class="line">[595]BYTE2 GATE ERRO IS = 00000003</span><br><span class="line">[598]BYTE3 GATE ERRO IS = 00000003</span><br><span class="line">[602]scan dram rank&amp;width fail !</span><br><span class="line">[605]initializing SDRAM Fail.</span><br></pre></td></tr></table></figure>
<h2 id="准备"><a class="header-anchor" href="#准备">¶</a>准备</h2>
<p>在解决开机失败问题之前，一定要对开机流程有一个大致的了解。经过简单的百度，发现了一篇博客：<a href="https://blog.csdn.net/wlwl0071986/article/details/47207809">全志平台linux启动流程分析</a>。简单总结一下，就是<code>Boot ROM</code> -&gt; <code>Boot0</code> -&gt; <code>Boot1</code> -&gt; <code>U-Boot</code> &gt; <code>kernel</code>。从正常的开机log看，基本就是这个流程。所以，原始Android SDK在<code>Boot0</code>就启动失败了，问题点定位到了。</p>
<p>同时，还需要拿到全志H6的芯片资料，这个可以在<a href="https://linux-sunxi.org/H6">linux-sunxi.org/H6</a>获取，这里有数据手册、用户手册、原始SDK。</p>
<h2 id="初步分析"><a class="header-anchor" href="#初步分析">¶</a>初步分析</h2>
<p>Android相关的代码，<code>OrangePi</code>提供了两个压缩包，<code>android.tar.gz</code>和<code>lichee.tar.gz</code>，boot0相关的内容应该是在<code>lichee.tar.gz</code>。经过一番搜索，发现了<code>brandy/basic_loader/boot0</code>目录，这里存储了<code>boot0</code>相关的代码。但是，没有H6的<code>boot0</code>！！！H6是A53内核，有make_a50、make_a67，就是没有make_a53。用grep搜索H6的芯片代码<code>sun50iw6p1</code>，也没有找到任何内容。</p>
<p>通过以上分析，可以得出结论，<code>OrangePi</code>没有提供Android系统的boot0源代码，而是使用了预编译文件。</p>
<p>另一边，按照用户手册的指导，为<code>OrangePi3 LTS</code>编译Linux系统，烧录到TF卡之后可以正常启动。也就是说，<code>OrangePi</code>为Linux系统提供了一份可以正常启动的boot0。经过一番搜索，在<code>orangepi-build/u-boot/v2014.07-sun50iw6-linux4.9/sunxi_spl/boot0</code>发现了boot0的源代码和编译好的<code>boot0_sdcard.bin</code>。</p>
<h2 id="找出预编译的boot0"><a class="header-anchor" href="#找出预编译的boot0">¶</a>找出预编译的boot0</h2>
<p>前面分析到，Android系统的boot0不是编译出来的，而是使用的预编译文件。关键点要找到这个文件。以下是官方用户手册给出的Android系统编译命令。显然，最后一步的pack命令用来收集所有编译好的文件，打包成img文件。所以要分析pack命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test@test:~$ cd android</span><br><span class="line">test@test:~/android$ source build/envsetup.sh</span><br><span class="line">test@test:~/android$ lunch petrel_fvd_p1-eng</span><br><span class="line">test@test:~/android$ extract-bsp</span><br><span class="line">test@test:~/android$ make -j8</span><br><span class="line">test@test:~/android$ pack</span><br></pre></td></tr></table></figure>
<p><code>pack</code>命令是<code>source build/envsetup.sh</code>注册的一个shell函数，可以用命令<code>type pack</code>看到源码。经过追踪，pack命令最终会调用<code>lichee/tools/pack/pack</code>脚本。经过分析pack脚本，在函数<code>do_finish()</code>中，会调用命令<code>dragon image.cfg  sys_partition.fex</code>来打包、生成最终的img文件。image.cfg，看文件名就知道是最终img文件的配置文件。经过find搜索，image.cfg在l<code>ichee/tools/pack/out/image.cfg</code>。打开这个文件，发现如下内容，刚好out目录下面有一个boot0_sdcard.fex文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;filename = &quot;boot0_nand.fex&quot;,   maintype = ITEM_BOOT,         subtype = &quot;BOOT0_0000000000&quot;,&#125;,</span><br><span class="line">&#123;filename = &quot;boot0_sdcard.fex&quot;, maintype = &quot;12345678&quot;,        subtype = &quot;1234567890BOOT_0&quot;,&#125;,</span><br></pre></td></tr></table></figure>
<p><code>lichee</code>目录是<code>lichee.tar.gz</code>解压出来的，这个压缩包里面没有<code>tools/pack/out</code>目录，说明out目录是编译时某个命令产生的。用grep搜索<code>boot0_sdcard.fex</code>，找到如下关键内容。所以关键点还是在pack脚本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pack/pack:171:$&#123;RES_DIR&#125;/$&#123;LICHEE_BIN_PATH&#125;/boot0_sdcard_$&#123;PACK_CHIP&#125;.bin:out/boot0_sdcard.fex</span><br><span class="line">pack/pack:311:          mv out/boot0_sdcard-$&#123;OTA_TEST_NAME&#125;.fex        out/boot0_sdcard.fex</span><br><span class="line">pack/pack:517:        programmer_img boot0_sdcard.fex boot_package.fex $&#123;out_img&#125; &gt; /dev/null</span><br><span class="line">pack/pack:710:  update_boot0 boot0_sdcard.fex   sys_config.bin SDMMC_CARD &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>进入脚本一顿搜索分析，找到如下关键信息。<code>boot0_sdcard.fex</code>来源于<code>$&#123;RES_DIR&#125;/$&#123;LICHEE_BIN_PATH&#125;/boot0_sdcard_$&#123;PACK_CHIP&#125;.bin</code>，命令<code>update_boot0</code>可能会修改文件<code>boot0_sdcard.fex</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">boot_file_list=(</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;RES_DIR&#125;/<span class="variable">$&#123;LICHEE_BIN_PATH&#125;</span>/boot0_nand_<span class="variable">$&#123;PACK_CHIP&#125;</span>.bin:out/boot0_nand.fex</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;RES_DIR&#125;/<span class="variable">$&#123;LICHEE_BIN_PATH&#125;</span>/boot0_sdcard_<span class="variable">$&#123;PACK_CHIP&#125;</span>.bin:out/boot0_sdcard.fex</span></span><br><span class="line">......</span><br><span class="line">    printf &quot;copying boot file\n&quot;</span><br><span class="line">    for file in $&#123;boot_file_list[@]&#125; ; do</span><br><span class="line">        cp -f $(echo $file | sed -e &#x27;s/:/ /g&#x27;) 2&gt;/dev/null</span><br><span class="line">    done</span><br><span class="line">......</span><br><span class="line">    # Those files for Nand or Card</span><br><span class="line">    update_boot0 boot0_nand.fex sys_config.bin NAND &gt; /dev/null</span><br><span class="line">    update_boot0 boot0_sdcard.fex   sys_config.bin SDMMC_CARD &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>使用命令<code>find -name boot0_sdcard_*.bin</code>找到文件<code>./pack/chips/sun50iw6p1/bin/boot0_sdcard_sun50iw6p1.bin</code>（还有很多给其他IC用的，这里忽略了）。二进制对比文件<code>boot0_sdcard_sun50iw6p1.bin</code>和<code>boot0_sdcard.fex</code>，确实存在一些差异，确认了<code>update_boot0</code>确实会修改文件<code>boot0_sdcard.fex</code>。</p>
<h2 id="尝试1：Android使用Linux-boot0"><a class="header-anchor" href="#尝试1：Android使用Linux-boot0">¶</a>尝试1：Android使用Linux boot0</h2>
<p>前面提到，自己编译的Linux系统可以完美启动。我觉得在<code>boot loader</code>阶段，Android和Linux其实是没有什么区别的。所以尝试使用Linux boot0来启动Android。在boot0的main()函数加了几句log，用来确认是否编译进去。然后重新编译。</p>
<p>前面分析出来，Android系统的boot0存储在<code>lichee/tools/pack/chips/sun50iw6p1/bin/boot0_sdcard_sun50iw6p1.bin</code>。备份Android原始的boot0，复制Linux的boot0并重命名，最后重新执行pack命令生成新的img文件。</p>
<p>烧录新的img，上电启动。系统是起来了，但是boot0加的log没有出来。一番查看，原来是从EMMC启动了，也就是说跳过了TF卡中的系统。看来Linux编译出来的boot0，可能在Android系统无法通过某种校验，然后就从EMMC启动了。</p>
<p>综上，本次尝试失败，两个系统的boot0无法通用。</p>
<h2 id="尝试2：从官方Android-img提取boot0文件"><a class="header-anchor" href="#尝试2：从官方Android-img提取boot0文件">¶</a>尝试2：从官方Android img提取boot0文件</h2>
<p><code>OrangePi</code>有提供一个Android镜像文件，可以正常启动。既然img文件是由若干个文件打包而成，那么一定可以解包。但问题就在这，img文件是通过<code>dragon</code>命令打包的，<code>dragon</code>也只提供了编译好的二进制文件，没有提供源代码。所以无法从打包的方向获取img文件的内部结构。</p>
<p>使用file命令查看img文件，返回data，没有更多的信息。看来file命令也无法识别其具体的文件类型。</p>
<p>用二进制查看器打开img文件，发现文件头有一个魔法字符串<code>IMAGEWTY</code>，Google这个字符串，发现了如下两个非常有用的网址。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/48872746/what-is-an-imagewty-firmware-format">https://stackoverflow.com/questions/48872746/what-is-an-imagewty-firmware-format</a></li>
<li><a href="https://github.com/Ithamar/awutils">https://github.com/Ithamar/awutils</a></li>
</ul>
<p><img src="https://image.pkemb.com/image/202203212247584.png" alt=""></p>
<p><code>awutils</code>提供了一个叫做<code>awimage</code>的工具，可以用来解压img文件。clone到本地，编译成可执行文件，尝试解包，成了。解出来的文件如下图所示。但是解包之后这么多文件，哪一个才是<code>boot0_sdcard.fex</code>呢？<code>dragon</code>命令有一个参数是<code>image.cfg</code>，再去碰碰运气。在<code>boot0_sdcard.fex</code>那一行，可以看到<code>maintype=&quot;12345678&quot;</code>，<code>subtype=&quot;1234567890BOOT_0&quot;</code>。好巧，解包之后存在一个名为<code>12345678_1234567890BOOT_0</code>的文件，且文件的大小也可以对应上，就是它了。</p>
<p><img src="https://image.pkemb.com/image/202203212248062.png" alt=""></p>
<p>之前提到过，pack脚本将<code>boot0_sdcard_sun50iw6p1.bin</code>复制为<code>boot0_sdcard.fex</code>后，还用<code>update_boot0</code>命令修改了<code>boot0_sdcard.fex</code>，最终打包到img文件的是<code>update_boot0</code>修改之后的文件。所以提取出来的文件也是<code>update_boot0</code>修改之后的。故要在<code>dragon</code>命令打包的前一刻，将提取出来的文件替换到<code>boot0_sdcard.fex</code>。所以对pack脚本做了如下修改，打包之前复制<code>12345678_1234567890BOOT_0</code>替换到<code>boot0_sdcard.fex</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -f /path/to/OrangePi_3_LTS_Android9_v1.0.img.dump/12345678_1234567890BOOT_0  boot0_sdcard.fex</span><br><span class="line">dragon image.cfg    sys_partition.fex</span><br></pre></td></tr></table></figure>
<p>重新执行pack命令打包img文件，烧录，启动成功。虽然启动过程中还有一些error log，但最终还是顺利进入了系统。全志H6原始Android SDK桌面如下。</p>
<p><img src="https://image.pkemb.com/image/202203212313364.jpg" alt=""></p>
]]></content>
      <categories>
        <category>android</category>
        <category>orangepi3lts</category>
      </categories>
  </entry>
  <entry>
    <title>文档网站生成器——docsify</title>
    <url>/2022/03/docsify/</url>
    <content><![CDATA[<p><code>docsify</code> 可以快速生成文档网站，使用非常方便。并且支持部署到<code>Github Pages</code>。在这里记录一下<code>docsify</code>的常用设置，方便查询。</p>
<span id="more"></span>
<h2 id="安装方法"><a class="header-anchor" href="#安装方法">¶</a>安装方法</h2>
<p>安装及使用的方法可以参考<a href="https://docsify.js.org/#/zh-cn/">官方文档</a>，写的非常的详细。可以点击进入我的<a href="https://notes.pkemb.com/#/">读书笔记</a>，看看最终的效果。</p>
<h2 id="favicon"><a class="header-anchor" href="#favicon">¶</a>favicon</h2>
<p>修改<code>index.html</code>文件，在<code>head</code>标签中加入如下<code>link</code>标签。参考修改：<a href="https://github.com/pkemb/notes/commit/8c488ace6118fa76b1d10a29903a41121da355cd">8c488a</a>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/png&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;16x16&quot;</span> <span class="attr">href</span>=<span class="string">&quot;media/favicon-16x16-pk.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="title"><a class="header-anchor" href="#title">¶</a>title</h2>
<p>修改<code>index.html</code>文件，在<code>head</code>标签中加入如下<code>title</code>标签。<code>title</code>会显示在浏览器标签上。参考修改：<a href="https://github.com/pkemb/notes/commit/8c488ace6118fa76b1d10a29903a41121da355cd">8c488a</a>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>笔记<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="name"><a class="header-anchor" href="#name">¶</a>name</h2>
<p>修改<code>index.html</code>文件，在<code>window.$docsify</code>为<code>name</code>设置值。<code>name</code>会显示在侧边栏的顶端。参考修改：<a href="https://github.com/pkemb/notes/commit/8c488ace6118fa76b1d10a29903a41121da355cd">8c488a</a>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">window.$docsify = &#123;</span><br><span class="line">  name: &#x27;新一代熊孩子程序员&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复制到剪切板"><a class="header-anchor" href="#复制到剪切板">¶</a>复制到剪切板</h2>
<p>一键复制代码块中的代码。修改<code>index.html</code>文件，在<code>body</code>标志中加入如下插件。参考修改：<a href="https://github.com/pkemb/notes/commit/cb0d9407eb08e484fb90d1856c710b24baaea8c7">cb0d94</a>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="新页面自动到顶端"><a class="header-anchor" href="#新页面自动到顶端">¶</a>新页面自动到顶端</h2>
<p>打开新页面后自动到顶端。修改<code>index.html</code>文件，在<code>window.$docsify</code>设置<code>auto2top</code>为<code>true</code>。参考修改：<a href="https://github.com/pkemb/notes/commit/85ba10331a445bac229f0679cc8eb951eb362aac">85ba10</a>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">window.$docsify = &#123;</span><br><span class="line">  auto2top: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义sidebar和navbar"><a class="header-anchor" href="#自定义sidebar和navbar">¶</a>自定义sidebar和navbar</h2>
<ul>
<li>navbar，导航栏，显示在页面右上角。参考修改：<a href="https://github.com/pkemb/notes/commit/c79007834fcaaaacae023ceb6c707f743d186884">c79007</a></li>
<li>sidebar，侧边栏，显示在页面左边。参考修改：<a href="https://github.com/pkemb/notes/commit/ca58162da44d7af81ee000cfbf24ffe533f77a98">ca5816</a></li>
<li>定义别名，避免递归查找导致页面打开慢。参考修改：<a href="https://github.com/pkemb/notes/commit/25bf6f62a700ec884f23db0096f6557ceac99166">25bf6f</a></li>
<li>添加目录自动折叠，避免侧边栏太长。参考修改：<a href="https://github.com/pkemb/notes/commit/7f222350675696087bddab6cd46a93131806ebce">7f2223</a></li>
</ul>
<h2 id="scroll-to-top按钮"><a class="header-anchor" href="#scroll-to-top按钮">¶</a>scroll-to-top按钮</h2>
<p>参考修改：<a href="https://github.com/pkemb/notes/commit/bd83ea8c32a0d0b552e38585f0fef5316131db0a">bd83ea</a></p>
]]></content>
  </entry>
  <entry>
    <title>在 Git Bash 安装更多工具</title>
    <url>/2022/03/install-more-tools-in-git-bash/</url>
    <content><![CDATA[<p>众所周知，<code>Git Bash</code>是一款非常好用的Git客户端，并且集成了<code>Mingw</code>，自带了非常多的GNU工具。可以在一定程度上解决Windows系统运行shell命令和shell脚本的问题。但某些常用工具（例如<code>make</code>）没有集成，所以来看看如何为<code>Git Bash</code>扩展更多的工具。</p>
<span id="more"></span>
<p>由于<code>Git Bahs</code>没有软件包管理工具，所以只能手动下载相应工具的Windows版本，并放置在<code>Git Bash</code>的的安装目录中。具体的操作步骤如下：</p>
<ol>
<li>确定工具所在的软件包</li>
<li>下载软件包的Windows版本</li>
<li>放置到<code>Git Bash</code>的安装目录中</li>
</ol>
<h2 id="查询软件包"><a class="header-anchor" href="#查询软件包">¶</a>查询软件包</h2>
<p>可以用<code>apt-cache</code>或<code>rpm -qf</code>命令查询，也可以在搜索引擎搜索。</p>
<h2 id="下载软件包"><a class="header-anchor" href="#下载软件包">¶</a>下载软件包</h2>
<p>下面列出的网站有非常多Windows版本的GNU软件包，可以尝试在这上面找一找。如果找不到，也可以在搜索引擎找一找。也可以尝试直接从源码编译。</p>
<ul>
<li><a href="https://sourceforge.net/projects/ezwinports/files/">https://sourceforge.net/projects/ezwinports/files/</a></li>
<li><a href="http://gnuwin32.sourceforge.net/packages.html">http://gnuwin32.sourceforge.net/packages.html</a></li>
</ul>
<h2 id="安装软件包"><a class="header-anchor" href="#安装软件包">¶</a>安装软件包</h2>
<p>64位<code>Git Bash</code>默认安装在<code>C:\Program Files\Git</code>，所以将下载的软件包解压到<code>C:\Program Files\Git\mingw64</code>即可。</p>
<p>以<code>make</code>命令为例，从<a href="https://sourceforge.net/projects/ezwinports/files/">ezwinports</a>下载make的软件包<a href="https://nchc.dl.sourceforge.net/project/ezwinports/make-4.3-without-guile-w32-bin.zip">make-4.3-without-guile-w32-bin.zip</a>，双击打开，点击<code>解压到</code>，在弹出的窗口中输入目标文件夹，点击确定即可。</p>
<p><img src="https://image.pkemb.com/image/202203191621634.png" alt=""></p>
<p>最后打开<code>Git Bash</code>，验证命令是否安装成功。</p>
<p><img src="https://image.pkemb.com/image/202203191623769.png" alt=""></p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://gist.github.com/pkemb/559d7c6470269caf020c9199ca305316">How to add more to Git Bash on Windows</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Binder驱动源码阅读</title>
    <url>/2022/04/binder-driver/</url>
    <content><![CDATA[<p>Binder驱动是Binder IPC的基石，学习了解Binder驱动的实现，有助于深入理解Binder。以下基于<code>Orangepi3lts</code>提供的源代码，分析Binder驱动的实现。</p>
<span id="more"></span>
<h2 id="binder设备使用方法"><a class="header-anchor" href="#binder设备使用方法">¶</a>binder设备使用方法</h2>
<p>了解Binder的使用方法，对理解驱动的设计思路有帮助。Binder是一种进程间通信的方法，采用主从结构，客户端可以借助Binder驱动给服务端发送消息，或者接收服务端的消息。自然可以得到下图。</p>
<p><img src="https://image.pkemb.com/image/202204122043628.png" alt=""></p>
<p>但是有一个问题，客户端怎么知道服务端的<code>handle</code>？所以Android引入了一个叫做<code>ServiceManager</code>的进程，这是一个非常特殊的服务端，其<code>handle</code>为0，主要功能是注册和查询Service。所以上图就扩展演变成了下图。由于SM的<code>handle</code>为0，所以服务端可以通过SM注册成为一个Service，客户端可以通过SM查询Service的handle。当得到服务端的handle后，客户端就可以直接与服务端通信了。</p>
<p><img src="https://image.pkemb.com/image/202204122102626.png" alt=""></p>
<p>通过上面的分析，Binder有以下的使用场景：</p>
<ol>
<li>服务端注册</li>
<li>客服端查询</li>
<li>客户端向服务端发起通信</li>
</ol>
<p>当然，还需要知道如何打开Binder驱动。下面以<code>ServiceManager</code>为例，展示了一个进程如何初始化Binder驱动。初始化大致分为以下3步。ServiceManager比较特殊，需要调用命令<code>BINDER_SET_CONTEXT_MGR</code>，整个系统也只有<code>ServiceManager</code>需要调用这个命令。</p>
<ol>
<li>打开设备驱动节点</li>
<li>执行mmap映射内存</li>
<li>调用ioctl读写数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅保留了主要代码</span></span><br><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/service_manager.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="type">char</span> *driver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>); <span class="comment">// 打开Binder驱动</span></span><br><span class="line">    binder_become_context_manager(bs);  <span class="comment">// 成为Binder大管家</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);    <span class="comment">// 循环处理消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/binder.c</span></span><br><span class="line"><span class="keyword">struct</span> binder_state *<span class="title function_">binder_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* driver, <span class="type">size_t</span> mapsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binder_become_context_manager</span><span class="params">(<span class="keyword">struct</span> binder_state *bs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码结构"><a class="header-anchor" href="#代码结构">¶</a>代码结构</h2>
<p>binder驱动代码在kernel源码的<code>drivers/android</code>目录下，头文件在<code>linux-4.9/include/uapi/linux/android</code>目录下，代码可通过<a href="https://github.com/orangepi-xunlong/linux-orangepi/tree/orange-pi-4.9-sun50iw6">linux-orangepi</a>获取。binder驱动代码主要分为两个文件，<a href="https://github.com/orangepi-xunlong/linux-orangepi/blob/orange-pi-4.9-sun50iw6/drivers/android/binder.c">binder.c</a>包含misc设备、fops等的实现代码，以及关键数据结构的定义。与内存分配有关的代码和数据结构都定义在<a href="https://github.com/orangepi-xunlong/linux-orangepi/blob/orange-pi-4.9-sun50iw6/drivers/android/binder_alloc.c">binder_alloc.c</a>中。</p>
<p>与binder有关的编译选项主要有两个，编译选项<code>CONFIG_ANDROID_BINDER_IPC</code>决定是否将binder编译进系统；<code>CONFIG_ANDROID_BINDER_DEVICES</code>提供了设备名字列表，用逗号分割，binder会根据这个列表提供的设备名，注册若干个设备。下面是<code>orangepi3lts</code>的编译选项设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_ANDROID_BINDER_IPC=y</span><br><span class="line">CONFIG_ANDROID_BINDER_DEVICES=&quot;binder,hwbinder,vndbinder&quot;</span><br></pre></td></tr></table></figure>
<h2 id="设备驱动初始化"><a class="header-anchor" href="#设备驱动初始化">¶</a>设备驱动初始化</h2>
<p>在<a href="https://github.com/orangepi-xunlong/linux-orangepi/blob/orange-pi-4.9-sun50iw6/drivers/android/binder.c">binder.c</a>的最底部，<code>device_initcall()</code>注册了binder的初始化函数<code>binder_init()</code>，下面是初始化函数的主体结构，删除了局部变量声明、错误处理相关的代码。首先在debugfs目录下创建文件夹和文件，然后根据编译选项的配置创建若干个设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅保留主要代码</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *binder_devices_param = CONFIG_ANDROID_BINDER_DEVICES;</span><br><span class="line">module_param_named(devices, binder_devices_param, charp, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">binder_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">// 在debugfs下创建目录 binder/proc，debugfs的挂载目录可以通过mount命令查看</span></span><br><span class="line">	binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">&quot;binder&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">		binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">&quot;proc&quot;</span>,</span><br><span class="line">						 binder_debugfs_dir_entry_root);</span><br><span class="line">	<span class="comment">// 在debugfs/binder目录下创建若干个文件</span></span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据 CONFIG_ANDROID_BINDER_DEVICES 提供的设备名，创建若干个设备</span></span><br><span class="line">	device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line">	<span class="keyword">while</span> ((device_name = strsep(&amp;device_names, <span class="string">&quot;,&quot;</span>))) &#123;</span><br><span class="line">		ret = init_binder_device(device_name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure>
<p>设备驱动节点的初始化由函数<code>init_binder_device()</code>完成，参数为设备名。首先为设备申请了一个设备结构体<code>binder_device</code>，然后就是对设备结构体的初始化。</p>
<p>首先初始化成员<code>miscdev</code>，这表明binder是一个misc字符设备，相关的操作函数存储在<code>binder_fops</code>，这是一个非常重要的结构体。然后调用<code>misc_register()</code>向系统注册binder设备。</p>
<p><code>context</code>表示binder设备的使用环境，主要记录了<code>contex mgr</code>相关的信息。可以从<a href="https://source.android.google.cn/devices/architecture/hidl/binder-ipc?hl=zh-cn">Android Binder文档</a>了解到不同binder设备的用途。</p>
<p>最后，通过<code>hlist</code>将所有的设备结构体链在一起，通过链表头<code>binder_devices</code>可以遍历所有的binder设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">HLIST_HEAD</span><span class="params">(binder_devices)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_binder_device</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line">	binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	binder_device-&gt;miscdev.fops = &amp;binder_fops;</span><br><span class="line">	binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">	binder_device-&gt;miscdev.name = name;</span><br><span class="line"></span><br><span class="line">	binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">	binder_device-&gt;context.name = name;</span><br><span class="line">	mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock);</span><br><span class="line"></span><br><span class="line">	ret = misc_register(&amp;binder_device-&gt;miscdev);</span><br><span class="line">	hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来验证一下binder驱动的初始化。在debugfs的挂载目录下可以看到binder创建的目录和文件。这些文件的作用后面再说。<code>/dev</code>目录下也可以看到binder驱动创建的三个设备节点。从<a href="https://source.android.google.cn/devices/architecture/hidl/binder-ipc?hl=zh-cn">Android Binder文档</a>可以了解到每个设备节点的用途。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">console:/ # mount | grep debugfs</span><br><span class="line">debugfs on /sys/kernel/debug type debugfs (rw,seclabel,relatime)</span><br><span class="line">console:/ # ls -l /sys/kernel/debug/binder</span><br><span class="line">total 0</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 08:00 failed_transaction_log</span><br><span class="line">drwxr-xr-x 2 root root 0 2022-03-20 17:39 proc</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 08:00 state</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 08:00 stats</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 08:00 transaction_log</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 08:00 transactions</span><br><span class="line"></span><br><span class="line">console:/ # ls /dev/*binder* -l</span><br><span class="line">crw-rw-rw- 1 root root 10,  54 1970-01-01 08:00 /dev/binder</span><br><span class="line">crw-rw-rw- 1 root root 10,  53 1970-01-01 08:00 /dev/hwbinder</span><br><span class="line">crw-rw-rw- 1 root root 10,  52 1970-01-01 08:00 /dev/vndbinder</span><br></pre></td></tr></table></figure>
<blockquote>
<table>
<thead>
<tr>
<th>IPC 域</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/binder</td>
<td>框架/应用进程之间的 IPC，使用 AIDL 接口</td>
</tr>
<tr>
<td>/dev/hwbinder</td>
<td>框架/供应商进程之间的 IPC，使用 HIDL 接口<br>供应商进程之间的 IPC，使用 HIDL 接口</td>
</tr>
<tr>
<td>/dev/vndbinder</td>
<td>供应商/供应商进程之间的 IPC，使用 AIDL 接口</td>
</tr>
</tbody>
</table>
</blockquote>
<p>另外，在<code>/sys/module/binder/parameters</code>目录下，还可以看到binder驱动定义的参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">console:/ # ls -l /sys/module/binder/parameters/</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 4096 2022-03-20 19:51 debug_mask</span><br><span class="line">-r--r--r-- 1 root root 4096 2022-03-20 19:51 devices</span><br><span class="line">-rw-r--r-- 1 root root 4096 2022-03-20 19:51 stop_on_user_error</span><br></pre></td></tr></table></figure>
<h2 id="open函数"><a class="header-anchor" href="#open函数">¶</a>open函数</h2>
<p>字符设备有一个非常重要的结构体，<code>struct file_operations</code>，以下是binder的定义。在对binder设备节点执行对应的系统调用时，最终会调用到设备驱动提供的函数。使用binder驱动的第一步是调用open()函数，所以需要先分析<code>binder_open()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>binder_open()</code>主要是围绕结构体<code>binder_proc</code>来做文章，这里记录了一些打开binder的进程的信息，然在<code>debugfs/binder/proc</code>目录下创建一个以<code>pid</code>命名的文件。<code>binder_open()</code>的绝大部分代码都非常好理解，个人觉得以下代码比较关键和难懂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// misc 会将 filp-&gt;private_data 设置为 strcut miscdevice</span></span><br><span class="line">	<span class="comment">// 而这个结构体包含在 struct binder_device中，所以可以通过</span></span><br><span class="line">	<span class="comment">// container_of 拿到 binder_dev</span></span><br><span class="line">	binder_dev = container_of(filp-&gt;private_data, <span class="keyword">struct</span> binder_device, miscdev);</span><br><span class="line">	proc-&gt;context = &amp;binder_dev-&gt;context; <span class="comment">// 记录当前进程打开的设备节点</span></span><br><span class="line">	binder_alloc_init(&amp;proc-&gt;alloc);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// ioctl() 或其他fops中的函数，可通过private_data拿到proc</span></span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line">	<span class="comment">// 所有的proc链接到链表binder_procs</span></span><br><span class="line">	mutex_lock(&amp;binder_procs_lock);</span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	mutex_unlock(&amp;binder_procs_lock);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mmap函数"><a class="header-anchor" href="#mmap函数">¶</a>mmap函数</h2>
<p>设备驱动的mmap函数需要协助kernel完成<code>struct vmware_area_struct</code>结构体的设置，mmap函数就非常好理解了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除了错误处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">// 从 private_data取出proc，这是在open函数设置的</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *failure_string;</span><br><span class="line">	<span class="comment">// 只有进程的主线程才能调用mmap</span></span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;tsk != current-&gt;group_leader)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">// 最大映射4MB</span></span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</span><br><span class="line">	vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">	vma-&gt;vm_private_data = proc;</span><br><span class="line">	<span class="comment">// 为进程映射虚拟地址空间</span></span><br><span class="line">	ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>binder_alloc_mmap_handler()</code>申请了一块连续的内核虚拟内存，为每个页面申请了<code>struct binder_lru_page</code>。</p>
<p>TODO：这些数据结构有什么用？物理内存是什么时候申请的？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binder_alloc_mmap_handler</span><span class="params">(<span class="keyword">struct</span> binder_alloc *alloc,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *failure_string;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">	<span class="comment">// 保留一个连续的内核虚拟区域</span></span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">	<span class="comment">// 记录内核虚拟地址</span></span><br><span class="line">	alloc-&gt;buffer = area-&gt;addr;</span><br><span class="line">	alloc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="type">uintptr_t</span>)alloc-&gt;buffer;</span><br><span class="line">	mutex_unlock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">	<span class="comment">// 为每个页面申请一个结构体 struct binder_lru_page</span></span><br><span class="line">	alloc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(alloc-&gt;pages[<span class="number">0</span>]) *</span><br><span class="line">				((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE),</span><br><span class="line">				GFP_KERNEL);</span><br><span class="line">	alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line">	<span class="comment">// binder transactions的缓冲区</span></span><br><span class="line">	buffer = kzalloc(<span class="keyword">sizeof</span>(*buffer), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	buffer-&gt;data = alloc-&gt;buffer;</span><br><span class="line">	list_add(&amp;buffer-&gt;entry, &amp;alloc-&gt;buffers);</span><br><span class="line">	buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">	binder_insert_free_buffer(alloc, buffer);</span><br><span class="line">	alloc-&gt;free_async_space = alloc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">	barrier();</span><br><span class="line">	alloc-&gt;vma = vma;</span><br><span class="line">	alloc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line">	<span class="comment">/* Same as mmgrab() in later kernel versions */</span></span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;alloc-&gt;vma_vm_mm-&gt;mm_count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ioctl函数"><a class="header-anchor" href="#ioctl函数">¶</a>ioctl函数</h2>
<p><code>binder_ioctl()</code>是binder驱动的关键，主要功能都是在这个函数实现。首先从<code>private_data</code>拿到<code>binder_proc</code>，然后获取<code>binder_thread</code>，这个结构体表示执行ioctl的线程。如果是第一次执行，<code>binder_get_thread()</code>会创建相关的结构体并初始化。进程所有的线程以红黑树的形式存储在<code>proc-&gt;threads</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">	...</span><br><span class="line">	thread = binder_get_thread(proc);</span><br></pre></td></tr></table></figure>
<p>然后就是一个大的<code>switch</code>语句，根据不同的<code>cmd</code>执行不同的函数。下表列出了所有<code>cmd</code>、对应的参数，以及功能。其中最关键的命令非<code>BINDER_WRITE_READ</code>莫属。</p>
<table>
<thead>
<tr>
<th>cmd</th>
<th>arg</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BINDER_WRITE_READ</td>
<td>指向<code>struct binder_write_read</code>的指针。</td>
<td>使用函数<code>binder_ioctl_write_read()</code>处理。</td>
</tr>
<tr>
<td>BINDER_SET_MAX_THREADS</td>
<td>整数。</td>
<td>设置<code>proc-&gt;max_threads</code>。</td>
</tr>
<tr>
<td>BINDER_SET_CONTEXT_MGR</td>
<td>None</td>
<td><code>ServiceManager</code>进程的专属命令。</td>
</tr>
<tr>
<td>BINDER_THREAD_EXIT</td>
<td>None</td>
<td>从<code>proc-&gt;threads</code>中删除线程，释放相关资源</td>
</tr>
<tr>
<td>BINDER_VERSION</td>
<td>指向<code>struct binder_version</code>的指针</td>
<td>版本号存储在宏BINDER_CURRENT_PROTOCOL_VERSION</td>
</tr>
<tr>
<td>BINDER_GET_NODE_DEBUG_INFO</td>
<td>指向<code>struct binder_node_debug_info</code>的指针</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="BINDER-SET-CONTEXT-MGR"><a class="header-anchor" href="#BINDER-SET-CONTEXT-MGR">¶</a>BINDER_SET_CONTEXT_MGR</h3>
<p><code>ServiceManager</code>在执行完mmap()函数后，会调用此命令。这个命令由函数<code>binder_ioctl_set_ctx_mgr()</code>处理。首先检查调用的进程是否符合要求，然后新建一个<code>binder_node</code>，并保存到<code>context-&gt;binder_context_mgr_node</code>。</p>
<p><code>binder_context</code>与binder设备有关，保存在设备结构体<code>binder_device</code>中，主要保存了mgr有关的信息。<code>binder_node</code>与Service有关，每个node表示一个service。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_ioctl_set_ctx_mgr</span><span class="params">(<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="comment">// open() 函数会为 proc-&gt;context赋值，最终指向 struct binder_device中的context</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> =</span> proc-&gt;context;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">new_node</span>;</span></span><br><span class="line">	<span class="type">kuid_t</span> curr_euid = current_euid();</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">	<span class="comment">// 检查context mgr是否已经设置，检查uid / euid是否符号要求</span></span><br><span class="line">	new_node = binder_new_node(proc, <span class="literal">NULL</span>); <span class="comment">// 每个node表示一个service</span></span><br><span class="line"></span><br><span class="line">	binder_node_lock(new_node);</span><br><span class="line">	new_node-&gt;local_weak_refs++;</span><br><span class="line">	new_node-&gt;local_strong_refs++;</span><br><span class="line">	new_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">	new_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 表示ServiceManager的node</span></span><br><span class="line">	context-&gt;binder_context_mgr_node = new_node;</span><br><span class="line">	binder_node_unlock(new_node);</span><br><span class="line">	binder_put_node(new_node);</span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BINDER-WRITE-READ"><a class="header-anchor" href="#BINDER-WRITE-READ">¶</a>BINDER_WRITE_READ</h3>
<p><code>BINDER_WRITE_READ</code>命令通过函数<code>binder_ioctl_write_read()</code>来处理，前三个参数来自于<code>ioctl()</code>函数的参数，<code>thread</code>是<code>binder_get_thread(proc)</code>的返回值。函数开头，首先将参数复制到结构体<code>struct binder_write_read</code>，这个结构体比较好理解，包含了读写的字节数以及对应的缓冲区指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></span><br><span class="line">	<span class="type">binder_size_t</span>		write_size;	<span class="comment">/* 需要写入的字节数 */</span></span><br><span class="line">	<span class="type">binder_size_t</span>		write_consumed;	<span class="comment">/* 驱动消耗的字节数 */</span></span><br><span class="line">	<span class="type">binder_uintptr_t</span>	write_buffer;	<span class="comment">/* 用户空间指针，指向要写入的数据 */</span></span><br><span class="line">	<span class="type">binder_size_t</span>		read_size;	<span class="comment">/* 需要读取的字节数 */</span></span><br><span class="line">	<span class="type">binder_size_t</span>		read_consumed;	<span class="comment">/* 驱动消耗的字节数 */</span></span><br><span class="line">	<span class="type">binder_uintptr_t</span>	read_buffer;	<span class="comment">/* 用户空间指针，读取的数据复制到此buffer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_ioctl_write_read</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>然后根据<code>bwr.write_size</code>和<code>bwr.read_size</code>的值决定是否调用<code>binder_thread_write()</code>、<code>binder_thread_read()</code>做进一步处理。最后将修改后的bwr结构体复制到用户空间，因为driver会更改<code>bwr.write_consumed</code>和<code>bwr.read_consumed</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	if (bwr.write_size &gt; 0) &#123;</span><br><span class="line">		ret = binder_thread_write(proc, thread,</span><br><span class="line">					  bwr.write_buffer, bwr.write_size,</span><br><span class="line">					  &amp;bwr.write_consumed);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	if (bwr.read_size &gt; 0) &#123;</span><br><span class="line">		ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">					 bwr.read_size, &amp;bwr.read_consumed,</span><br><span class="line">					 filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">		if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))</span><br><span class="line">			binder_wakeup_proc_ilocked(proc);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="binder-thread-write"><a class="header-anchor" href="#binder-thread-write">¶</a>binder_thread_write()</h4>
<p>函数<code>binder_thread_write()</code>非常长，但好在结构比较清晰。指针<code>ptr</code>是一个用户空间指针，始终指向待处理的字节。不断的从<code>ptr</code>取出<code>cmd</code>，然后根据cmd进行不同的处理，最后更新<code>consumed</code>，直到buffer所有的数据处理完毕。也就是说，<code>bwr.write_buffer</code>由若干个cmd和紧随其后的可选固定长度参数构成，参数的长度根据cmd的不同而不同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_thread_write</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params">			<span class="type">binder_uintptr_t</span> binder_buffer, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">			<span class="type">binder_size_t</span> *consumed)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> cmd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> =</span> proc-&gt;context;</span><br><span class="line">	<span class="type">void</span> __user *buffer = (<span class="type">void</span> __user *)(<span class="type">uintptr_t</span>)binder_buffer;</span><br><span class="line">	<span class="type">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">	<span class="type">void</span> __user *end = buffer + size;</span><br><span class="line">	<span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line">		<span class="keyword">if</span> (get_user(cmd, (<span class="type">uint32_t</span> __user *)ptr))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">			...</span><br><span class="line">			*consumed = ptr - buffer;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>下表列出了<code>binder_thread_write</code>支持的所有cmd。后面结合具体的使用场景，再来分析这些命令的作用。</p>
<table>
<thead>
<tr>
<th>binder command protocol</th>
<th>param</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BC_INCREFS<br>BC_ACQUIRE<br> BC_RELEASE<br> BC_DECREFS</td>
<td>无符号32位整数，target</td>
<td>增加或减少引用计数</td>
</tr>
<tr>
<td>BC_INCREFS_DONE<br>BC_ACQUIRE_DONE</td>
<td>两个指针参数，依次是node_ptr和cookie</td>
<td></td>
</tr>
<tr>
<td>BC_ATTEMPT_ACQUIRE<br>BC_ACQUIRE_RESULT</td>
<td>None</td>
<td>这两个命令不支持</td>
</tr>
<tr>
<td>BC_FREE_BUFFER</td>
<td>一个指针参数，data_ptr</td>
<td></td>
</tr>
<tr>
<td>BC_TRANSACTION_SG<br>BC_REPLY_SG</td>
<td>有一个<code>struct binder_transaction_data_sg</code>参数</td>
<td></td>
</tr>
<tr>
<td>BC_TRANSACTION<br>BC_REPLY</td>
<td>有一个<code>struct binder_transaction_data</code>参数</td>
<td></td>
</tr>
<tr>
<td>BC_REGISTER_LOOPER</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>BC_ENTER_LOOPER</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>BC_EXIT_LOOPER</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>BC_REQUEST_DEATH_NOTIFICATION<br>BC_CLEAR_DEATH_NOTIFICATION</td>
<td>一个无符号32位整数，target；<br>一个指针参数，cookie</td>
<td></td>
</tr>
<tr>
<td>BC_DEAD_BINDER_DONE</td>
<td>一个指针参数，cookie</td>
<td></td>
</tr>
</tbody>
</table>
<p>TODO：详细理解每一个cmd的作用</p>
<h4 id="binder-thread-read"><a class="header-anchor" href="#binder-thread-read">¶</a>binder_thread_read()</h4>
<p><code>binder_thread_read()</code>函数比较长，不是很好理解。主要工作流程如下：</p>
<ol>
<li>进入阻塞状态，等待<code>binder_work</code></li>
<li>如果队列不为空，取出一个<code>binder_work</code></li>
<li>根据work的不同类型，进行不同的处理</li>
<li>给读取的线程回复一个BR命令，某些命令还会带一个参数。</li>
</ol>
<p>下面来分析实现代码。首先，设置线程的等待标志位。Binder同时支持阻塞和非阻塞模式，假设是阻塞模式，则调用<code>binder_wait_for_work()</code>等待一个<code>binder_work</code>的到来。<code>binder_wait_for_work()</code>基于Linux内核的等待队列实现，等待队列是<code>thread-&gt;wait</code>。如果当前线程已经有<code>binder_work</code>，则不会阻塞，直接返回。<code>binder_work</code>是写入线程发来的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"><span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!binder_has_work(thread, wait_for_proc_work))</span><br><span class="line">		ret = -EAGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	ret = binder_wait_for_work(thread, wait_for_proc_work);</span><br><span class="line">&#125;</span><br><span class="line">thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br></pre></td></tr></table></figure>
<p>然后进入一个死循环，根据work的不同类型进行不同的处理，具体参考下方代码块的注释。处理完毕后给读取线程的缓冲区写入一个BR命令，部分BR命令还有一个参数。<code>BINDER_WORK_TRANSACTION</code>的处理过于复杂，所以放在了<code>switch</code>语句的后面处理。暂时先不具体分析每个<code>work type</code>是怎么处理的，后面结合具体的使用场景再分析。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	w = binder_dequeue_work_head_ilocked(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123; <span class="comment">// 处理`binder_transaction`结构体</span></span><br><span class="line">		t = container_of(w, <span class="keyword">struct</span> binder_transaction, work);</span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WORK_RETURN_ERROR: &#123; <span class="comment">// 直接在读取线程的缓冲区写入`e-&gt;cmd`</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_error</span> *<span class="title">e</span> =</span> container_of( w, <span class="keyword">struct</span> binder_error, work);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">		<span class="comment">// 直接在读取线程的缓冲区写入命令`BR_TRANSACTION_COMPLETE`</span></span><br><span class="line">		cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">		put_user(cmd, (<span class="type">uint32_t</span> __user *)ptr)：</span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WORK_NODE: &#123; <span class="comment">// 处理`binder_node`结构体</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> =</span> container_of(w, <span class="keyword">struct</span> binder_node, work);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:</span><br><span class="line">	<span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</span><br><span class="line">	<span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123; <span class="comment">// 处理`binder_ref_death`结构体</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span></span><br><span class="line">		death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!t) <span class="keyword">continue</span>;</span><br><span class="line">	<span class="comment">// 处理binder_transaction结构体</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BR命令的全程是<code>binder driver return protocol</code>，由binder driver发送给service进程。下表列出了所有的BR命令及其对应的参数。</p>
<table>
<thead>
<tr>
<th>binder return protocol</th>
<th>param</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BR_OK</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>BR_TRANSACTION<br>BR_REPLY</td>
<td>struct binder_transaction_data</td>
<td>the received command.</td>
</tr>
<tr>
<td>BR_DEAD_REPLY</td>
<td>None</td>
<td>The target of the last transaction (either a bcTRANSACTION or a bcATTEMPT_ACQUIRE) is no longer with us.</td>
</tr>
<tr>
<td>BR_INCREFS<br>BR_ACQUIRE<br>BR_RELEASE<br>BR_DECREFS</td>
<td>struct binder_ptr_cookie</td>
<td>ptr to binder, cookie for binder</td>
</tr>
<tr>
<td>BR_NOOP</td>
<td>None</td>
<td>什么都不做，检查下一个命令。 它的存在主要是可以用 BR_SPAWN_LOOPER 命令替换它。</td>
</tr>
<tr>
<td>BR_SPAWN_LOOPER</td>
<td>None</td>
<td>驱动程序已确定进程没有线程等待为传入事务提供服务。 当一个进程接收到这个命令时，它必须产生一个新的服务线程并通过 bcENTER_LOOPER 注册它。</td>
</tr>
<tr>
<td>BR_DEAD_BINDER</td>
<td>binder_uintptr_t, cookie</td>
<td></td>
</tr>
<tr>
<td>BR_CLEAR_DEATH_NOTIFICATION_DONE</td>
<td>binder_uintptr_t, cookie</td>
<td></td>
</tr>
<tr>
<td>BR_FAILED_REPLY</td>
<td>None</td>
<td>最后一个事务（bcTRANSACTION 或 bcATTEMPT_ACQUIRE）失败（例如内存不足）。</td>
</tr>
</tbody>
</table>
<h2 id="Binder协议"><a class="header-anchor" href="#Binder协议">¶</a>Binder协议</h2>
<p>之前的分析，更多是语法层面的分析，还没有深入理解分析Binder的数据结构。所以，接下来根据具体的通信实例，来深入理解Binder协议，理解BC、BR命令及其参数的含义。</p>
<h3 id="注册Service"><a class="header-anchor" href="#注册Service">¶</a>注册Service</h3>
<p><a href="#binder%E8%AE%BE%E5%A4%87%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">binder设备使用方法</a>提到过，进程或线程可以向ServiceManager注册成为Service。所以现在来看看注册为Service需要发送什么样的数据。下面的代码片段来自<code>MediaPlayerService.cpp</code>，<code>defaultServiceManager()</code>会获取一个handle为0的<code>BpBinder</code>对象，并以此创建出一个<code>BpServiceManager</code>对象，BpBinder对象保存在<code>mRemote</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaPlayerService::instantiate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">defaultServiceManager</span>()-&gt;<span class="built_in">addService</span>(</span><br><span class="line">            <span class="built_in">String16</span>(<span class="string">&quot;media.player&quot;</span>), <span class="keyword">new</span> <span class="built_in">MediaPlayerService</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>BpServiceManager::addService()</code>的实现。首先使用<code>Parcel</code>打包数据。<code>Parcel</code>是一种数据容器，提供了非常多的接口来打包各种类型的数据，打包和解包需要使用对应的接口即可。然后调用<code>remote()-&gt;transact()</code>发送并接收返回的消息。<code>remote()</code>返回<code>mRemote</code>，而<code>mRemote</code>是handle等于0的<code>BpBinder</code>对象，所以<code>remote()-&gt;transact()</code>实际上是将消息发送给ServiceManager。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IServiceManager.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BpServiceManager</span> : <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> allowIsolated, <span class="type">int</span> dumpsysPriority)</span> </span>&#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">        data.<span class="built_in">writeString16</span>(name);</span><br><span class="line">        data.<span class="built_in">writeStrongBinder</span>(service); <span class="comment">// 对象类型是BINDER_TYPE_HANDLE</span></span><br><span class="line">        data.<span class="built_in">writeInt32</span>(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">// allowIsolated 默认等于 false</span></span><br><span class="line">        data.<span class="built_in">writeInt32</span>(dumpsysPriority);       <span class="comment">// dumpsysPriority 默认等于 DUMP_FLAG_PRIORITY_DEFAULT</span></span><br><span class="line">        <span class="type">status_t</span> err = <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> err == NO_ERROR ? reply.<span class="built_in">readExceptionCode</span>() : err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BpBinder::transact()</code>实际上会借助<code>IPCThreadState::transact()</code>来完成实际的发送动作，<code>IPCThreadState</code>对象每个线程有且只有一个。下面是函数的具体实现，<code>handle=0</code>，<code>code=ADD_SERVICE_TRANSACTION</code>，<code>data</code>在<code>BpServiceManager::addService()</code>函数中写入了一些对象，<code>flags</code>是默认值0，<code>reply</code>是ServiceManager返回的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp, flags 默认为0</span></span><br><span class="line"><span class="comment">// 仅保留主要代码，删除了log和错误处理</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>writeTransactionData()</code>负责将待发送数据的相关信息组合成<code>binder_transaction_data</code>结构，然后将<code>cmd</code>和<code>binder_transaction_data</code>结构写入到<code>mOut</code>对象，这也是一个<code>Parcel</code>对象。如下代码所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;  <span class="comment">// 等于0，代表ServiceManager</span></span><br><span class="line">    tr.code = code;             <span class="comment">// ADD_SERVICE_TRANSACTION</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    tr.data_size = data.<span class="built_in">ipcDataSize</span>();    <span class="comment">// 待发送数据的大小</span></span><br><span class="line">    tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();  <span class="comment">// 指向待发送数据的首地址</span></span><br><span class="line">    <span class="comment">// 待发送数据中对象的数量</span></span><br><span class="line">    tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">    tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>(); <span class="comment">// 对象相对tr.data.ptr.buffer的偏移</span></span><br><span class="line"></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IPCThreadState::waitForResponse()</code>主要完成以下两个工作：</p>
<ol>
<li>调用<code>talkWithDriver()</code>，将<code>mOut</code>发送到driver，然后等待driver回复的信息并写入到<code>mIn</code></li>
<li>根据<code>mIn</code>中的数据，进行不同的处理</li>
</ol>
<p>由于现在还不知道driver会返回什么数据，所以这个函数先不分析。先来看看<code>talkWithDriver()</code>。首先判断<code>mProcess</code>对象的文件描述符是否大于0，然后根据<code>mIn</code>和<code>mOut</code>来构建<code>binder_write_read</code>结构体，最后调用ioctl的<code>BINDER_WRITE_READ</code>命令将数据发送到driver。不妨回头看看前面对<a href="#BINDER_WRITE_READ">BINDER_WRITE_READ</a>的分析，两个地方对上了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line">    <span class="comment">// We don&#x27;t want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// This is what we&#x27;ll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    <span class="comment">// 一些错误处理，略</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图展示了从<code>addService()</code>到<code>talkWithDriver()</code>是如何对数据封装的，箭头表示指针指向对应的数据结构。前面提到过，不同的BC指令会带有不同的参数，<code>BC_TRANSACTION</code>的参数是一个<code>binder_transaction_data</code>结构体，这个结构体表明了要发送的数据、目标以及如何处理数据。</p>
<p><img src="https://image.pkemb.com/image/202204162039111.png" alt=""></p>
<p>driver使用函数<code>binder_transaction()</code>来处理<code>BC_TRANSACTION</code>，这个函数非常的长（600行左右），并且和<code>BC_REPLAY</code>共用一个函数，所以分析起来有点困难。当<code>replay=0</code>是，函数的主要流程如下：</p>
<ol>
<li>根据target.handle找到target_node / target_proc</li>
<li>构建结构体 binder_transaction</li>
<li>依次取出<code>tr-&gt;data.buffer</code>中的binder对象，并根据不同的对象类型进行不同的处理，并处理结果附加到binder_transaction</li>
<li>t-&gt;work.type = BINDER_WORK_TRANSACTION</li>
<li>调用<code>binder_proc_transaction()</code>，将<code>t-&gt;work</code>附加到<code>target_proc-&gt;todo</code>队列，然后唤醒target_proc。</li>
</ol>
<p><code>addService()</code>写入了一个类型为<code>BINDER_TYPE_HANDLE</code>的binder对象，其存储了即将注册的service的handle值。<code>binder_translate_handle()</code>的工作是获取注册service的<code>binder_node</code>，并增加引用。现在，这里的<code>target_proc</code>是<code>service manager</code>，唤醒目标进程后，<code>binder_thread_read()</code>会继续运行。注意这里的work type是<code>BINDER_WORK_TRANSACTION</code>。</p>
<p>TODO：binder_node是什么时候在driver注册的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">binder_transaction</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> binder_thread *thread,       <span class="comment">// 想注册成为Service的线程</span></span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> binder_transaction_data *tr, <span class="comment">// 在函数writeTransactionData()构建的结构体</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> reply,                          <span class="comment">// 0, replay = cmd == BC_REPLY</span></span></span><br><span class="line"><span class="params">	<span class="type">binder_size_t</span> extra_buffers_size)</span>   <span class="comment">// 0</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (reply) &#123;  <span class="comment">// 处理BC_REPLAY</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;      <span class="comment">// 处理BC_TRANSACTION</span></span><br><span class="line">		<span class="comment">// 找到 target_node / target_proc</span></span><br><span class="line">		<span class="keyword">if</span> (tr-&gt;target.handle) &#123; <span class="comment">// 目标进程不是ServiceManager</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			target_node = context-&gt;binder_context_mgr_node;</span><br><span class="line">			target_node = binder_get_node_refs_for_txn(target_node, &amp;target_proc, &amp;return_error);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 构建 binder_transaction</span></span><br><span class="line">	t-&gt;code = tr-&gt;code;   <span class="comment">// ADD_SERVICE_TRANSACTION</span></span><br><span class="line">	t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">	<span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> *<span class="title">hdr</span>;</span></span><br><span class="line">		hdr = (<span class="keyword">struct</span> binder_object_header *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">		<span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">			<span class="comment">// 根据不同的类型进行不同的处理</span></span><br><span class="line">			<span class="keyword">case</span> BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">				fp = to_flat_binder_object(hdr);</span><br><span class="line">				ret = binder_translate_handle(fp, t, thread);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">	<span class="keyword">if</span> (reply) &#123;  <span class="comment">// 处理BC_REPLAY</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">		binder_proc_transaction(t, target_proc, target_thread);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		binder_proc_transaction(t, target_proc, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从前面<a href="#binder_thread_read">binder_thread_read()</a>的分析看，<code>BINDER_WORK_TRANSACTION</code>的处理在<code>binder_thread_read()</code>函数的最后面，其主要工作是根据<code>binder_transaction</code>结构体构造<code>binder_transaction_data</code>结构体，然后写回到用户空间的buffer。注意这里的命令是<code>BR_TRANSACTION</code>，<code>tr.code</code>是<code>ADD_SERVICE_TRANSACTION</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> =</span> t-&gt;buffer-&gt;target_node;</span><br><span class="line">		tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">		tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">		cmd = BR_TRANSACTION;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	tr.code = t-&gt;code;   <span class="comment">// ADD_SERVICE_TRANSACTION</span></span><br><span class="line">	tr.flags = t-&gt;flags;</span><br><span class="line"></span><br><span class="line">	tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">	tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">	tr.data.ptr.buffer = (<span class="type">binder_uintptr_t</span>)</span><br><span class="line">		((<span class="type">uintptr_t</span>)t-&gt;buffer-&gt;data +</span><br><span class="line">		binder_alloc_get_user_buffer_offset(&amp;proc-&gt;alloc));</span><br><span class="line">	tr.data.ptr.offsets = tr.data.ptr.buffer +</span><br><span class="line">				ALIGN(t-&gt;buffer-&gt;data_size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">	put_user(cmd, (<span class="type">uint32_t</span> __user *)ptr);</span><br><span class="line">	ptr += <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">	copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">	ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后看service manager对消息的处理，历经千难万险，SM终于拿到了消息，并完成了添加service的动作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">svcmgr_handler</span><span class="params">(<span class="keyword">struct</span> binder_state *bs,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">struct</span> binder_transaction_data *txn,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">struct</span> binder_io *msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">struct</span> binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">	<span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</span><br><span class="line">		s = <span class="built_in">bio_get_string16</span>(msg, &amp;len);</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		handle = <span class="built_in">bio_get_ref</span>(msg);</span><br><span class="line">		allow_isolated = <span class="built_in">bio_get_uint32</span>(msg) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		dumpsys_priority = <span class="built_in">bio_get_uint32</span>(msg);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">do_add_service</span>(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,</span><br><span class="line">				txn-&gt;sender_pid))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取service"><a class="header-anchor" href="#获取service">¶</a>获取service</h3>
<p>TODO</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<ul>
<li><a href="http://gityuan.com/2015/11/01/binder-driver/">http://gityuan.com/2015/11/01/binder-driver/</a></li>
<li><a href="http://gityuan.com/2015/11/02/binder-driver-2/">http://gityuan.com/2015/11/02/binder-driver-2/</a></li>
<li><a href="http://gityuan.com/2015/11/07/binder-start-sm/">http://gityuan.com/2015/11/07/binder-start-sm/</a></li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>常用软件的代理设置方法</title>
    <url>/2022/07/proxy/</url>
    <content><![CDATA[<p>由于网络的原因，下载国外站点的文件非常慢，还经常中断导致下载失败，又要重新下载。这简直是浪费人生！！！一种解决方法是通过镜像站点下载，但一些偏门资源可能没有。另一种解决方法是挂代理，方便、直接、有效。</p>
<span id="more"></span>
<h2 id="git"><a class="header-anchor" href="#git">¶</a>git</h2>
<p>设置代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &quot;http://ip:port/&quot;</span><br><span class="line">git config --global https.proxy &quot;https://ip:port/&quot;</span><br></pre></td></tr></table></figure>
<p>代理需要鉴权</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &quot;http://user:password@ip:port/&quot;</span><br></pre></td></tr></table></figure>
<p>密码中特殊字符的处理：<a href="https://stackoverflow.com/questions/6172719/escape-character-in-git-proxy-password">Escape @ character in git proxy password</a></p>
<p>取消代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>
<h2 id="apt"><a class="header-anchor" href="#apt">¶</a>apt</h2>
<p><strong>方法1：设置环境变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=&quot;http://ip:port/&quot;</span><br><span class="line">export https_proxy=&quot;htts://ip:port/&quot;</span><br></pre></td></tr></table></figure>
<p><strong>方法2：修改apt配置</strong></p>
<p>修改<code>/etc/apt/apt.conf</code>，增加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquire::http::proxy &quot;http://ip:port/&quot;;</span><br><span class="line">Acquire::ftp::proxy &quot;ftp://ip:port/&quot;;</span><br><span class="line">Acquire::https::proxy &quot;https://ip:port/&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>方法3：命令行参数</strong></p>
<p>在命令行增加<code>-o</code>参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get -o Acquire::http::proxy=&quot;http://ip:port/&quot; update</span><br></pre></td></tr></table></figure>
<h2 id="wget"><a class="header-anchor" href="#wget">¶</a>wget</h2>
<p><strong>方法1：设置环境变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=&quot;http://ip:port/&quot;</span><br><span class="line">export https_proxy=&quot;htts://ip:port/&quot;</span><br></pre></td></tr></table></figure>
<p><strong>方法2：修改配置文件</strong></p>
<p>在<code>~/.wgetrc</code>增加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can <span class="built_in">set</span> the default proxies <span class="keyword">for</span> Wget to use <span class="keyword">for</span> http, https, and ftp.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">They will override the value <span class="keyword">in</span> the environment.</span></span><br><span class="line">https_proxy = http://ip:port/</span><br><span class="line">http_proxy = http://ip:port/</span><br><span class="line">ftp_proxy = http://ip:port/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If you <span class="keyword">do</span> not want to use proxy at all, <span class="built_in">set</span> this to off.</span></span><br><span class="line">use_proxy = on</span><br></pre></td></tr></table></figure>
<p>也可以使用命令行参数临时关闭或打开proxy：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--proxy=on/off</span><br></pre></td></tr></table></figure>
<p><strong>方法3：-e参数</strong></p>
<p><code>-e</code>用于执行wgetrc格式的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -e &quot;http_proxy=http://ip:port/&quot;</span><br></pre></td></tr></table></figure>
<h2 id="curl"><a class="header-anchor" href="#curl">¶</a>curl</h2>
<p><strong>方法1：设置环境变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=&quot;http://ip:port/&quot;</span><br><span class="line">export https_proxy=&quot;htts://ip:port/&quot;</span><br></pre></td></tr></table></figure>
<p><strong>方法2：修改配置文件</strong></p>
<p>编辑文件<code>~/.curlrc</code>，增加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socks5 = &quot;ip:port&quot;</span><br></pre></td></tr></table></figure>
<p><strong>方法3：命令行参数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -x socks5://ip:port ...</span><br></pre></td></tr></table></figure>
<p>参数``–noproxy`用于取消代理。</p>
]]></content>
  </entry>
  <entry>
    <title>使用trace compass分析ftrace</title>
    <url>/2022/09/analyze-ftrace-with-trace-compass/</url>
    <content><![CDATA[<p><code>ftrace</code>是一个非常好用的调试工具，特别是在调试性能相关的问题时。但在实际使用过程中发行，log实在是太多了，手工分析非常困难。所以需要一个图形化的分析工具来帮忙分析<code>strace</code>。这里简单记录一下如何使用<code>trace compass</code>来分析<code>ftrace</code>。</p>
<span id="more"></span>
<h2 id="安装trace-compass"><a class="header-anchor" href="#安装trace-compass">¶</a>安装trace compass</h2>
<p>进入<a href="https://www.eclipse.org/tracecompass/">tracecompass官网</a>，点击下载。解压后即可直接运行。trace compass需要JDK才能运行，如果启动失败，请检查JDK是否安装，以及版本是否符合要求。下图是启动之后的界面。</p>
<p><img src="http://image.pkemb.com/image/202209031531586.png" alt=""></p>
<p>使用trace compass分析ftrace需要先安装插件。点击<code>Window-&gt;Preferences</code>，找到<code>Install/Update -&gt; Available Software Sites</code>，勾选所有的sites，最后点击<code>Apply and Close</code>。如下图所示。</p>
<p><img src="http://image.pkemb.com/image/202209031539361.png" alt=""></p>
<p>点击 <code>Help -&gt; Install New Software...</code>，<code>Work with</code>选择<code>download.eclipse.org</code>，勾选<code>Trace Types, Trace Compass ftrace (Incubation)</code>，一路点击下一步、同意即可。最后重启即完成安装。以同样的方法安装<code>Analyses, Additional Kernel Plug-ins(Incubation)</code>。</p>
<p><img src="http://image.pkemb.com/image/202209031544594.png" alt=""></p>
<h2 id="分析ftrace"><a class="header-anchor" href="#分析ftrace">¶</a>分析ftrace</h2>
<p>点击<code>File -&gt; OpenTrace...</code>，打开抓好的trace文件。有关如何抓ftrace，可以参考<a href="https://pkemb.com/2022/09/capture-ftrace/">抓ftrace</a>。</p>
]]></content>
      <tags>
        <tag>ftrace</tag>
      </tags>
  </entry>
  <entry>
    <title>抓ftrace</title>
    <url>/2022/09/capture-ftrace/</url>
    <content><![CDATA[<p><code>ftrace</code>是一个非常好用的调试工具，特别是在调试性能相关的问题时。这里简单记录一下如何抓ftrace。</p>
<span id="more"></span>
<h2 id="普通方法抓取ftrace"><a class="header-anchor" href="#普通方法抓取ftrace">¶</a>普通方法抓取ftrace</h2>
<p>有关ftrace的介绍，可以参考官方文档<a href="https://www.kernel.org/doc/html/latest/trace/ftrace.html">ftrace</a>。一般是使用如下命令来抓ftrace：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /sys/kernel/debug/tracing/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭trace，并清空相关数据</span></span><br><span class="line">echo 0 &gt; tracing_on</span><br><span class="line">echo &gt; set_event</span><br><span class="line">echo &gt; trace</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置要抓取的event，根据实际需要更改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有可用的event可以 <span class="built_in">cat</span> available_events</span></span><br><span class="line">echo &quot;sched&quot; &gt;&gt; set_event</span><br><span class="line">echo &quot;irq&quot; &gt;&gt;  set_event</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置buff，越大能抓的<span class="built_in">log</span>越多，但越占用内存空间。如果<span class="built_in">log</span>的大小超过buff，则覆盖最开始的<span class="built_in">log</span>。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意这是每个CPU核心的buffer大小，实际使用的内存空间要乘以核心数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以 <span class="built_in">cat</span> buffer_total_size_kb 查看总buffer大小</span></span><br><span class="line">echo 20480 &gt; buffer_size_kb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启抓ftrace</span></span><br><span class="line">echo 1 &gt; tracing_on</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复现到bug后停止</span></span><br><span class="line">echo 0 &gt; tracing_on</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存<span class="built_in">log</span></span></span><br><span class="line">cat trace &gt; /path/to/ftrace.log</span><br></pre></td></tr></table></figure>
<p>但在实际的debug实践中，发行buffer的大小不太好控制。buffer设置太小，log容易被覆盖。但buffer设置太大，会占用较多的内存空间，影响其他程序的运行。而且一些嵌入式设备，内存很小。</p>
<h2 id="trace-cmd"><a class="header-anchor" href="#trace-cmd">¶</a>trace-cmd</h2>
<p><code>trace-cmd</code>是ftrace的前端应用程序，其官网是<a href="https://trace-cmd.org/">trace-cmd.org/</a>，源代码在<a href="https://git.kernel.org/pub/scm/utils/trace-cmd/trace-cmd.git/">trace-cmd.git</a>。</p>
<h3 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h3>
<p>对于常用的Linux发行版本，可以使用直接包管理器安装。例如Ubuntu使用如下命令安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install trace-cmd</span><br></pre></td></tr></table></figure>
<h3 id="交叉编译"><a class="header-anchor" href="#交叉编译">¶</a>交叉编译</h3>
<p>对于嵌入式Linux，一般来说需要交叉编译。可以参考如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装交叉编译工具链，或直接使用BSP提供的工具链</span></span><br><span class="line">sudo apt-get install gcc-arm-linux-gnueabi</span><br><span class="line">export CC=arm-linux-gnueabi-gcc</span><br><span class="line">export CROSS_COMPILE=arm-linux-gnueabi-</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建相关目录</span></span><br><span class="line">mkdir ~/trace</span><br><span class="line">cd ~/trace</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 libtraceevent</span></span><br><span class="line">git clone https://git.kernel.org/pub/scm/libs/libtrace/libtraceevent.git</span><br><span class="line">cd libtraceevent</span><br><span class="line">make</span><br><span class="line">make DESTDIR=~/trace/install install</span><br><span class="line">sed -i -e &#x27;s@prefix=/usr/local@prefix=/home/pk/trace/install/usr/local@g&#x27; \</span><br><span class="line">~/trace/install/usr/local/lib/x86_64-linux-gnu/pkgconfig/libtraceevent.pc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 libtracefs</span></span><br><span class="line">cd ~/trace</span><br><span class="line">git clone https://git.kernel.org/pub/scm/libs/libtrace/libtracefs.git</span><br><span class="line">cd libtracefs</span><br><span class="line">export PKG_CONFIG_PATH=~/trace/install/usr/local/lib/x86_64-linux-gnu/pkgconfig</span><br><span class="line">make</span><br><span class="line">make DESTDIR=~/trace/install install</span><br><span class="line">sed -i -e &#x27;s@prefix=/usr/local@prefix=/home/pk/trace/install/usr/local@g&#x27; \</span><br><span class="line">~/trace/install/usr/local/lib/x86_64-linux-gnu/pkgconfig/libtracefs.pc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译trace-cmd</span></span><br><span class="line">git clone https://git.kernel.org/pub/scm/utils/trace-cmd/trace-cmd.git</span><br><span class="line">LDFLAGS=-static make</span><br><span class="line">make DESTDIR=~/trace/install install</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://marryton007.github.io/2021/11/29/embedded/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91trace-cmd/">交叉编译trace-cmd</a></p>
<h3 id="子命令"><a class="header-anchor" href="#子命令">¶</a>子命令</h3>
<p><code>trace-cmd</code>支持的子命令如下。比较常用的有record、reset、report、stat、list。每个子命令都有很多选项，可以用命令<code>trace-cmd command -h</code>查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trace-cmd version 2.9.1 (not-a-git-repo)</span><br><span class="line"></span><br><span class="line">usage:</span><br><span class="line">  trace-cmd [COMMAND] ...</span><br><span class="line"></span><br><span class="line">  commands:</span><br><span class="line">     record - record a trace into a trace.dat file</span><br><span class="line">     set - set a ftrace configuration parameter</span><br><span class="line">     start - start tracing without recording into a file</span><br><span class="line">     extract - extract a trace from the kernel</span><br><span class="line">     stop - stop the kernel from recording trace data</span><br><span class="line">     restart - restart the kernel trace data recording</span><br><span class="line">     show - show the contents of the kernel tracing buffer</span><br><span class="line">     reset - disable all kernel tracing and clear the trace buffers</span><br><span class="line">     clear - clear the trace buffers</span><br><span class="line">     report - read out the trace stored in a trace.dat file</span><br><span class="line">     stream - Start tracing and read the output directly</span><br><span class="line">     profile - Start profiling and read the output directly</span><br><span class="line">     hist - show a histogram of the trace.dat information</span><br><span class="line">     stat - show the status of the running tracing (ftrace) system</span><br><span class="line">     split - parse a trace.dat file into smaller file(s)</span><br><span class="line">     options - list the plugin options available for trace-cmd report</span><br><span class="line">     listen - listen on a network socket for trace clients</span><br><span class="line">     agent - listen on a vsocket for trace clients</span><br><span class="line">     setup-guest - create FIFOs for tracing guest VMs</span><br><span class="line">     list - list the available events, plugins or options</span><br><span class="line">     restore - restore a crashed record</span><br><span class="line">     snapshot - take snapshot of running trace</span><br><span class="line">     stack - output, enable or disable kernel stack tracing</span><br><span class="line">     check-events - parse trace event formats</span><br><span class="line">     dump - read out the meta data from a trace file</span><br></pre></td></tr></table></figure>
<h3 id="trace-cmd示例"><a class="header-anchor" href="#trace-cmd示例">¶</a>trace-cmd示例</h3>
<p>首先使用record子命令抓ftrace，然后用report命令转化为文本格式。也可以不转换，直接导入<a href="https://kernelshark.org/">KernelShark</a>分析。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-m 设置buff的大小，-e 设置event，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-o 输出到指定文件。对于空间比较小的嵌入式设备，可以保存到外挂的U盘</span></span><br><span class="line">pi@pi4b:~ $ sudo trace-cmd record -m 40960 -e &#x27;sched_*&#x27; -e &#x27;irq_*&#x27; -o ./ftrace.dat</span><br><span class="line">Hit Ctrl^C to stop recording</span><br><span class="line">^CCPU0 data recorded at offset=0x5f7000</span><br><span class="line">    29159424 bytes in size</span><br><span class="line">CPU1 data recorded at offset=0x21c6000</span><br><span class="line">    22093824 bytes in size</span><br><span class="line">CPU2 data recorded at offset=0x36d8000</span><br><span class="line">    35000320 bytes in size</span><br><span class="line">CPU3 data recorded at offset=0x5839000</span><br><span class="line">    39243776 bytes in size</span><br><span class="line">pi@pi4b:~ $ trace-cmd report -i ftrace.dat &gt; ftrace.log</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ftrace</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次解决VMWare Ubuntu虚拟机卡死</title>
    <url>/2022/10/vmware-ubuntu-hangs/</url>
    <content><![CDATA[<p>最近好几台VMware Ubuntu虚拟机开机15分钟后卡死，断断续续查了将近半个月。一度想重装虚拟机，但考虑到要重新配置的软件太多了，遂放弃。最后决定还是死磕，终于解决了。</p>
<span id="more"></span>
<h2 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h2>
<p>VMware Ubuntu20.04虚拟机，开机后system和软中断占用率逐渐增加，大概15分钟后吃掉所有CPU，系统卡死，虚拟终端无响应，SSH断连，所有服务无响应。虚拟机暂停后resume可以登录系统操作，但过15分钟后依旧卡死。重启系统后依旧有问题。卡死前的top截图如下。</p>
<p><img src="http://image.pkemb.com/image/202210151539366.png" alt=""></p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<ul>
<li>解决方法：虚拟机打开<code>Intel VT-x/EPT</code>后没有问题了。</li>
<li>根本原因：没有找到，可能是Windows升级导致的。</li>
<li>感悟：要多思考，根据线索仔细分析可能的问题点，抓log并分析。<strong>不是瞎猜</strong>。</li>
</ul>
<h2 id="第一次交手：drm-kms-helper"><a class="header-anchor" href="#第一次交手：drm-kms-helper">¶</a>第一次交手：drm_kms_helper</h2>
<p>卡死后再等一会，从虚拟终端能看到一点点kernel的报错log，如下代码块所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jul 27 09:21:10 (my server name) kernel: [drm:drm_atomic_helper_wait_for_dependencies [drm_kms_helper]] *ERROR* [PLANE:34lane-0] flip_done timed out</span><br></pre></td></tr></table></figure>
<h3 id="在网络上寻找答案"><a class="header-anchor" href="#在网络上寻找答案">¶</a>在网络上寻找答案</h3>
<p>用相关的关键字搜索，找到两个解决方法，但是都没有用，<strong>还是有问题</strong>。</p>
<ol>
<li>降低kernel版本到5.4.0-122，<a href="https://community.spiceworks.com/topic/2459117-kernel-errors-present-ubuntu-20-04-4-on-vmware-esxi-7-03">参考</a>。</li>
<li>更改kernel启动参数，<a href="https://askubuntu.com/questions/893817/boot-very-slow-because-of-drm-kms-helper-errors">参考</a>。</li>
</ol>
<h3 id="nogui"><a class="header-anchor" href="#nogui">¶</a>nogui</h3>
<p>考虑到<code>kms</code>和显示有关，所以尝试以<code>nogui</code>参数启动虚拟机，但是没有用，<strong>还是有问题</strong>。</p>
<h3 id="删除相关ko"><a class="header-anchor" href="#删除相关ko">¶</a>删除相关ko</h3>
<p>报错log中出现最多的关键字就是<code>kms</code>，通过lsmod发现有一个名为<code>drm_kms_helper</code>的模块，非常可疑。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pk@localhost:~$ lsmod | grep drm</span><br><span class="line">drm_kms_helper               184320   1 vmwgfx</span><br><span class="line">syscopyarea                   16384   1 drm_kms_helper</span><br><span class="line">sysfillrect                   16384   1 drm_kms_helper</span><br></pre></td></tr></table></figure>
<p>在<code>blacklist.conf</code>把<code>vmwgfx</code>和<code>drm_kms_helper</code>加入黑名单，更新kernel，重启系统。但是没有用，<strong>还是有问题</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pk@localhost:~$ tail -2 /etc/modprobe.d/blacklist.conf</span><br><span class="line">blacklist vmwgfx</span><br><span class="line">blacklist drm_kms_helper</span><br><span class="line">pk@localhost:~$ sudo update-initramfs -u</span><br><span class="line">pk@localhost:~$ sudo reboot</span><br></pre></td></tr></table></figure>
<h2 id="第二次交手：卸载软件或停止服务"><a class="header-anchor" href="#第二次交手：卸载软件或停止服务">¶</a>第二次交手：卸载软件或停止服务</h2>
<p>看来不是<code>drm_kms_helper</code>的问题。考虑到出现问题之后，好像是给confluence装了几个插件。会不会是插件有问题呢？赶紧卸载最近安装的插件，等待，<strong>还是有问题</strong>。</p>
<p>从<code>top</code>的输出截图看，有几个java程序的占用率也非常高。考虑到虚拟机跑了非常多的服务，所以把所有的服务都停了，等待，<strong>还是有问题</strong>。</p>
<h2 id="第三次交手：升级软件"><a class="header-anchor" href="#第三次交手：升级软件">¶</a>第三次交手：升级软件</h2>
<p>可能是VMWare低版本的一个bug，最近才被打到？现在的版本是16.12，官网的最新版本是16.2.4。赶紧下载最新的版本装上去，等待，<strong>还是有问题</strong>。</p>
<p>难道是Ubuntu20的一个bug？升级到Ubuntu22试试。考虑到正常工作时间才15分钟左右，可能无法完成升级，所以升级之前拍了一个快照。执行命令<code>do-release-upgrade</code>进行发现版本升级，中间pause、resume虚拟机好几次，终于升级上去了。升级完毕后重启系统，完蛋，启动失败，rootfs找不到。懒得修了，回滚到Ubuntu20吧。</p>
<p>不要怀疑，<code>apt upgrade</code>升级所有软件，也<strong>还是有问题</strong>。</p>
<h2 id="第四次交手：journalctl"><a class="header-anchor" href="#第四次交手：journalctl">¶</a>第四次交手：journalctl</h2>
<p>实在想不出问题在哪里，用<code>journalctl -b -1</code>看看上次启动的日志，发现有大量<code>multipathd</code>的log，很有可能这就是这里了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Oct 14 22:15:09 pk.inc multipathd[1032]: sda: failed to get udev uid: Invalid argument</span><br><span class="line">Oct 14 22:15:09 pk.inc multipathd[1032]: sda: failed to get sysfs uid: Invalid argument</span><br><span class="line">Oct 14 22:15:09 pk.inc multipathd[1032]: sda: failed to get sgio uid: No such file or directory</span><br><span class="line">Oct 14 22:15:10 pk.inc multipathd[1032]: sdb: add missing path</span><br><span class="line">Oct 14 22:15:10 pk.inc multipathd[1032]: sdb: failed to get udev uid: Invalid argument</span><br><span class="line">Oct 14 22:15:10 pk.inc multipathd[1032]: sdb: failed to get sysfs uid: Invalid argument</span><br><span class="line">Oct 14 22:15:10 pk.inc multipathd[1032]: sdb: failed to get sgio uid: No such file or directory</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://blog.csdn.net/lk_luck/article/details/120730206">esx-Server 多路径配置</a>，在<code>/etc/multipath.conf</code>添加<code>blacklist</code>，重启服务器。在要准备庆祝的时候，<strong>服务器卡死了</strong>！！！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pk@localhost:~$ cat /etc/multipath.conf</span><br><span class="line">defaults &#123;</span><br><span class="line">    user_friendly_names yes</span><br><span class="line">&#125;</span><br><span class="line">blacklist &#123;</span><br><span class="line">    devnode &quot;^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*&quot;</span><br><span class="line">    devnode &quot;^sd[a-z]?[0-9]*&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第五次交手：kenrel"><a class="header-anchor" href="#第五次交手：kenrel">¶</a>第五次交手：kenrel</h2>
<p>仔细观察最终的top截图，发现<code>sy</code>和<code>si</code>的占用率非常高，很有可能问题是出在kernel。也不去猜了，直接硬碰硬，抓trace。</p>
<h3 id="perf-top"><a class="header-anchor" href="#perf-top">¶</a>perf top</h3>
<p><code>perf top</code>可以看到内核函数的占用率，可以精准定位。安装之后，执行<code>perf top</code>，没有任何输出，虚拟机好像好像还挂了，em…，难受。放弃这个方法。</p>
<h3 id="ftrace"><a class="header-anchor" href="#ftrace">¶</a>ftrace</h3>
<p>既然<code>si</code>的占用率高，那就抓一下irq的ftrace。执行下面的命令抓ftrace，待虚拟机卡死后，pause、resume，虚拟机恢复正常，Ctrl-C结束抓取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trace-cmd record -e irq</span><br></pre></td></tr></table></figure>
<p>用<code>kernelshark</code>加载trace.dat，发现irq有大段的空白。</p>
<img src=http://image.pkemb.com/image/202210151734293.png width=70%>
<p>只显示一个CPU的事件，随便选取一个空白，CPU0将近27秒没有任何irq，这很不正常。kernel本身应该不会有这么严重bug，难道是CPU的问题？</p>
<img src=http://image.pkemb.com/image/202210151738171.png width=70%>
<p>由于之前开启了Hyper-V，所以虚拟机关闭了<code>Intel VT-x/EPT</code>。难度是因为这个？赶紧进入控制面板，打开Windows功能，关闭<code>Hyper-V</code>、<code>Windows虚拟机程序监控平台</code>、<code>虚拟机平台</code>，重启电脑。</p>
<img src=http://image.pkemb.com/image/202210151812725.png width=50%>
<p>进入虚拟机的CPU设置，打开<code>Intel VT-x/EPT</code>，启动虚拟机，静静的等待，完美！！！不再出现卡死的情况，完结撒花！</p>
<img src=http://image.pkemb.com/image/202210151815689.png width=40%>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用yocto为arm平台编译bpftrace</title>
    <url>/2023/02/use-yocto-compile-bpftrace-for-arm/</url>
    <content><![CDATA[<p>bpftrace最新发布的<a href="https://github.com/iovisor/bpftrace/releases/tag/v0.17.0">0.17.0</a>加入了对arm平台的支持，所以就想为arm平台编译一版bpftrace。值得注意的是，bpftrace才加入对arm 32位的支持（<a href="https://github.com/iovisor/bpftrace/pull/2360">#2360</a>，<a href="https://github.com/iovisor/bpftrace/pull/2361">#2361</a>），由于之前一直是基于64位系统，所以现在工作的还不是很好，还有一些bug。</p>
<span id="more"></span>
<h2 id="yocto环境准备"><a class="header-anchor" href="#yocto环境准备">¶</a>yocto环境准备</h2>
<p>bpftrace相关的bb在<a href="https://github.com/kraj/meta-clang">meta-clang</a>。同时我想使用一个真实arm平台的BSP，而不是yocto提供的虚拟机<code>qemuarm</code>，所以我还加入了<a href="https://git.yoctoproject.org/meta-raspberrypi">meta-raspberrypi</a>。考虑到需要克隆很多仓库，所以借助<code>repo</code>工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir bpftrace-arm</span><br><span class="line">cd bpftrace-arm</span><br><span class="line">repo init -u https://gitlab.com/pkemb/yocto-manifest.git -b master</span><br><span class="line">repo sync</span><br><span class="line">repo start master --all</span><br><span class="line">export TEMPLATECONF=$&#123;PWD&#125;/meta/meta-pkemb/conf/templates/bpftrace-arm</span><br><span class="line">source meta/poky/oe-init-build-env</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><a href="https://gitlab.com/pkemb/yocto-manifest">pkemb/yocto-manifest</a>默认使用内网的镜像地址。</li>
<li>环境变量<code>TEMPLATECONF</code>用于指定示例配置文件的位置，详细说明参考<a href="https://docs.yoctoproject.org/singleindex.html#term-TEMPLATECONF">yocto文档</a>。</li>
<li><code>repo sync</code>默认会从Google服务器下载最新版的<code>repo</code>工具。由于一些原因，国内无法下载。可以设置环境变量<code>export REPO_URL=https://mirrors.tuna.tsinghua.edu.cn/git/git-repo</code>，从清华源下载。</li>
<li>现在（2023年2月12日）meta-clang中的bpftrace版本是0.16.0，0.16.0 ~ 0.17.0有一些关于32位的修改，这些补丁在meta-pkemb中有加入。</li>
</ul>
<h2 id="修改bb文件"><a class="header-anchor" href="#修改bb文件">¶</a>修改bb文件</h2>
<p>修改bpftrace及其相关依赖的bb文件，在<code>COMPATIBLE_HOST</code>变量中加入<code>arm</code>。</p>
<h3 id="meta-meta-clang"><a class="header-anchor" href="#meta-meta-clang">¶</a>meta/meta-clang</h3>
<p><code>bcc_0.26.0.bb</code>和<code>bpftrace_0.16.0.bb</code>。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/dynamic-layers/openembedded-layer/recipes-devtools/bcc/bcc_0.26.0.bb b/dynamic-layers/openembedded-layer/recipes-devtools/bcc/bcc_0.26.0.bb</span></span><br><span class="line"><span class="comment">index 36c6192..23009c6 100644</span></span><br><span class="line"><span class="comment">--- a/dynamic-layers/openembedded-layer/recipes-devtools/bcc/bcc_0.26.0.bb</span></span><br><span class="line"><span class="comment">+++ b/dynamic-layers/openembedded-layer/recipes-devtools/bcc/bcc_0.26.0.bb</span></span><br><span class="line"><span class="meta">@@ -68,4 +68,4 @@</span> do_install_ptest() &#123;</span><br><span class="line"> FILES:$&#123;PN&#125; += &quot;$&#123;PYTHON_SITEPACKAGES_DIR&#125;&quot;</span><br><span class="line"> FILES:$&#123;PN&#125;-doc += &quot;$&#123;datadir&#125;/$&#123;PN&#125;/man&quot;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-COMPATIBLE_HOST = &quot;(x86_64.*|aarch64.*|powerpc64.*|riscv64.*)-linux&quot;</span></span><br><span class="line"><span class="addition">+COMPATIBLE_HOST = &quot;(x86_64.*|aarch64.*|arm.*|powerpc64.*|riscv64.*)-linux&quot;</span></span><br><span class="line"><span class="comment">diff --git a/dynamic-layers/openembedded-layer/recipes-devtools/bpftrace/bpftrace_0.16.0.bb b/dynamic-layers/openembedded-layer/recipes-devtools/bpftrace/bpftrace_0.16.0.bb</span></span><br><span class="line"><span class="comment">index ca324bc..19e8c64 100644</span></span><br><span class="line"><span class="comment">--- a/dynamic-layers/openembedded-layer/recipes-devtools/bpftrace/bpftrace_0.16.0.bb</span></span><br><span class="line"><span class="comment">+++ b/dynamic-layers/openembedded-layer/recipes-devtools/bpftrace/bpftrace_0.16.0.bb</span></span><br><span class="line"><span class="meta">@@ -54,5 +54,5 @@</span> EXTRA_OECMAKE = &quot; \</span><br><span class="line">     -DENABLE_MAN=OFF \</span><br><span class="line"> &quot;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-COMPATIBLE_HOST = &quot;(x86_64.*|aarch64.*|powerpc64.*|riscv64.*)-linux&quot;</span></span><br><span class="line"><span class="addition">+COMPATIBLE_HOST = &quot;(x86_64.*|aarch64.*|arm.*|powerpc64.*|riscv64.*)-linux&quot;</span></span><br><span class="line"> COMPATIBLE_HOST:libc-musl = &quot;null&quot;</span><br></pre></td></tr></table></figure>
<h3 id="meta-meta-openembedded"><a class="header-anchor" href="#meta-meta-openembedded">¶</a>meta/meta-openembedded</h3>
<p><code>libbpf_0.8.0.bb</code>。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/meta-oe/recipes-kernel/libbpf/libbpf_0.8.0.bb b/meta-oe/recipes-kernel/libbpf/libbpf_0.8.0.bb</span></span><br><span class="line"><span class="comment">index 3aea7c079..909478be3 100644</span></span><br><span class="line"><span class="comment">--- a/meta-oe/recipes-kernel/libbpf/libbpf_0.8.0.bb</span></span><br><span class="line"><span class="comment">+++ b/meta-oe/recipes-kernel/libbpf/libbpf_0.8.0.bb</span></span><br><span class="line"><span class="meta">@@ -12,7 +12,7 @@</span> SRC_URI = &quot;git://github.com/libbpf/libbpf.git;protocol=https;branch=master&quot;</span><br><span class="line"> SRCREV = &quot;86eb09863c1c0177e99c2c703092042d3cdba910&quot;</span><br><span class="line"></span><br><span class="line"> PACKAGE_ARCH = &quot;$&#123;MACHINE_ARCH&#125;&quot;</span><br><span class="line"><span class="deletion">-COMPATIBLE_HOST = &quot;(x86_64|i.86|aarch64|riscv64|powerpc64).*-linux&quot;</span></span><br><span class="line"><span class="addition">+COMPATIBLE_HOST = &quot;(x86_64|i.86|aarch64|arm|riscv64|powerpc64).*-linux&quot;</span></span><br><span class="line"></span><br><span class="line"> S = &quot;$&#123;WORKDIR&#125;/git/src&quot;</span><br></pre></td></tr></table></figure>
<h2 id="启动编译"><a class="header-anchor" href="#启动编译">¶</a>启动编译</h2>
<p>yocto是在编译前通过<code>do_fetch</code>任务下载bb指定的源代码，下载很有可能会失败。所以建议把所有的fetch任务跑完之后，再开始编译。建议晚上睡觉前编译，因为<code>clang</code>需要编译非常非常非常久。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载所有的源代码</span></span><br><span class="line">bitbake bpftrace --runall=fetch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始编译</span></span><br><span class="line">bitbake bpftrace</span><br></pre></td></tr></table></figure>
<p>编译成功之后，bpftrace可执行文件在 <code>build/tmp/work/cortexa7t2hf-neon-vfpv4-poky-linux-gnueabi/bpftrace/0.16.0+gita277ec42102c463d656df8f64eb2f7e87e322210-r0/package/usr/bin</code>。</p>
<h2 id="运行bpftrace"><a class="header-anchor" href="#运行bpftrace">¶</a>运行bpftrace</h2>
<p>yocto编译时所使用的glibc版本，与平台里的glibc版本可能不一致，所以bpftrace是无法直接运行的。为了将bpftrace跑起来，需要一些技巧，这里提供两个参考的方法。</p>
<h3 id="复制文件到arm平台"><a class="header-anchor" href="#复制文件到arm平台">¶</a>复制文件到arm平台</h3>
<p>为了缩短路径长度，以下相对路径均基于bpftrace的工作目录<code>build/tmp/work/cortexa7t2hf-neon-vfpv4-poky-linux-gnueabi/bpftrace/0.16.0+gita277ec42102c463d656df8f64eb2f7e87e322210-r0/</code>。</p>
<ol>
<li>在编译主机打包<code>recipe-sysroot</code>目录，复制到arm平台并解压。假设是放在arm平台的<code>/root/bpf/recipe-sysroot</code>目录。</li>
<li>将编译主机的文件<code>package/usr/bin/bpftrace</code>复制到arm平台的<code>/root/bpf/recipe-sysroot/usr/bin</code>目录。</li>
</ol>
<h3 id="方法一：chroot"><a class="header-anchor" href="#方法一：chroot">¶</a>方法一：chroot</h3>
<p>通过<code>chroot</code>命令，为bpftrace打造一个专属的rootfs，包含bpftrace对应的glibc，以及依赖的库和头文件。</p>
<p>编写wrapper脚本<code>/usr/bin/bpftrace_chroot.sh</code>，内容如下。记得给脚本加可执行权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">SYSROOT=&quot;/root/bpf/recipe-sysroot&quot;</span><br><span class="line"></span><br><span class="line">mkdir -p $SYSROOT/proc $SYSROOT/sys</span><br><span class="line"></span><br><span class="line">if ! mount | grep -q $SYSROOT/proc; then</span><br><span class="line">    mount --bind /proc $SYSROOT/proc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if ! mount | grep -q $SYSROOT/sys; then</span><br><span class="line">    mount --bind /sys $SYSROOT/sys</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if ! mount | grep -q $SYSROOT/sys/kernel/debug; then</span><br><span class="line">    mount --bind /sys/kernel/debug $SYSROOT/sys/kernel/debug</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">chroot /root/bpf/recipe-sysroot /usr/bin/bpftrace &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~# bpftrace_chroot.sh -l &#x27;*sleep*&#x27;</span><br><span class="line">hardware:*sleep*:</span><br><span class="line">kprobe:__rpc_sleep_on_priority</span><br><span class="line">kprobe:alarm_timer_nsleep</span><br><span class="line">kprobe:alarm_timer_nsleep_restart</span><br><span class="line">kprobe:alarmtimer_do_nsleep</span><br><span class="line">kprobe:alarmtimer_nsleep_wakeup</span><br><span class="line">kprobe:brcmf_sdio_bus_sleep</span><br><span class="line">kprobe:brcmf_sdio_sleep</span><br><span class="line">kprobe:common_nsleep</span><br><span class="line">kprobe:do_cpu_nanosleep</span><br><span class="line">kprobe:do_nanosleep</span><br><span class="line">kprobe:dwc_otg_get_lpm_portsleepstatus</span><br><span class="line">kprobe:fscache_object_sleep_till_congested</span><br><span class="line">kprobe:gpiod_cansleep</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="方法二：patchelf"><a class="header-anchor" href="#方法二：patchelf">¶</a>方法二：patchelf</h3>
<p>首先使用patchelf修改bpftrace的解释器，然后修改<code>LD_LIBRARY_PATH</code>。具体步骤如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/bpftrace/recipe-sysroot/usr/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份一下</span></span><br><span class="line">cp bpftrace bpftrace_patchelf</span><br><span class="line">patchelf --set-interpreter /root/bpf/recipe-sysroot/lib/ld-linux-armhf.so.3 ./bpftrace_patchelf</span><br></pre></td></tr></table></figure>
<p>编写wrapper脚本/usr/bin/bpftrace_patchelf.sh，内容如下。记得给脚本加可执行权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=/root/bpf/recipe-sysroot/lib:/root/bpf/recipe-sysroot/usr/lib</span><br><span class="line"></span><br><span class="line">/root/bpftrace/recipe-sysroot/usr/bin/bpftrace_patchelf &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~# bpftrace_patchelf.sh -l &#x27;*sleep*&#x27;</span><br><span class="line">hardware:*sleep*:</span><br><span class="line">kprobe:__rpc_sleep_on_priority</span><br><span class="line">kprobe:alarm_timer_nsleep</span><br><span class="line">kprobe:alarm_timer_nsleep_restart</span><br><span class="line">kprobe:alarmtimer_do_nsleep</span><br><span class="line">kprobe:alarmtimer_nsleep_wakeup</span><br><span class="line">kprobe:brcmf_sdio_bus_sleep</span><br><span class="line">kprobe:brcmf_sdio_sleep</span><br><span class="line">kprobe:common_nsleep</span><br><span class="line">kprobe:do_cpu_nanosleep</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="已知问题"><a class="header-anchor" href="#已知问题">¶</a>已知问题</h2>
<h3 id="无法获取到正确的数值型数据"><a class="header-anchor" href="#无法获取到正确的数值型数据">¶</a>无法获取到正确的数值型数据</h3>
<p>如下面的命令，pid是一个非常大的值，系统中并没有这个进程。<code>tid</code>、<code>nsecs</code>等参数也是类似的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:~# bpftrace_patchelf.sh -e &#x27;kprobe:do_nanosleep &#123; printf(&quot;PID %s(%d) sleeping...\n&quot;, comm, pid); &#125;&#x27;</span><br><span class="line">sh: relocation error: /root/bpf/recipe-sysroot/lib/libc.so.6: symbol __nptl_set_robust_list_avail version GLIBC_PRIVATE not defined in file ld-linux-armhf.so.3 with link time reference</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">PID sleep(2128712024) sleeping...</span><br><span class="line">PID sleep(2128712024) sleeping...</span><br><span class="line">PID sleep(2128712024) sleeping...</span><br><span class="line">PID cron(2128712024) sleeping...</span><br><span class="line">PID sleep(2128712024) sleeping...</span><br><span class="line">PID sleep(2128712024) sleeping...</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://github.com/iovisor/bpftrace/issues/1688">arm 32 support(issue 1688)</a></li>
<li><a href="https://github.com/iovisor/bpftrace/pull/2360">#2360</a></li>
<li><a href="https://chasinglulu.github.io/2021/07/07/%E5%9C%A8AArch64%E5%B9%B3%E5%8F%B0%E4%B8%8A%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5eBPF%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B7%A5%E5%85%B7/">在AArch64平台上静态编译链接eBPF相关的工具</a></li>
</ul>
]]></content>
      <categories>
        <category>bpf</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>bpftrace</tag>
      </tags>
  </entry>
  <entry>
    <title>confluence的安装、使用与维护</title>
    <url>/2023/03/confluence/</url>
    <content><![CDATA[<p>记录一下confluence的安装、使用与维护。</p>
<span id="more"></span>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<p><code>confluence</code>需要jdk和数据库，这里选择mysql数据库。为了方便维护，使用宝塔面板安装和创建Mysql数据库。版本号可以参考<a href="https://confluence.atlassian.com/doc/supported-platforms-207488198.html">Supported Platforms</a>。</p>
<h3 id="安装JDK"><a class="header-anchor" href="#安装JDK">¶</a>安装JDK</h3>
<p><code>confluence</code>不能使用openjdk，只能使用oracal jdk。所以如果服务器之前安装了openjdk，请先卸载。jdk可以在镜像网站<a href="https://www.injdk.cn/">injdk</a>下载，建议使用<code>jdk11</code>。如果已安装，跳过此步。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要root权限</span></span><br><span class="line">cd /usr/local</span><br><span class="line">wget https://d6.injdk.cn/oraclejdk/11/jdk-11.0.12_linux-x64_bin.tar.gz</span><br><span class="line">tar -xf jdk-11.0.12_linux-x64_bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>编辑<code>/etc/bash.bashrc</code>或<code>/etc/bashrc</code>，文件最后加入如下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk-11.0.12</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>退出登录，再次登录服务器。使用如下命令验证安装是否成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pk@pk:~$ java --version</span><br><span class="line">java 11.0.12 2021-07-20 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.12+8-LTS-237)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.12+8-LTS-237, mixed mode)</span><br><span class="line">pk@pk:~$ <span class="built_in">which</span> java</span><br><span class="line">/usr/local/jdk-11.0.12/bin/java</span><br></pre></td></tr></table></figure>
<h3 id="创建数据库"><a class="header-anchor" href="#创建数据库">¶</a>创建数据库</h3>
<p>进入宝塔面板。如果没有安装mysql数据库，需要先在软件商店安装mysql，推荐安装<code>mysql8</code>。如果已经安装低版本的mysql，需要卸载重新安装<code>mysql8</code>。</p>
<p>mysql安装好之后，点击左侧的数据库，点击添加数据库，填写数据库名和用户名，编码选择<code>utf-8</code>，点击提交。记住数据库名、用户名和密码。</p>
<img src="http://image.pkemb.com/image/202303191636743.png" width="70%">
<blockquote>
<p>安装宝塔面板可以参考 <a href="https://www.bt.cn/new/download.html#linux">bt.cn</a>。</p>
</blockquote>
<h4 id="修改数据库排序规则"><a class="header-anchor" href="#修改数据库排序规则">¶</a>修改数据库排序规则</h4>
<p>点击数据库右侧的管理，进入<code>phpMyadmin</code>，执行如下SQL语句。将<code>数据库名</code>替换为刚刚创建的数据库。如果没有安装<code>phpMyadmin</code>，可以在软件商店搜索安装。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database 数据库名 <span class="keyword">default</span> <span class="keyword">collate</span> utf8_bin;</span><br></pre></td></tr></table></figure>
<h4 id="修改数据库隔离级别"><a class="header-anchor" href="#修改数据库隔离级别">¶</a>修改数据库隔离级别</h4>
<p>在宝塔面板进入mysql的设置页面，选中左侧的配置修改，在<code>[mysqld]</code>下添加配置<code>transaction-isolation=READ-COMMITTED</code>。保存并重启mysql。</p>
<img src="http://image.pkemb.com/image/202303191730559.png" width="70%">
<h3 id="安装confluence"><a class="header-anchor" href="#安装confluence">¶</a>安装confluence</h3>
<p>进入<a href="https://www.atlassian.com/software/confluence/download-archives">download-archives</a>下载confluence。建议选择一个LTS版本。选择<code>Linux 64 Bit</code>，点击<code>Download</code>。</p>
<img src="http://image.pkemb.com/image/202303191645628.png" width="80%"/>
<p>下载到服务器后，用chmod添加可执行权限，切换到root用户执行安装包即可。安装目录与安装包所在的目录没有关系。第一步，选择<code>o</code>，确认安装。</p>
<p><img src="http://image.pkemb.com/image/202303191647490.png" alt=""></p>
<p>选择安装模式，1 默认安装，2 自定义安装，3 升级。这里选择1。</p>
<p><img src="http://image.pkemb.com/image/202303191649933.png" alt=""></p>
<p>最后一步，确认安装。这里给出了几个重要的信息。配置信息和附件都存储在家目录。等待安装完成，服务启动。</p>
<blockquote>
<p>安装目录：/opt/atlassian/confluence<br>
家目录：/var/atlassian/application-data/confluence<br>
HTTP端口：8090<br>
RMI端口：8080</p>
</blockquote>
<p><img src="http://image.pkemb.com/image/202303191650577.png" alt=""></p>
<h3 id="防火墙"><a class="header-anchor" href="#防火墙">¶</a>防火墙</h3>
<p>进入宝塔面板，点击左侧的安全，点击添加端口规则，放开8090端口。打开浏览器，输入<code>ip:8090</code>即可访问confluence。</p>
<img src="http://image.pkemb.com/image/202303191656106.png" width="60%"/>
<h3 id="破解"><a class="header-anchor" href="#破解">¶</a>破解</h3>
<h4 id="准备"><a class="header-anchor" href="#准备">¶</a>准备</h4>
<p>使用命令<code>systemctl stop confluence</code>停止服务。<br>
下载atlassian-agent.jar并上传到服务器的<code>/var/atlassian/application-data</code>目录，并将文件的所有者和所属组改成confluence。修改文件<code>/opt/atlassian/confluence/bin/setenv.sh</code>，在文件末尾添加以下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_OPTS=&quot;-javaagent:/var/atlassian/application-data/atlassian-agent.jar $&#123;JAVA_OPTS&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>使用命令<code>systemctl start confluence</code>启动服务。使用命令<code>systemctl status confluence</code>确认服务是否启动成功。如果启动失败，请检查<code>setenv.sh</code>文件是否有语法错误。</p>
<h4 id="生成序列号"><a class="header-anchor" href="#生成序列号">¶</a>生成序列号</h4>
<p>打开浏览器，输入<code>ip:8090</code>访问confluence，这里选择产品安装。</p>
<img src="http://image.pkemb.com/image/202303191710585.png" width="60%"/>
<p>获取应用，根据实际情况勾选。建议<strong>不要</strong>勾选。</p>
<img src="http://image.pkemb.com/image/202303191711249.png" width="60%"/>
<p>复制服务器ID。</p>
<img src="http://image.pkemb.com/image/202303191712147.png" width="60%"/>
<p>进入服务器命令行，使用如下命令生成序列号。相关参数需要替换成实际的值。将生成的序列号填入网页，点击下一步，即可完成破解。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/atlassian/application-data</span><br><span class="line">java -jar atlassian-agent.jar -p conf -m aaa@bbb.com -n my_name -o http://ip -s ABCD-1234-EFGH-5678</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p product, conf: confluence<br>
-m email<br>
-n name<br>
-o organisation<br>
-s server id</p>
</blockquote>
<h3 id="连接mysql数据库"><a class="header-anchor" href="#连接mysql数据库">¶</a>连接mysql数据库</h3>
<p>数据库选择mysql，由于缺少mysql驱动，这里需要到<a href="https://dev.mysql.com/downloads/connector/j/5.1.html">dev.mysql.com</a>下载MySQL驱动程序。</p>
<p><img src="http://image.pkemb.com/image/202303191721407.png" alt=""></p>
<p>图示版本号确认是可以的。点击下载，将解压之后的<code>mysql-connector-java-8.0.22.jar</code>移动到<code>/opt/atlassian/confluence/confluence/WEB-INF/lib</code>目录。注意：将文件的所有者和所属组都更改为confluence。</p>
<p><img src="http://image.pkemb.com/image/202303191723854.png" alt=""></p>
<p><code>systemctl restart confluence</code>重启服务，重启好之后，刷新网页，填入<a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">创建数据库</a>步骤记录下来的信息。如果遇到如下两个错误，请检查<a href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99">修改数据库排序规则</a>和<a href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">修改数据库隔离级别</a>。</p>
<p><img src="http://image.pkemb.com/image/202303191725205.png" alt=""></p>
<p><img src="http://image.pkemb.com/image/202303191725684.png" alt=""></p>
<h3 id="完成安装"><a class="header-anchor" href="#完成安装">¶</a>完成安装</h3>
<p>数据库连接成功后，点击空白站点，完成安装。</p>
<img src="http://image.pkemb.com/image/202303191738365.png" width="60%"/>
<h2 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h2>
<h3 id="基本设置"><a class="header-anchor" href="#基本设置">¶</a>基本设置</h3>
<p>默认URL、邮件服务器等。</p>
<h3 id="破解插件"><a class="header-anchor" href="#破解插件">¶</a>破解插件</h3>
<p>遇到付费插件时，点击立即购买，然后点击接受&amp;安装。</p>
<img src="http://image.pkemb.com/image/202303191840728.png" width="70%"/>
<p>安装好之后进入插件的管理界面，复制应用密钥。然后使用下面的命令生成许可证。注意-p后面是接应用密钥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/atlassian/application-data</span><br><span class="line">java -jar atlassian-agent.jar -p com.mxgraph.confluence.plugins.diagramly -m aaa@bbb.com -n my_name -o http://ip -s ABCD-1234-EFGH-5678</span><br></pre></td></tr></table></figure>
<img src="http://image.pkemb.com/image/202303191841346.png" width="40%"/>
<h2 id="维护"><a class="header-anchor" href="#维护">¶</a>维护</h2>
<p>数据的备份与还原，迁移，以及软件升级。</p>
<h3 id="备份"><a class="header-anchor" href="#备份">¶</a>备份</h3>
<p>备份分为confluence备份和数据备份。</p>
<h4 id="confluence自动备份"><a class="header-anchor" href="#confluence自动备份">¶</a>confluence自动备份</h4>
<p>使用管理员账号进入<code>一般配置</code>，在<code>预定作业-&gt;备份系统</code>，编辑备份系统的日程表。</p>
<img src="http://image.pkemb.com/image/202303191749124.png" width="80%">
<p>点击左侧的<code>每日备份管理</code>，可以设置备份文件的文件名，是否备份附件，备份路径。务必确认<code>confluence</code>用户在备份路径有写入的权限，否则不会产生备份文件。</p>
<img src="http://image.pkemb.com/image/202303191750111.png" width="50%">
<p><strong>自定义备份路径</strong></p>
<p>默认备份路径不可以修改。如果需要自定义备份路径，修改文件<code>&lt;confluence-home&gt;/confluence.cfg.xml</code>，将以下内容修改为<code>true</code>，重启confluence服务即可修改备份路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property name=&quot;admin.ui.allow.daily.backup.custom.location&quot;&gt;true&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<h4 id="confluence手工备份"><a class="header-anchor" href="#confluence手工备份">¶</a>confluence手工备份</h4>
<p>进入一般配置，点击左侧的<code>备份与还原</code>，可以手工导出整个网站。</p>
<img src="http://image.pkemb.com/image/202303191828819.png" width="60%"/>
<h4 id="数据库备份"><a class="header-anchor" href="#数据库备份">¶</a>数据库备份</h4>
<p>数据库备份借助宝塔的定时任务完成。</p>
<img src="http://image.pkemb.com/image/202303191755174.png" width="70%"/>
<h3 id="还原"><a class="header-anchor" href="#还原">¶</a>还原</h3>
<h4 id="confluence还原"><a class="header-anchor" href="#confluence还原">¶</a>confluence还原</h4>
<p>假如confluence奔溃了，无法访问了。停止confluence服务。将家目录<code>/var/atlassian/application-data/confluence</code>移动为<code>/var/atlassian/application-data/confluence.bak</code>，启动confluence服务。由于家目录为空，访问confluence会重新进入配置流程，进入到下图所示的步骤时，选择<code>从备份还原站点</code>。</p>
<p><img src="http://image.pkemb.com/image/202303191738365.png" alt=""></p>
<h4 id="数据库还原"><a class="header-anchor" href="#数据库还原">¶</a>数据库还原</h4>
<p>宝塔的数据库管理页面，以及phpmyadmin均可以导入数据包备份文件并还原。</p>
<h3 id="迁移"><a class="header-anchor" href="#迁移">¶</a>迁移</h3>
<p>可以参考官方文档<a href="https://confluence.atlassian.com/doc/migrating-confluence-between-servers-184150.html">Migrating Confluence Between Servers</a>。翻译如下：</p>
<ol>
<li>在新服务器安装confluce</li>
<li>旧服务器和新服务器都停止confluence服务</li>
<li>复制mysql驱动到新服务器</li>
<li>删除新服务器的家目录，拷贝旧服务器的家目录到新服务器</li>
<li>一些其他的必要修改</li>
<li><code>&lt;confluence-install&gt;/conf/server.xml</code>从旧服务器复制到新服务器</li>
<li>配置数据库连接</li>
<li>新服务器启动服务，进入一般设置，添加license。</li>
</ol>
<p>官方给的步骤可以确保<code>server id</code>不变，所以这么复杂。由于是破解版，所以<code>server id</code>变了也没关系，重新生成一个即可。步骤可以简化为：</p>
<ol>
<li>旧服务器强制触发一次备份</li>
<li>在新服务器安装</li>
<li>最后一步选择从备份文件还原</li>
</ol>
<h3 id="升级"><a class="header-anchor" href="#升级">¶</a>升级</h3>
<p>进入一般配置，点击左侧的<code>升级规划</code>，可以下载升级步骤，按照步骤操作即可。建议升级之前，进入<code>定时任务</code>，强制执行一次备份。如果服务器是虚拟机，也可以拍一个快照。</p>
<img src="http://image.pkemb.com/image/202303191831525.png" width="70%"/>
]]></content>
  </entry>
  <entry>
    <title>记一次解决域名解析为127.0.0.1</title>
    <url>/2023/07/fix-domain-resolve-to-localhost/</url>
    <content><![CDATA[<p>又是一次自己坑自己。</p>
<span id="more"></span>
<h2 id="问题背景"><a class="header-anchor" href="#问题背景">¶</a>问题背景</h2>
<p>某天登录gitlab，卡在<code>检查站点连接是否安全</code>，不断的循环，怎么都无法进入到登录界面。经过一番搜索，也没有太多的帖子，没有找到解决方案。</p>
<img src="http://image.pkemb.com/image/202307072102821.png"/>
<p>既然如此，那就进开发者模式，看看网络请求。经过一番观察，发现<code>challenges.cloudflare.com</code>的请求总是返回<code>400</code>。无意之间，发现远程地址竟然是<strong>127.0.0.1:443</strong>！！！用<code>nslookup challenges.cloudflare.com</code>查询DNS解析，确实是127.0.0.1。</p>
<img src="http://image.pkemb.com/image/202307072109011.png"/>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器:  ax86u.inc</span><br><span class="line">Address:  192.168.50.1</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    challenges.cloudflare.com</span><br><span class="line">Addresses:  ::1</span><br><span class="line">          127.0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="尝试1：更换DNS服务器"><a class="header-anchor" href="#尝试1：更换DNS服务器">¶</a>尝试1：更换DNS服务器</h2>
<p>既然DNS解析错误，那就更换DNS服务器。在本机和路由器，把常见的DNS服务器试了一遍，解析结果一直都是<code>127.0.0.1</code>。在<code>nslookup</code>命令行参数指定DNS服务器，也都尝试了一遍，依旧没用。但是其他的域名没有问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\pk&gt;nslookup challenges.cloudflare.com 8.8.8.8</span><br><span class="line">服务器:  dns.google</span><br><span class="line">Address:  8.8.8.8</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    challenges.cloudflare.com</span><br><span class="line">Addresses:  ::1</span><br><span class="line">          127.0.0.1</span><br><span class="line"></span><br><span class="line">C:\Users\pk&gt;nslookup baidu.com 8.8.8.8</span><br><span class="line">服务器:  dns.google</span><br><span class="line">Address:  8.8.8.8</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    baidu.com</span><br><span class="line">Addresses:  110.242.68.66</span><br><span class="line">          39.156.66.10</span><br></pre></td></tr></table></figure>
<h2 id="尝试2：其他设备对比"><a class="header-anchor" href="#尝试2：其他设备对比">¶</a>尝试2：其他设备对比</h2>
<p>既然在本机和路由器修改DNS服务器没用，那就可能是ISP有问题？看看其他设备啥情况。结果如下表所示，看来不是ISP的问题。有问题的机器，要么是我的主机，要么主机的虚拟机。</p>
<table>
<thead>
<tr>
<th>No</th>
<th>设备</th>
<th>网络</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>手机</td>
<td>流量</td>
<td>OK</td>
</tr>
<tr>
<td>2</td>
<td>手机</td>
<td>局域网</td>
<td>OK</td>
</tr>
<tr>
<td>3</td>
<td>其他笔记本（物理机）</td>
<td>局域网</td>
<td>OK</td>
</tr>
<tr>
<td>4</td>
<td>Ubuntu虚拟机</td>
<td>局域网</td>
<td>NG</td>
</tr>
<tr>
<td>5</td>
<td>Win7 虚拟机</td>
<td>局域网</td>
<td>NG</td>
</tr>
<tr>
<td>6</td>
<td>有问题的主机</td>
<td>局域网</td>
<td>NG</td>
</tr>
</tbody>
</table>
<p>我的虚拟机都配置了两张网卡，一张桥接，直连路由器，一张NAT；并且NAT网卡的优先级高于桥接网卡。当停用桥接网卡后，依旧NG；<strong>当停用NAT网卡后，好了</strong>！！！看来问题在我的主机，应该是某个后台软件或服务在捣鬼。</p>
<h2 id="尝试3：抓包"><a class="header-anchor" href="#尝试3：抓包">¶</a>尝试3：抓包</h2>
<p>既然有东西在捣鬼，那就抓包看看。打开Wireshark，选好网卡，过滤DNS包，在cmd多敲几次<code>nslookup challenges.cloudflare.com</code>，没有抓到。但是换个域名，就能看到DNS的数据包。看来还没走到网卡，DNS数据包就被劫持了。</p>
<h2 id="尝试4：procexp和tcpview"><a class="header-anchor" href="#尝试4：procexp和tcpview">¶</a>尝试4：procexp和tcpview</h2>
<p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">procexp</a>可以查看进程的详细信息，<a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/tcpview">tcpview</a>可以查看TCP和UDP连接信息。尝试通过这两个工具，来找出可疑的进程。可惜没有看到可疑的进程，也没有进程监听53端口。这个方法不行。</p>
<h2 id="尝试5：FastGithub"><a class="header-anchor" href="#尝试5：FastGithub">¶</a>尝试5：FastGithub</h2>
<p>使用工具无法定位到可疑进程，那就只好回忆，自己安装了什么和DNS有关系的软件或服务。还真想到了一个：<a href="https://github.com/dotnetcore/FastGithub">FastGithub</a>。在FastGihub的软件目录用grep搜索，发现了如下异常log。把FastGithub服务关闭后，果然<code>challenges.cloudflare.com</code>的DNS解析就正常了。仔细看log文件，也没发现把<code>challenges.cloudflare.com</code>解析为127.0.0.1的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logs/log20230707.txt:11391:challenges.cloudflare.com-&gt;127.0.0.1</span><br><span class="line">logs/log20230707.txt:11395:challenges.cloudflare.com-&gt;::1</span><br></pre></td></tr></table></figure>
<p>经过一番探索，在<code>appsettings/appsettings.dnspollution.json</code>发现了如下配置。把其他正常解析的域名加上类似的配置，重启服务后，也会解析为127.0.0.1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;*.cloudflare.com&quot;: &#123;</span><br><span class="line">  &quot;TlsSni&quot;: true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在issue列表搜索，有发现类似的问题，<a href="https://github.com/dotnetcore/FastGithub/issues/119">软件导致api.nuget.org 解析为127.0.0.1</a>，<a href="https://github.com/dotnetcore/FastGithub/issues/290">可能影响托管在Cloudflare DNS的域名</a>。解决方法就是删除相关节点。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>停止FastGithub服务后，访问github会很慢，甚至无响应。所以最终选择运行FastGithub服务，删除<code>cloudflare.com</code>的配置。</p>
]]></content>
  </entry>
  <entry>
    <title>seccomp</title>
    <url>/2023/09/seccomp/</url>
    <content><![CDATA[<p>最近遇到了一个和<code>seccomp</code>相关的问题，但还不清楚是什么，学习一下。</p>
<span id="more"></span>
<h2 id="概要"><a class="header-anchor" href="#概要">¶</a>概要</h2>
<p><code>seccomp</code>是Linux kernel的一种计算安全机制，让进程只能够执行指定的系统调用。如果尝试执行不允许执行的系统调用，则程序会收到<code>SIGKILL</code>或<code>SIGSYS</code>信号。可以通过系统调用<code>prctl(2)</code>使用参数<code>PR_SET_SECCOMP</code>，或系统调用<code>seccomp(2)</code>开启<code>seccomp</code>模式。<code>seccomp</code>有两种模式，分别是严格模式<code>SECCOMP_MODE_STRICT</code>和过滤模式<code>SECCOMP_MODE_FILTER</code>。</p>
<p><code>OpenSSH</code>、<code>vsftpd</code>、<code>Chrome/Chromium</code>、<code>Docker</code>等项目使用了<code>seccomp</code>。</p>
<h2 id="严格模式-SECCOMP-MODE-STRICT"><a class="header-anchor" href="#严格模式-SECCOMP-MODE-STRICT">¶</a>严格模式 SECCOMP_MODE_STRICT</h2>
<p>严格模式只允许调用<code>read(2)</code>、<code>write(2)</code>、<code>_exit(2)</code>（不包括<code>exit_group(2)</code>）和<code>sigreturn(2)</code>。其他的系统调用会导致调用的线程退出，但进程只有一个线程时，整个程序会因为<code>SIGKILL</code>终止。严格模式对于数字处理应用程序非常有用，可能需要执行从管道或套接字读取的不受信任的字节码。</p>
<p>需要注意的是，调用线程不能够再调用<code>sigprocmask(2)</code>，但可以使用<code>sigreturn(2)</code>阻塞除<code>SIGKILL</code>和<code>SIGSTOP</code>外的所有信号。这意味着<code>alarm(2)</code>（举例）不能用于限制程序的执行时间。此外，为了确保能终止程序，必须使用<code>SIGKILL</code>。通过向<code>timer_create(2)</code>传递<code>SIGEV_SIGNAL</code>参数，并且<code>sigev_signo</code>设置为<code>SIGKILL</code>可以完成这个。或者使用<code>setrlimit(2)</code>设置<code>RLIMIT_CPU</code>的硬限制。</p>
<p>使用如下代码开启严格模式。如果使用<code>seccomp(2)</code>，第二个参数<code>flags</code>必须为0，第三个参数<code>args</code>必须为NULL。kernel配置需要打开<code>CONFIG_SECCOMP</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">syscall(SYS_seccomp, SECCOMP_SET_MODE_STRICT, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);</span><br></pre></td></tr></table></figure>
<h2 id="过滤模式-SECCOMP-MODE-FILTER"><a class="header-anchor" href="#过滤模式-SECCOMP-MODE-FILTER">¶</a>过滤模式 SECCOMP_MODE_FILTER</h2>
<p>允许使用<code>BPF</code>过滤系统调用，相比严格模式，更加灵活。</p>
<p>待完善。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Seccomp">wikipedia seccomp</a></li>
<li><a href="https://docs.kernel.org/userspace-api/seccomp_filter.html">docs.kernel.org seccomp_filter</a>
<ul>
<li><a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/userspace-api/seccomp_filter.html">seccomp_filter中文翻译</a></li>
</ul>
</li>
<li><a href="https://man7.org/linux/man-pages/man2/seccomp.2.html">seccomp(2)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/363174561">https://zhuanlan.zhihu.com/p/363174561</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Jenkins流水线</title>
    <url>/2023/12/jenkins-pipeline/</url>
    <content><![CDATA[<p>记录一下折腾Jenkins流水线过程中的一些笔记和心得。相比于自由风格任务，Jenkins流水线用代码来描述任务，并且支持从SCM中拉取代码，这样可以更快速的部署新任务，并对任务代码做版本控制。</p>
<span id="more"></span>
<h2 id="Jenkins官方文档"><a class="header-anchor" href="#Jenkins官方文档">¶</a>Jenkins官方文档</h2>
<p>主要参考内容是Jenkins官方文档。有中文版本，但汉化的不全，汉化版本可能也缺少内容。建议英文和中文配合一起看。刚开始对语法还不熟时，可以多看看<a href="https://www.jenkins.io/doc/book/pipeline/syntax/">流水线语法</a>。</p>
<table>
<thead>
<tr>
<th>文档</th>
<th>英文版</th>
<th>中文版</th>
</tr>
</thead>
<tbody>
<tr>
<td>流水线入门</td>
<td><a href="https://www.jenkins.io/doc/book/pipeline/getting-started/">getting-started</a></td>
<td><a href="https://www.jenkins.io/zh/doc/book/pipeline/getting-started/">getting-started</a></td>
</tr>
<tr>
<td>流水线语法</td>
<td><a href="https://www.jenkins.io/doc/book/pipeline/syntax/">syntax</a></td>
<td><a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/">syntax</a></td>
</tr>
<tr>
<td>git插件</td>
<td><a href="https://www.jenkins.io/doc/pipeline/steps/git/">git</a></td>
<td><a href="https://www.jenkins.io/zh/doc/pipeline/steps/git/">git</a></td>
</tr>
<tr>
<td>Email Extension</td>
<td><a href="https://www.jenkins.io/doc/pipeline/steps/email-ext/">email-ext</a></td>
<td><a href="https://www.jenkins.io/zh/doc/pipeline/steps/email-ext/">email-ext</a></td>
</tr>
</tbody>
</table>
<h2 id="代码生成器"><a class="header-anchor" href="#代码生成器">¶</a>代码生成器</h2>
<p>Jenkins提供了<a href="https://www.jenkins.io/zh/doc/book/pipeline/getting-started/#snippet-generator">片段生成器</a>和<a href="https://www.jenkins.io/zh/doc/book/pipeline/getting-started/#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8C%87%E4%BB%A4%E7%94%9F%E6%88%90%E5%99%A8">声明式指令生成器</a>。在刚开始对语法还不是很熟悉的时候，这两个工具非常有用。</p>
<h3 id="片段生成器"><a class="header-anchor" href="#片段生成器">¶</a>片段生成器</h3>
<blockquote>
<p>内置的“片段生成器”工具有助于为各个步骤创建代码段，发现插件提供的新步骤，或者为特定的步骤尝试不同的参数。</p>
<p>片段生成器由 Jenkins 实例中可用的步骤动态添加。可用的步骤的数量依赖于安装的插件，这些插件显式地公开了流水线中使用的步骤。</p>
<p>要使用代码生成器生成一个步骤的片段：</p>
<ol>
<li>从已配置好的流水线导航到 流水线语法 链接（见上），或访问 <code>$&#123;YOUR_JENKINS_URL&#125;/pipeline-syntax</code>。</li>
<li>在 示例步骤 下拉菜单中选择需要的步骤。</li>
<li>使用 示例步骤 下拉菜单的动态填充区来配置已选的步骤。</li>
<li>点击 生成流水线脚本 生成一个能够被复制并粘贴到流水线中的流水线片段。<br>
<img src="https://www.jenkins.io/zh/doc/book/resources/pipeline/snippet-generator.png" alt=""></li>
</ol>
</blockquote>
<h3 id="声明式指令生成器"><a class="header-anchor" href="#声明式指令生成器">¶</a>声明式指令生成器</h3>
<blockquote>
<p>片段生成器可以帮助生成脚本式流水线的步骤或者声明式流水线的 stage 中的 steps 代码块，但是其并没有包含用于定义声明式流水线的 section（节段）和 directive（指令）。声明式指令生成器（Declarative Directive Generator）这个工具可以做到这点。和 片段生成器类似，指令生成器允许你选择声明式的指令，对其以一种方式进行配置，然后生成这个指令的配置，让你将其用于声明式流水线。</p>
<p>要使用声明式指令生成器生成一个声明式的指令：</p>
<ol>
<li>从已配置好的流水线导航到 Pipeline Syntax/流水线语法 链接（见上），然后点击侧栏的 Declarative Directive Generator，或直接访问 <code>$&#123;YOUR_JENKINS_URL&#125;/directive-generator</code>。</li>
<li>在下拉菜单中选择需要的指令。</li>
<li>使用下拉菜单下面动态生成的区域配置已选的指令。</li>
<li>点击 Generate Declarative Directive 生成一个能够被复制到流水线中的指令配置。</li>
</ol>
</blockquote>
<h2 id="流水线模板"><a class="header-anchor" href="#流水线模板">¶</a>流水线模板</h2>
<p>根据自己调试流水线的经验，和实际的需要，写了一个模板。包含环境变量、选项、触发器、stage以及构建失败的邮件发送。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        ENV1 = <span class="string">&#x27;value1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options &#123;</span><br><span class="line">        timestamps()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    triggers &#123;</span><br><span class="line">        cron <span class="string">&#x27;H 21 * * *&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;clean-ws&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                deleteDir()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;stage2&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// xxx</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        unsuccessful &#123;</span><br><span class="line">            emailext (</span><br><span class="line">                <span class="symbol">attachLog:</span> <span class="literal">true</span>,</span><br><span class="line">                <span class="symbol">body:</span> <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">                <span class="symbol">compressLog:</span> <span class="literal">true</span>,</span><br><span class="line">                <span class="symbol">subject:</span> <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">                <span class="symbol">to:</span> <span class="string">&#x27;xxx@xxx.com&#x27;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="常用代码块"><a class="header-anchor" href="#常用代码块">¶</a>常用代码块</h2>
<h3 id="环境变量"><a class="header-anchor" href="#环境变量">¶</a>环境变量</h3>
<p><code>environment</code> 指令可以设置全局变量或局部变量。放在<code>pipeline</code>下面是全局变量，放在<code>stage</code>下面是局部变量。如下是官方文档给的示例，<code>CC</code>是一个全局环境变量。<code>AN_ACCESS_KEY</code>是一个局部变量。参考<a href="https://www.jenkins.io/doc/book/pipeline/syntax/#environment">environment</a>。</p>
<p>在shell指令中，直接使用<code>$ENVNAME</code>引用环境变量。在<code>echo</code>指令中，使用<code>$env.ENVNAME</code>引用环境变量，且必须用双引号。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        CC = <span class="string">&#x27;clang&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                AN_ACCESS_KEY = credentials(<span class="string">&#x27;my-predefined-secret-text&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;printenv&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;echo $CC, $AN_ACCESS_KEY&#x27;</span> <span class="comment">//shell直接 $ 引用变量，双引号和单引号都可以</span></span><br><span class="line">                echo <span class="string">&quot;$env.CC&quot;</span> <span class="comment">// echo 指令需要使用 $env. 引用变量，必须用双引号。单引号不会解析变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选项"><a class="header-anchor" href="#选项">¶</a>选项</h3>
<p><code>options</code>指令可以控制流水线的形为。文档<a href="https://www.jenkins.io/doc/book/pipeline/syntax/#options">options</a>。可以借助<a href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8C%87%E4%BB%A4%E7%94%9F%E6%88%90%E5%99%A8">声明式指令生成器</a>来自动生成相关代码。<code>options</code>指令需要放在<code>pipeline</code>的下面。</p>
<img src="http://image.pkemb.com/image/202312102149496.png"/>
<p>官方示例。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    options &#123;</span><br><span class="line">        timeout(<span class="attr">time:</span> <span class="number">1</span>, <span class="attr">unit:</span> <span class="string">&#x27;HOURS&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="触发器"><a class="header-anchor" href="#触发器">¶</a>触发器</h3>
<p><code>triggers</code>指令用于定义流水线自动运行的方式。可以周期性定时运行，也可以外部事件触发运行，例如有代码提交到<code>Gerrit</code>。同样可以借助<a href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8C%87%E4%BB%A4%E7%94%9F%E6%88%90%E5%99%A8">声明式指令生成器</a>来自动生成相关代码。参考<a href="https://www.jenkins.io/doc/book/pipeline/syntax/#triggers">triggers</a>。<code>triggers</code>指令需要放在<code>pipeline</code>的下面。</p>
<img src="http://image.pkemb.com/image/202312102150099.png"/>
<p>官方示例。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        cron(<span class="string">&#x27;H */4 * * 1-5&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h3>
<p><code>parameters</code>指令定义了一个参数列表，在触发流水线任务的时候需要提供这些参数。参考<a href="https://www.jenkins.io/doc/book/pipeline/syntax/#parameters">parameters</a>。可以借助<a href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8C%87%E4%BB%A4%E7%94%9F%E6%88%90%E5%99%A8">声明式指令生成器</a>来自动生成相关代码。<code>parameters</code>指令需要放在<code>pipeline</code>的下面。</p>
<img src="http://image.pkemb.com/image/202312102156295.png"/>
<p>下面是一个官方的示例。在shell中，直接使用<code>$PARAMNAME</code>引用参数，在<code>echo</code>指令中，使用<code>$params.PARAMNAME</code>引用参数，且必须是双引号。</p>
<blockquote>
<p>需要注意的是，如果修改了参数的配置，用旧的参数列表跑一次后，再跑一次才会是新的参数列表。</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="attr">name:</span> <span class="string">&#x27;PERSON&#x27;</span>, <span class="attr">defaultValue:</span> <span class="string">&#x27;Mr Jenkins&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;Who should I say hello to?&#x27;</span>)</span><br><span class="line">        text(<span class="attr">name:</span> <span class="string">&#x27;BIOGRAPHY&#x27;</span>, <span class="attr">defaultValue:</span> <span class="string">&#x27;&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;Enter some information about the person&#x27;</span>)</span><br><span class="line">        booleanParam(<span class="attr">name:</span> <span class="string">&#x27;TOGGLE&#x27;</span>, <span class="attr">defaultValue:</span> <span class="literal">true</span>, <span class="attr">description:</span> <span class="string">&#x27;Toggle this value&#x27;</span>)</span><br><span class="line">        choice(<span class="attr">name:</span> <span class="string">&#x27;CHOICE&#x27;</span>, <span class="attr">choices:</span> [<span class="string">&#x27;One&#x27;</span>, <span class="string">&#x27;Two&#x27;</span>, <span class="string">&#x27;Three&#x27;</span>], <span class="attr">description:</span> <span class="string">&#x27;Pick something&#x27;</span>)</span><br><span class="line">        password(<span class="attr">name:</span> <span class="string">&#x27;PASSWORD&#x27;</span>, <span class="attr">defaultValue:</span> <span class="string">&#x27;SECRET&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;Enter a password&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;Hello $&#123;params.PERSON&#125;&quot;</span></span><br><span class="line">                echo <span class="string">&quot;Biography: $&#123;params.BIOGRAPHY&#125;&quot;</span></span><br><span class="line">                echo <span class="string">&quot;Toggle: $&#123;params.TOGGLE&#125;&quot;</span></span><br><span class="line">                echo <span class="string">&quot;Choice: $&#123;params.CHOICE&#125;&quot;</span></span><br><span class="line">                echo <span class="string">&quot;Password: $&#123;params.PASSWORD&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="post"><a class="header-anchor" href="#post">¶</a>post</h3>
<p><code>post</code>段定义了一个或多个步骤，在<code>stages</code>运行完之后运行。可以根据不同的条件运行不同的步骤。例如构建失败发送邮件。参考<a href="https://www.jenkins.io/doc/book/pipeline/syntax/#post">post</a>。<code>post</code>块需要放在<code>pipeline</code>的下面。可以借助<a href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8C%87%E4%BB%A4%E7%94%9F%E6%88%90%E5%99%A8">声明式指令生成器</a>来自动生成相关代码。<code>post</code>块支持多种条件块，如下表所示。</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>Always run, regardless of build status</td>
</tr>
<tr>
<td>changed</td>
<td>Run if the current builds status is different than the previous builds status</td>
</tr>
<tr>
<td>fixed</td>
<td>Run if the previous build was not successful and the current builds status is “Success”</td>
</tr>
<tr>
<td>regression</td>
<td>Run if the current builds status is worse than the previous builds status</td>
</tr>
<tr>
<td>aborted</td>
<td>Run when the build status is “Aborted”</td>
</tr>
<tr>
<td>failure</td>
<td>Run if the build status is “Failure”</td>
</tr>
<tr>
<td>success</td>
<td>Run if the build status is “Success” or hasnt been set yet</td>
</tr>
<tr>
<td>unstable</td>
<td>Run if the build status is “Unstable”</td>
</tr>
<tr>
<td>unsuccessful</td>
<td>Run if the current builds status is “Aborted”, “Failure” or “Unstable”</td>
</tr>
<tr>
<td>cleanup</td>
<td>Always run after all other conditions, regardless of build status</td>
</tr>
<tr>
<td>notBuilt</td>
<td>Run if the build status is “Not Built”</td>
</tr>
</tbody>
</table>
<p>示例如下。在官方示例的基础上加了一个<code>unsuccessful</code>，表示在构建终止、失败或不稳定时发送邮件。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Example&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            echo <span class="string">&#x27;I will always say Hello again!&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        unsuccessful &#123;</span><br><span class="line">            emailext (</span><br><span class="line">                <span class="symbol">attachLog:</span> <span class="literal">true</span>,</span><br><span class="line">                <span class="symbol">body:</span> <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">                <span class="symbol">compressLog:</span> <span class="literal">true</span>,</span><br><span class="line">                <span class="symbol">subject:</span> <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">                <span class="symbol">to:</span> <span class="string">&#x27;xxx@xxx.com&#x27;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邮件"><a class="header-anchor" href="#邮件">¶</a>邮件</h3>
<p><code>jenkins</code>自带的<code>mail</code>指令提供了基本的邮件发送功能。可以通过<a href="#%E7%89%87%E6%AE%B5%E7%94%9F%E6%88%90%E5%99%A8">片段生成器</a>生成相关代码。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">mail(</span><br><span class="line">    <span class="symbol">bcc:</span> <span class="string">&#x27;密送&#x27;</span>,</span><br><span class="line">    <span class="symbol">body:</span> <span class="string">&#x27;正文&#x27;</span>,</span><br><span class="line">    <span class="symbol">cc:</span> <span class="string">&#x27;抄送&#x27;</span>,</span><br><span class="line">    <span class="symbol">from:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="symbol">replyTo:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="symbol">subject:</span> <span class="string">&#x27;主题&#x27;</span>,</span><br><span class="line">    <span class="symbol">to:</span> <span class="string">&#x27;收件人&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<img src="http://image.pkemb.com/image/202312102236441.png"/>
<p><a href="https://plugins.jenkins.io/email-ext/">Email Extension</a> 插件提供了更多的功能。安装插件后，可以在<a href="#%E7%89%87%E6%AE%B5%E7%94%9F%E6%88%90%E5%99%A8">片段生成器</a>找到<code>emailext</code>。</p>
<p>另外，发送邮件还需要在<code>系统管理 -&gt; 系统配置</code>中设置邮件服务器和发件人。</p>
<h3 id="错误捕获"><a class="header-anchor" href="#错误捕获">¶</a>错误捕获</h3>
<p>可以通过<code>catchError</code>指令捕获错误，进行一些错误处理或忽略错误。如下示例所示，如果没有新的commit，<code>git push</code>指令会失败，但这个错误其实是可以忽略的。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;push&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                catchError(<span class="attr">buildResult:</span> <span class="string">&#x27;SUCCESS&#x27;</span>, <span class="attr">message:</span> <span class="string">&#x27;push 失败&#x27;</span>) &#123;</span><br><span class="line">                    sh <span class="string">&#x27;git push origin HEAD:refs/for/master&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以通过<a href="#%E7%89%87%E6%AE%B5%E7%94%9F%E6%88%90%E5%99%A8">片段生成器</a>生成相关代码。</p>
<img src="http://image.pkemb.com/image/202312102252897.png"/>
<h3 id="克隆代码仓库"><a class="header-anchor" href="#克隆代码仓库">¶</a>克隆代码仓库</h3>
<p>在<a href="#%E7%89%87%E6%AE%B5%E7%94%9F%E6%88%90%E5%99%A8">片段生成器</a>使用<code>git</code>或<code>checkout</code>生成克隆代码仓库的指令。<code>checkout</code>支持的选项更多，且支持更多的代码仓库。</p>
<img src="http://image.pkemb.com/image/202312102302695.png"/>
<img src="http://image.pkemb.com/image/202312102303978.png"/>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
  </entry>
  <entry>
    <title>POSIX消息队列</title>
    <url>/2023/12/posix-message-queues/</url>
    <content><![CDATA[<p>POSIX消息队列允许进程以消息的形式交换数据，与System V消息队列不同，但提供了类似的功能。</p>
<span id="more"></span>
<h2 id="使用条件"><a class="header-anchor" href="#使用条件">¶</a>使用条件</h2>
<p>若想使用POSIX消息队列，kernel需要打开配置<code>CONFIG_POSIX_MQUEUE</code>（默认情况是打开的）。编译程序时需要加上<code>-lrt</code>参数。</p>
<h2 id="使用方法"><a class="header-anchor" href="#使用方法">¶</a>使用方法</h2>
<h3 id="打开或创建消息队列"><a class="header-anchor" href="#打开或创建消息队列">¶</a>打开或创建消息队列</h3>
<p>使用<a href="https://www.man7.org/linux/man-pages/man3/mq_open.3.html">mq_open()</a>创建或打开一个消息队列，这个函数会返回一个消息队列描述符（<code>mdq_t</code>），之后的函数调用会使用到这个描述符。返回<code>-1</code>表示打开失败，错误原因可以通过<code>errno</code>获取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;fcntl.h&gt;           /* For O_* constants */</span><br><span class="line">#include &lt;sys/stat.h&gt;        /* For mode constants */</span><br><span class="line">#include &lt;mqueue.h&gt;</span><br><span class="line"></span><br><span class="line">mqd_t mq_open(const char *name, int oflag);</span><br><span class="line">mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);</span><br></pre></td></tr></table></figure>
<p>消息队列使用参数<code>name</code>标识，其格式为<code>/somename</code>。<code>name</code>是一个以空字符结尾、长度不大于<code>NAME_MAX</code>（i.e., 255）的字符串，以斜线<code>/</code>开头，后续是一个或多个不是斜线的字符。若两个进程需要操作同一个消息队列，需要使用相同的<code>name</code>。</p>
<p><code>oflag</code>参数用于控制函数的动作，与<code>open()</code>函数的标志位非常类似。</p>
<ul>
<li>O_RDONLY 只从消息队列中接收数据</li>
<li>O_WRONLY 只发送数据到消息队列中</li>
<li>O_RDWR 发送和接收数据</li>
<li>O_CLOEXEC</li>
<li>O_CREAT 如果消息队列不存在，则创建</li>
<li>O_EXCL 如果指定了O_CREATE且消息队列存在，则返回错误 EEXIST</li>
<li>O_NONBLOCK</li>
</ul>
<p><code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code> 这三个只能指定一个，且必须指定一个，其余标志可以指定0个或多个，通过位或运算拼接。如果指定了<code>O_CREATE</code>，还需要指定<code>mode</code>和<code>attr</code>参数。</p>
<p><code>mode</code>参数用于指定消息队列的权限。</p>
<p><code>attr</code>参数是<code>struct mq_attr</code>结构体指针。<code>mq_open()</code>只会使用<code>mq_maxmsg</code>和<code>mq_msgsize</code>，忽略其他的值。如果<code>attr</code>是NULL，则会使用默认值。后面会介绍默认值。</p>
<p><code>mq_maxmsg</code>指消息队列最多能存储多少个消息。<code>mq_msgsize</code>指每个消息的最大大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct mq_attr &#123;</span><br><span class="line">    long mq_flags;       /* Flags (ignored for mq_open()) */</span><br><span class="line">    long mq_maxmsg;      /* Max. # of messages on queue */</span><br><span class="line">    long mq_msgsize;     /* Max. message size (bytes) */</span><br><span class="line">    long mq_curmsgs;     /* # of messages currently in queue</span><br><span class="line">                            (ignored for mq_open()) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>消息队列描述符本质上是一个文件描述符。所以文件描述符的特性也适用于消息队列描述符。例如<code>fork()</code>后，子进程会继承父进程的消息队列描述符，且指向同一个消息队列。</p>
</blockquote>
<h3 id="发送消息"><a class="header-anchor" href="#发送消息">¶</a>发送消息</h3>
<p>使用<a href="https://www.man7.org/linux/man-pages/man3/mq_send.3.html">mq_send()</a>发送消息到消息队列。参数<code>mqdes</code>是消息队列描述符，表示消息将要发送到的队列。<code>msg_ptr</code>是指向消息的指针，其长度是<code>msg_len</code>，长度必须小于或等于消息队列的<code>mq_msqsize</code>属性。<code>msg_prio</code>是一个非负整数，用于表示消息的优先级。消息在队列中按照优先级降序排序，同优先级的消息放在旧消息的后面。</p>
<p>如果队列已经满了（消息数量等于队列的<code>mq_maxmsg</code>属性），<code>mq_send()</code>会一直阻塞直到有足够的空间放入消息，或被信号中断。如果消息队列使能了<code>O_NONBLOCK</code>标志，调用会立即返回错误<code>EAGAIN</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_send</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> msg_ptr[.msg_len],</span></span><br><span class="line"><span class="params">            <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> msg_prio)</span>;</span><br></pre></td></tr></table></figure>
<p><code>mq_timedsend()</code>的行为类似于<code>mq_send()</code>。消息队列满了并且<code>O_NONBLOCK</code>标志没有使能的情况下，<code>abs_timeout</code>表示调用会阻塞多久。值是从<code>1970-01-01 00:00:00 +0000 (UTC)</code>开始的绝对时间，以秒和纳秒为单位。如果消息队列已满并且调用时已经超时，会立即返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_timedsend</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> msg_ptr[.msg_len],</span></span><br><span class="line"><span class="params">                <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> msg_prio,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure>
<p>成功发送消息，<code>mq_send()</code>和<code>mq_timedsend()</code>返回<code>0</code>。如果有错误则返回<code>-1</code>，<code>errno</code>表示错误。</p>
<blockquote>
<p>每个消息都会关联一个优先级，并且高优先级消息会被优先发送给接收进程。消息优先级的范围是从 0（低）到<code>sysconf(_SC_MQ_PRIO_MAX)-1</code>（高）。在Linux操作系统，<code>sysconf(_SC_MQ_PRIO_MAX)</code> 返回 32768。POSIX.1只要求实现0~31。</p>
</blockquote>
<h3 id="接收消息"><a class="header-anchor" href="#接收消息">¶</a>接收消息</h3>
<p>使用<a href="https://www.man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive()</a>从消息队列接收消息。<code>mq_receive()</code>移除消息队列<code>mqdes</code>中优先级最高、时间最久的消息，并将消息放到<code>msg_ptr</code>指向的缓存区，<code>msg_len</code>指定了缓冲区的长度，其值必须大于或等于消息队列的<code>mq_msgsize</code>属性。如果<code>msg_prio</code>不是NULL，那么用于返回接收到消息的优先级。</p>
<p>如果队列是空的，默认情况下，<code>mq_receive()</code>会一直阻塞直到有消息可用，或被信号中断。如果消息队列使能了<code>O_NONBLOCK</code>标志，调用会立即返回错误<code>EAGAIN</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mq_receive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> msg_ptr[.msg_len],</span></span><br><span class="line"><span class="params">                    <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> *msg_prio)</span>;</span><br></pre></td></tr></table></figure>
<p><code>mq_timedreceive()</code>的行为类似于<code>mq_receive()</code>。消息队列为空并且<code>O_NONBLOCK</code>标志没有使能的情况下，<code>abs_timeout</code>表示调用会阻塞多久。值是从<code>1970-01-01 00:00:00 +0000 (UTC)</code>开始的绝对时间，以秒和纳秒为单位。如果消息队列为空并且调用时已经超时，会立即返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mq_timedreceive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> *<span class="keyword">restrict</span> msg_ptr[.msg_len],</span></span><br><span class="line"><span class="params">                    <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> *<span class="keyword">restrict</span> msg_prio,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abs_timeout)</span>;</span><br></pre></td></tr></table></figure>
<p>成功接收消息，<code>mq_receive()</code>和<code>mq_timedreceive()</code>返回<code>0</code>。如果有错误则返回<code>-1</code>，<code>errno</code>表示错误。</p>
<h3 id="关闭消息队列"><a class="header-anchor" href="#关闭消息队列">¶</a>关闭消息队列</h3>
<p>当进程不再使用消息队列时，可以使用<a href="https://www.man7.org/linux/man-pages/man3/mq_close.3.html">mq_close()</a>关闭消息队列。</p>
<p>如果调用进程为消息队列注册了通知请求，那么通知请求会被移除。同时其他的进程就可以注册通知请求了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_close</span><span class="params">(<span class="type">mqd_t</span> mqdes)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>mq_close()</code>只是为当前进程关闭消息队列，其他进程的消息队列可能还处于打开的状态。</p>
</blockquote>
<h3 id="删除消息队列"><a class="header-anchor" href="#删除消息队列">¶</a>删除消息队列</h3>
<p>当不需要消息队列的时候，可以使用<a href="https://www.man7.org/linux/man-pages/man3/mq_unlink.3.html">mq_unlink()</a>移除指定的消息队列<code>name</code>。消息队列名字会立即移除。消息队列本身会在所有引用队列的描述符关闭后销毁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果只是用<code>mq_close</code>关闭消息队列，而没有调用<code>mq_unlink()</code>删除消息队列，那么消息队列会一直存在系统中，直到系统关闭。</p>
</blockquote>
<h2 id="消息队列属性"><a class="header-anchor" href="#消息队列属性">¶</a>消息队列属性</h2>
<p>使用<a href="https://www.man7.org/linux/man-pages/man3/mq_getattr.3.html">mq_getattr()</a>获取消息队列属性，使用<a href="https://www.man7.org/linux/man-pages/man3/mq_getattr.3.html">mq_setatrr()</a>设置消息队列属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_getattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="keyword">struct</span> mq_attr *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_setattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="keyword">struct</span> mq_attr *<span class="keyword">restrict</span> newattr,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> mq_attr *<span class="keyword">restrict</span> oldattr)</span>;</span><br></pre></td></tr></table></figure>
<p>消息队列属性是一个<code>struct mq_attr</code>结构体。<code>mq_flags</code>字段包含打开消息队列时关联的标志，这个字段只会出现标志<code>O_NONBLOCK</code>。</p>
<p><code>mq_maxmsg</code>和<code>mq_msgsize</code>字段可以在使用<code>mq_open()</code>打开消息队列时设置。</p>
<p><code>mq_maxmsg</code>字段是消息数量的上限。<code>mq_msgsize</code>字段是消息大小的的上限。这两个字段的值必须大于0。在使用<code>mq_open()</code>打开消息队列的时候会设置这两个字段。</p>
<p><code>mq_curmsgs</code>字段包含消息队列的消息数量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mq_flags;   <span class="comment">/* Flags: 0 or O_NONBLOCK */</span></span><br><span class="line">    <span class="type">long</span> mq_maxmsg;  <span class="comment">/* Max. # of messages on queue */</span></span><br><span class="line">    <span class="type">long</span> mq_msgsize; <span class="comment">/* Max. message size (bytes) */</span></span><br><span class="line">    <span class="type">long</span> mq_curmsgs; <span class="comment">/* # of messages currently in queue */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>mq_setattr()</code>使用<code>newattr</code>修改消息队列的属性。但只有<code>mq_flags</code>字段的<code>O_NONBLOCK</code>标志可以修改，其他字段会被忽略。如果<code>oldattr</code>不是NULL，用于返回消息队列修改之前的属性。</p>
<h2 id="异步通知"><a class="header-anchor" href="#异步通知">¶</a>异步通知</h2>
<p>TODO</p>
<p><a href="https://www.man7.org/linux/man-pages/man3/mq_notify.3.html">https://www.man7.org/linux/man-pages/man3/mq_notify.3.html</a></p>
<h2 id="库接口和系统调用"><a class="header-anchor" href="#库接口和系统调用">¶</a>库接口和系统调用</h2>
<table>
<thead>
<tr>
<th>Library interface</th>
<th>System call</th>
</tr>
</thead>
<tbody>
<tr>
<td>mq_close(3)</td>
<td>close(2)</td>
</tr>
<tr>
<td>mq_getattr(3)</td>
<td>mq_getsetattr(2)</td>
</tr>
<tr>
<td>mq_notify(3)</td>
<td>mq_notify(2)</td>
</tr>
<tr>
<td>mq_open(3)</td>
<td>mq_open(2)</td>
</tr>
<tr>
<td>mq_receive(3)</td>
<td>mq_timedreceive(2)</td>
</tr>
<tr>
<td>mq_send(3)</td>
<td>mq_timedsend(2)</td>
</tr>
<tr>
<td>mq_setattr(3)</td>
<td>mq_getsetattr(2)</td>
</tr>
<tr>
<td>mq_timedreceive(3)</td>
<td>mq_timedreceive(2)</td>
</tr>
<tr>
<td>mq_timedsend(3)</td>
<td>mq_timedsend(2)</td>
</tr>
<tr>
<td>mq_unlink(3)</td>
<td>mq_unlink(2)</td>
</tr>
</tbody>
</table>
<h2 id="proc接口"><a class="header-anchor" href="#proc接口">¶</a>/proc接口</h2>
<p>以下接口可用于限制POSIX消息队列使用的内存总量，设置新消息队列的默认属性。</p>
<h3 id="proc-sys-fs-mqueue-msg-default"><a class="header-anchor" href="#proc-sys-fs-mqueue-msg-default">¶</a>/proc/sys/fs/mqueue/msg_default</h3>
<p><code>mq_maxmsg</code>属性的默认值。用<a href="#%E6%89%93%E5%BC%80%E6%88%96%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">mq_open()</a>创建队列并且<code>attr</code>参数是NULL时，新队列的<code>mq_maxmsg</code>属性会使用这个文件定义的值。这个文件的默认值是10。</p>
<h3 id="proc-sys-fs-mqueue-msg-default-v2"><a class="header-anchor" href="#proc-sys-fs-mqueue-msg-default-v2">¶</a>/proc/sys/fs/mqueue/msg_default</h3>
<p>TODO</p>
<h3 id="proc-sys-fs-mqueue-msg-max"><a class="header-anchor" href="#proc-sys-fs-mqueue-msg-max">¶</a>/proc/sys/fs/mqueue/msg_max</h3>
<p>TODO</p>
<h3 id="proc-sys-fs-mqueue-msgsize-default"><a class="header-anchor" href="#proc-sys-fs-mqueue-msgsize-default">¶</a>/proc/sys/fs/mqueue/msgsize_default</h3>
<p>TODO</p>
<h3 id="proc-sys-fs-mqueue-msgsize-max"><a class="header-anchor" href="#proc-sys-fs-mqueue-msgsize-max">¶</a>/proc/sys/fs/mqueue/msgsize_max</h3>
<p>TODO</p>
<h3 id="proc-sys-fs-mqueue-queues-max"><a class="header-anchor" href="#proc-sys-fs-mqueue-queues-max">¶</a>/proc/sys/fs/mqueue/queues_max</h3>
<p>TODO</p>
<h2 id="消息队列文件系统"><a class="header-anchor" href="#消息队列文件系统">¶</a>消息队列文件系统</h2>
<p>在Linux，消息队列创建在虚拟文件系统。可以使用如下命令挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /dev/mqueue</span><br><span class="line">mount -t mqueue none /dev/mqueue</span><br></pre></td></tr></table></figure>
<p>挂载文件系统后，可以使用操作文件的命令来查看和操作消息队列。例如<code>ls</code>和<code>rm</code>。这个文件夹的文件包含队列的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /dev/mqueue/mymq</span></span><br><span class="line">QSIZE:129     NOTIFY:2    SIGNO:0    NOTIFY_PID:8260</span><br></pre></td></tr></table></figure>
<p>字段说明如下：</p>
<ul>
<li>QSIZE：队列中所有消息的总大小，单位字节。</li>
<li>NOTIFY_PID：如果非0，则此进程使用<a href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5">mq_notify()</a>注册了异步通知。其余字段描述通知是如何发生的。</li>
<li>NOTIFY：通知的方法。0：SIGEV_SIGNAL；1：SIGEV_NONE；2：SIGEV_THREAD。</li>
<li>SIGNO：SIGEV_SIGNAL使用的信号编号。</li>
</ul>
<h2 id="POSIX消息队列与SystemV消息队列对比"><a class="header-anchor" href="#POSIX消息队列与SystemV消息队列对比">¶</a>POSIX消息队列与SystemV消息队列对比</h2>
<p>TODO</p>
<h2 id="测试程序"><a class="header-anchor" href="#测试程序">¶</a>测试程序</h2>
<p><a href="https://github.com/pkemb/test-api/blob/master/src/mqueue.c">mqueue.c</a></p>
<h3 id="查看消息队列的系统参数"><a class="header-anchor" href="#查看消息队列的系统参数">¶</a>查看消息队列的系统参数</h3>
<p><code>./mqueue server</code>启动服务端，会打印与消息队列相关的系统参数。Ctrl-C退出，<code>cat /dev/mqueue/test_posix_message_queue</code>可以看到消息队列的一些数据。可以看到现在消息队列占用的空间是0。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./mqueue server</span></span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/msg_default: 10</span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/msg_max: 10</span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/msgsize_default: 8192</span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/msgsize_max: 8192</span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/queues_max: 256</span><br><span class="line">[INFO][show_mqueue_info:0206] SC_MQ_PRIO_MAX: 32768</span><br><span class="line">^C</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /dev/mqueue/test_posix_message_queue</span></span><br><span class="line">QSIZE:0          NOTIFY:0     SIGNO:0     NOTIFY_PID:0</span><br></pre></td></tr></table></figure>
<h3 id="发送阻塞"><a class="header-anchor" href="#发送阻塞">¶</a>发送阻塞</h3>
<p>在服务器没有启动的情况下，执行命令<code>./mqueue client 1 2 3 4 5 6 7 8 9 10 11</code>发送11个消息。可以看到，消息<code>11</code>没有发送成功，说明消息队列满了。为了测试消息优先级，第一个消息优先级是1，第二个消息优先级是2，依此类推。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./mqueue client 1 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line">[INFO][client:0129] mqd = 3</span><br><span class="line">[INFO][client:0140] 发送成功：1</span><br><span class="line">[INFO][client:0140] 发送成功：2</span><br><span class="line">[INFO][client:0140] 发送成功：3</span><br><span class="line">[INFO][client:0140] 发送成功：4</span><br><span class="line">[INFO][client:0140] 发送成功：5</span><br><span class="line">[INFO][client:0140] 发送成功：6</span><br><span class="line">[INFO][client:0140] 发送成功：7</span><br><span class="line">[INFO][client:0140] 发送成功：8</span><br><span class="line">[INFO][client:0140] 发送成功：9</span><br><span class="line">[INFO][client:0140] 发送成功：10</span><br></pre></td></tr></table></figure>
<p>在第二个终端执行<code>cat /dev/mqueue/test_posix_message_queue</code>，可以看到消息队列占用了11个字节的空间，符合预期。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /dev/mqueue/test_posix_message_queue</span></span><br><span class="line">QSIZE:11         NOTIFY:0     SIGNO:0     NOTIFY_PID:0</span><br></pre></td></tr></table></figure>
<h3 id="消息优先级"><a class="header-anchor" href="#消息优先级">¶</a>消息优先级</h3>
<p>基于上一个实验，在第二个终端执行<code>./mqueue server</code>。消息10最先接收到，消息队列有个空位了，所以消息11发送成功。这时消息11的优先级最高，所以第二个收到的消息是11，然后是消息9，依次类推。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个终端</span></span><br><span class="line">[INFO][client:0140] 发送成功：9</span><br><span class="line">[INFO][client:0140] 发送成功：10</span><br><span class="line">[INFO][client:0140] 发送成功：11</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二个终端</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./mqueue server</span></span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/msg_default: 10</span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/msg_max: 10</span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/msgsize_default: 8192</span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/msgsize_max: 8192</span><br><span class="line">[INFO][show_mqueue_info:0200] /proc/sys/fs/mqueue/queues_max: 256</span><br><span class="line">[INFO][show_mqueue_info:0206] SC_MQ_PRIO_MAX: 32768</span><br><span class="line">[INFO][server:0099] 第 1 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：10</span><br><span class="line">[INFO][server:0101] 消息长度：2</span><br><span class="line">[INFO][server:0102] 优先级：10</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 2 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：11</span><br><span class="line">[INFO][server:0101] 消息长度：2</span><br><span class="line">[INFO][server:0102] 优先级：11</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 3 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：9</span><br><span class="line">[INFO][server:0101] 消息长度：1</span><br><span class="line">[INFO][server:0102] 优先级：9</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 4 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：8</span><br><span class="line">[INFO][server:0101] 消息长度：1</span><br><span class="line">[INFO][server:0102] 优先级：8</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 5 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：7</span><br><span class="line">[INFO][server:0101] 消息长度：1</span><br><span class="line">[INFO][server:0102] 优先级：7</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 6 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：6</span><br><span class="line">[INFO][server:0101] 消息长度：1</span><br><span class="line">[INFO][server:0102] 优先级：6</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 7 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：5</span><br><span class="line">[INFO][server:0101] 消息长度：1</span><br><span class="line">[INFO][server:0102] 优先级：5</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 8 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：4</span><br><span class="line">[INFO][server:0101] 消息长度：1</span><br><span class="line">[INFO][server:0102] 优先级：4</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 9 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：3</span><br><span class="line">[INFO][server:0101] 消息长度：1</span><br><span class="line">[INFO][server:0102] 优先级：3</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 10 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：2</span><br><span class="line">[INFO][server:0101] 消息长度：1</span><br><span class="line">[INFO][server:0102] 优先级：2</span><br><span class="line"></span><br><span class="line">[INFO][server:0099] 第 11 个消息</span><br><span class="line">[INFO][server:0100] 收到的消息：1</span><br><span class="line">[INFO][server:0101] 消息长度：1</span><br><span class="line">[INFO][server:0102] 优先级：1</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://www.man7.org/linux/man-pages/man7/mq_overview.7.html">mq_overview.7.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈Yocto recipe之间共享文件的方法</title>
    <url>/2023/12/yocto-shareing-files-between-recipes/</url>
    <content><![CDATA[<p>在编写Yocto recipe的时候，可能会用到其他recipe的文件。这里简单总结一下recipe之间共享文件的几种方法，以及使用过程中遇到的问题。</p>
<span id="more"></span>
<h2 id="方法一：DEPENDS"><a class="header-anchor" href="#方法一：DEPENDS">¶</a>方法一：DEPENDS</h2>
<p>这种方法是最常用的，也是最推荐使用的。假设<code>foo.bb</code>安装了<code>$&#123;D&#125;$&#123;includedir&#125;/foo.h</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># foo.bb</span><br><span class="line">do_install() &#123;</span><br><span class="line">    install -d $&#123;D&#125;$&#123;includedir&#125;</span><br><span class="line">    isntall $&#123;S&#125;/foo.h $&#123;D&#125;$&#123;includedir&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>bar.bb</code>需要用到<code>foo.h</code>，那么只需要在<code>bar.bb</code>加上<code>DEPENDS += 'foo'</code>，那么<code>bar.bb</code>就能使用<code>foo.h</code>了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bar.bb</span><br><span class="line">DEPENDS += &#x27;foo&#x27;</span><br></pre></td></tr></table></figure>
<p>简简单单一句<code>DEPENDS</code>，yocto在背后做了很多工作。下面来追以下yocto是如何实现的。</p>
<h3 id="准备共享文件do-populate-sysroot"><a class="header-anchor" href="#准备共享文件do-populate-sysroot">¶</a>准备共享文件do_populate_sysroot</h3>
<p>首先，<code>foo.bb</code>要准备好共享给其他recipe的文件，这一步由<code>foo.bb</code>的<code>do_populate_sysroot</code>任务完成。这个任务会复制文件到<code>SYSROOT_DESTDIR</code>目录（即${WORKDIR}/sysroot-destdir）。简单看一下这个任务的实现，首先会调用函数<code>sysroot_stage_all</code>，这个函数会完成实际的复制动作；然后调用<code>sysroot_strip</code>，会对ELF文件做strip；<code>SYSROOT_PREPROCESS_FUNCS</code>注册了一些预处理的函数，如果想对共享的文件做一些个性化处理，可以向这个变量注册函数；最后是<code>BB_MULTI_PROVIDER_ALLOWED</code>（不知道有啥用）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_populate_sysroot</span>(<span class="params">d</span>):</span><br><span class="line">    <span class="comment"># SYSROOT &#x27;version&#x27; 2</span></span><br><span class="line">    bb.build.exec_func(<span class="string">&quot;sysroot_stage_all&quot;</span>, d)</span><br><span class="line">    bb.build.exec_func(<span class="string">&quot;sysroot_strip&quot;</span>, d)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> (d.getVar(<span class="string">&#x27;SYSROOT_PREPROCESS_FUNCS&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).split():</span><br><span class="line">        bb.build.exec_func(f, d)</span><br><span class="line">    pn = d.getVar(<span class="string">&quot;PN&quot;</span>)</span><br><span class="line">    multiprov = d.getVar(<span class="string">&quot;BB_MULTI_PROVIDER_ALLOWED&quot;</span>).split()</span><br><span class="line">    provdir = d.expand(<span class="string">&quot;$&#123;SYSROOT_DESTDIR&#125;$&#123;base_prefix&#125;/sysroot-providers/&quot;</span>)</span><br><span class="line">    bb.utils.mkdirhier(provdir)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> d.getVar(<span class="string">&quot;PROVIDES&quot;</span>).split():</span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">in</span> multiprov:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        p = p.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;_&quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(provdir + p, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(pn)</span><br></pre></td></tr></table></figure>
<p>关键是函数<code>sysroot_stage_all</code>，这个函数会将<code>$&#123;D&#125;</code>下面的文件复制到<code>$&#123;SYSROOT_DESTDIR&#125;</code>。当然，不是所有的文件都会复制，只会复制<code>$&#123;SYSROOT_DIRS&#125;</code>变量列出的目录，还会删除<code>$&#123;SYSROOT_DIRS_IGNORE&#125;</code>变量列出的目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysroot_stage_dir() &#123;</span><br><span class="line">	src=&quot;$1&quot;</span><br><span class="line">	dest=&quot;$2&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="keyword">if</span> the src doesn<span class="string">&#x27;t exist don&#x27;</span>t <span class="keyword">do</span> anything</span></span><br><span class="line">	if [ ! -d &quot;$src&quot; ]; then</span><br><span class="line">		 return</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	mkdir -p &quot;$dest&quot;</span><br><span class="line">	rdest=$(realpath --relative-to=&quot;$src&quot; &quot;$dest&quot;)</span><br><span class="line">	(</span><br><span class="line">		cd $src</span><br><span class="line">		find . -print0 | cpio --null -pdlu $rdest</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sysroot_stage_dirs() &#123;</span><br><span class="line">	from=&quot;$1&quot;</span><br><span class="line">	to=&quot;$2&quot;</span><br><span class="line"></span><br><span class="line">	for dir in $&#123;SYSROOT_DIRS&#125;; do</span><br><span class="line">		sysroot_stage_dir &quot;$from$dir&quot; &quot;$to$dir&quot;</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Remove directories we <span class="keyword">do</span> not care about</span></span><br><span class="line">	for dir in $&#123;SYSROOT_DIRS_IGNORE&#125;; do</span><br><span class="line">		rm -rf &quot;$to$dir&quot;</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sysroot_stage_all() &#123;</span><br><span class="line">	sysroot_stage_dirs $&#123;D&#125; $&#123;SYSROOT_DESTDIR&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>SYSROOT_DIRS</code>和<code>SYSROOT_DIRS_IGNORE</code>变量的默认值。所以如果没有把文件安装到<code>SYSROOT_DIRS</code>包含的目录，或者把文件安装到了<code>SYSROOT_DIRS_IGNORE</code>列出的目录，那么其他的recipe就拿不到文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SYSROOT_DIRS = &quot; \</span><br><span class="line">    $&#123;includedir&#125; \</span><br><span class="line">    $&#123;libdir&#125; \</span><br><span class="line">    $&#123;base_libdir&#125; \</span><br><span class="line">    $&#123;nonarch_base_libdir&#125; \</span><br><span class="line">    $&#123;datadir&#125; \</span><br><span class="line">    /sysroot-only \</span><br><span class="line">    &quot;</span><br><span class="line"></span><br><span class="line">SYSROOT_DIRS_IGNORE = &quot; \</span><br><span class="line">    $&#123;mandir&#125; \</span><br><span class="line">    $&#123;docdir&#125; \</span><br><span class="line">    $&#123;infodir&#125; \</span><br><span class="line">    $&#123;datadir&#125;/X11/locale \</span><br><span class="line">    $&#123;datadir&#125;/applications \</span><br><span class="line">    $&#123;datadir&#125;/bash-completion \</span><br><span class="line">    $&#123;datadir&#125;/fonts \</span><br><span class="line">    $&#123;datadir&#125;/gtk-doc/html \</span><br><span class="line">    $&#123;datadir&#125;/installed-tests \</span><br><span class="line">    $&#123;datadir&#125;/locale \</span><br><span class="line">    $&#123;datadir&#125;/pixmaps \</span><br><span class="line">    $&#123;datadir&#125;/terminfo \</span><br><span class="line">    $&#123;libdir&#125;/$&#123;BPN&#125;/ptest \</span><br><span class="line">    &quot;</span><br></pre></td></tr></table></figure>
<h3 id="获取共享文件do-prepare-recipe-sysroot"><a class="header-anchor" href="#获取共享文件do-prepare-recipe-sysroot">¶</a>获取共享文件do_prepare_recipe_sysroot</h3>
<p><code>do_prepare_recipe_sysroot</code>任务会根据<code>DEPENDS</code>变量，将文件安装到<code>STAGING_DIR_HOST</code>目录或<code>STAGING_DIR_NATIVE</code>目录。</p>
<blockquote>
<p>Installs the files into the individual recipe specific sysroots (i.e. recipe-sysroot and recipe-sysroot-native under ${WORKDIR} based upon the dependencies specified by DEPENDS). See the “staging” class for more information.</p>
</blockquote>
<p>这个任务的实现比较复杂，看不太懂。</p>
<h3 id="kernel-bbclass"><a class="header-anchor" href="#kernel-bbclass">¶</a>kernel.bbclass</h3>
<p>需要注意的是，<code>kernel.bbclass</code>将<code>SYSROOT_DIRS</code>变量清空了。这意味其他recipes拿不到kernel recipe安装到<code>$&#123;D&#125;</code>下面的文件（被坑了一把，一度怀疑人生）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># We don&#x27;t need to stage anything, not the modules/firmware since those would clash with linux-firmware</span><br><span class="line">SYSROOT_DIRS = &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>在yocto 4.0.6之前，是重写了<code>sysroot_stage_all</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># We don&#x27;t need to stage anything, not the modules/firmware since those would clash with linux-firmware</span><br><span class="line">sysroot_stage_all () &#123;</span><br><span class="line">	:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二：work-shared"><a class="header-anchor" href="#方法二：work-shared">¶</a>方法二：work-shared</h2>
<p><code>work-shared</code>目录在<code>$&#123;TMPDIR&#125;/work-sahred</code>，一般情况下是<code>build/tmp/work-sahred</code>。recipe可以将文件安装到此目录下，其他recipe就可以在此路径下拿到文件。从Yocto文档看，只用于gcc及其变种，但这个限制不是强制的。</p>
<blockquote>
<p>4.2.24 build/tmp/work-shared/</p>
<p>For efficiency, the OpenEmbedded build system creates and uses this directory to hold recipes that share a work directory with other recipes. In practice, this is only used for gcc and its variants (e.g. gcc-cross, libgcc, gcc-runtime, and so forth).</p>
</blockquote>
<h2 id="方法三：DEPLOY-DIR-IMAGE"><a class="header-anchor" href="#方法三：DEPLOY-DIR-IMAGE">¶</a>方法三：DEPLOY_DIR_IMAGE</h2>
<p>与work-shared目录类似，也是recipe安装文件到DEPLAY_DIR_IMAGE目录，其他recipe通过此目录读取。</p>
<blockquote>
<p>DEPLOY_DIR_IMAGE<br>
…<br>
Instead, it’s only useful when a recipe needs to “read” a file already deployed by a dependency.</p>
</blockquote>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>通过<code>DEPENDS</code>可以很方便的拿到其他recipe安装到<code>$&#123;D&#125;</code>目录的文件。但要注意<code>SYSROOT_DIRS</code>和<code>SYSROOT_DIRS_IGNORE</code>变量，一个控制什么目录会共享，一个控制什么目录不会共享。通过检查<code>$&#123;SYSROOT_DESTDIR&#125;</code>可以确认共享给其他recipe的文件。</p>
<p>此外，还能通过<code>work-shared</code>和<code>DEPLOY_DIR_IMAGE</code>目录拿到其他recipe安装的文件。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://docs.yoctoproject.org">yocto doc</a></li>
</ul>
]]></content>
      <tags>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>DX4600开启ssh</title>
    <url>/2024/03/dx4600-enable-ssh/</url>
    <content><![CDATA[<p>突破绿联系统的限制，彻底掌握自己的设备。</p>
<span id="more"></span>
<h2 id="使用浏览器获取-API-Token"><a class="header-anchor" href="#使用浏览器获取-API-Token">¶</a>使用浏览器获取 API Token</h2>
<p>随便用客户端创建个 Docker 容器，在浏览器开发者模式查看网络连接，获取Token：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.50.155:9999/containers/create?name=hack&amp;ugreen_nas_model=docker&amp;api_token=xxxxGJkMTIyMzM0Y2YxYTBlZTJmZGI2MDhlODE0YjM4YzhiODhkYg%3D%3D</span><br></pre></td></tr></table></figure>
<p>Token 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxxGJkMTIyMzM0Y2YxYTBlZTJmZGI2MDhlODE0YjM4YzhiODhkYg%3D%3D</span><br></pre></td></tr></table></figure>
<h2 id="创建-Hack-容器"><a class="header-anchor" href="#创建-Hack-容器">¶</a>创建 Hack 容器</h2>
<h3 id="创建容器配置-container-json"><a class="header-anchor" href="#创建容器配置-container-json">¶</a>创建容器配置 container.json</h3>
<p>container.json 文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_query&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;hack&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;name&quot;: &quot;hack&quot;,</span><br><span class="line">  &quot;AttachStdout&quot;: false,</span><br><span class="line">  &quot;AttachStderr&quot;: false,</span><br><span class="line">  &quot;ExposedPorts&quot;: &#123;&#125;,</span><br><span class="line">  &quot;Tty&quot;: true,</span><br><span class="line">  &quot;OpenStdin&quot;: true,</span><br><span class="line">  &quot;Env&quot;: [</span><br><span class="line">    &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;Cmd&quot;: [</span><br><span class="line">    &quot;/bin/sh&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;Healthcheck&quot;: &#123;&#125;,</span><br><span class="line">  &quot;Image&quot;: &quot;alpine:latest&quot;,</span><br><span class="line">  &quot;Volumes&quot;: null,</span><br><span class="line">  &quot;Entrypoint&quot;: null,</span><br><span class="line">  &quot;OnBuild&quot;: null,</span><br><span class="line">  &quot;Labels&quot;: null,</span><br><span class="line">  &quot;HostConfig&quot;: &#123;</span><br><span class="line">    &quot;PidMode&quot;: &quot;host&quot;,</span><br><span class="line">    &quot;Privileged&quot;: true,</span><br><span class="line">    &quot;Devices&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;CgroupPermissions&quot;: &quot;mrw&quot;,</span><br><span class="line">        &quot;PathInContainer&quot;: &quot;/dev/dri/renderD128&quot;,</span><br><span class="line">        &quot;PathOnHost&quot;: &quot;/dev/dri/renderD128&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;CgroupPermissions&quot;: &quot;mrw&quot;,</span><br><span class="line">        &quot;PathInContainer&quot;: &quot;/dev/dri/card0&quot;,</span><br><span class="line">        &quot;PathOnHost&quot;: &quot;/dev/dri/card0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;NetworkMode&quot;: &quot;host&quot;,</span><br><span class="line">    &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">    &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;always&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;LogConfig&quot;: &#123;&#125;,</span><br><span class="line">    &quot;Sysctls&quot;: &#123;&#125;,</span><br><span class="line">    &quot;Mounts&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;Target&quot;: &quot;/host&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/&quot;,</span><br><span class="line">        &quot;ReadOnly&quot;: false,</span><br><span class="line">        &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">        &quot;Consistency&quot;: &quot;default&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;RW&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;Links&quot;: []</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;NetworkingConfig&quot;: &#123;</span><br><span class="line">    &quot;EndpointsConfig&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建容器"><a class="header-anchor" href="#创建容器">¶</a>创建容器</h3>
<p>自行替换 <code>api_token</code> 内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">curl --compressed \</span><br><span class="line">    -H &#x27;Host: 192.168.50.155:9999&#x27; \</span><br><span class="line">    -H &#x27;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) UGREEN_Nas/3.9.0 Chrome/91.0.4472.164 Electron/13.3.0 Safari/537.36&#x27; \</span><br><span class="line">    -H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">    -H &#x27;Accept: */*&#x27; \</span><br><span class="line">    -H &#x27;Referer: http://192.168.50.155:9999/service/web/&#x27; \</span><br><span class="line">    -H &#x27;Accept-Language: en-US&#x27; \</span><br><span class="line">    --data-binary @container.json \</span><br><span class="line">    &#x27;http://192.168.50.155:9999/containers/create?name=hack&amp;ugreen_nas_model=docker&amp;api_token=xxxxxJkMTIyMzM0Y2YxYTBlZTJmZGI2MDhlODE0YjM4YzhiODhkYg%3D%3D&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="开启ssh登录"><a class="header-anchor" href="#开启ssh登录">¶</a>开启ssh登录</h2>
<p>进入绿联的docker应用，找到刚刚创建的hack容器，进入shell。执行如下命令进入绿联系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nsenter -t 1 -m /bin/sh</span><br></pre></td></tr></table></figure>
<p>进入系统后执行下面的命令创建 ssh 登录。绿联系统开机会杀死sshd进程，所以把sshd复制一份改名，才能做到开机自启动。修改<code>/etc/ssh/sshd_config</code>的<code>PubkeyAuthentication</code>为<code>yes</code>，开启密钥登录。添加自己的公钥到 <code>/root/.ssh/authorized_keys</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/sbin/sshd /usr/sbin/sshdpk</span><br><span class="line">ssh-keygen -A</span><br><span class="line">chmod go-w /root</span><br><span class="line">chmod 700 /root/.ssh</span><br><span class="line">chmod 600 /root/.ssh/authorized_keys</span><br><span class="line">cat &gt; /etc/init.d/sshdpk &lt;&lt;EOF</span><br><span class="line">#!/bin/sh /etc/rc.common</span><br><span class="line">START=99</span><br><span class="line">STOP=10</span><br><span class="line">USE_PROCD=1</span><br><span class="line">PROG=/usr/sbin/sshdpk</span><br><span class="line">mkdir -p /var/empty</span><br><span class="line">start_service() &#123;</span><br><span class="line">    procd_open_instance</span><br><span class="line">    procd_set_param command &quot;$PROG&quot; -D</span><br><span class="line">    procd_close_instance</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">chmod +x /etc/init.d/sshd</span><br><span class="line">service sshd enable</span><br><span class="line">sed -i &#x27;/PubkeyAuthentication/ s/no/yes/g&#x27; /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>默认的端口是 922，如果不是通过<code>/etc/ssh/sshd_config</code>文件确认。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -p 922 root@192.168.50.155</span><br></pre></td></tr></table></figure>
<p>如果想使用普通用户登录ssh，直接使用普通用户的本地密码，或者添加ssh公钥到普通用户的<code>.ssh/authorized_keys</code>文件。<code>root</code>用户执行<code>usermod -aG docker </code>​<code>**username**</code> 将普通用户加入docker组，这样普通用户也可以执行docker命令。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<ul>
<li><a href="https://blog.jim.plus/blog/post/jim/dx4600-enable-ssh">https://blog.jim.plus/blog/post/jim/dx4600-enable-ssh</a></li>
<li><a href="https://honmaple.me/articles/2023/07/%E7%BB%BF%E8%81%94%E4%BA%91Nas%E6%96%B0%E7%89%88%E6%9C%ACv3.4.0%E5%9B%BA%E4%BB%B6%E5%BC%80%E5%90%AFSSH.html">绿联云Nas新版本v3.4.0固件开启SSH</a></li>
</ul>
]]></content>
      <tags>
        <tag>dx4600</tag>
      </tags>
  </entry>
  <entry>
    <title>DX4600安装虚拟机</title>
    <url>/2024/03/dx4600-virtual-machine/</url>
    <content><![CDATA[<p>绿联NAS DX4600安装虚拟机，非官方教程。基于docker，不会修改系统任何数据。本文在<a href="https://www.bilibili.com/video/BV1iB421k7Xe/">BV1iB421k7Xe</a>的基础上，对网络、配置文件持久化、反向代理等方面进行了完善。</p>
<span id="more"></span>
<h2 id="环境准备"><a class="header-anchor" href="#环境准备">¶</a>环境准备</h2>
<ol>
<li>SSH登录DX4600，<a href="https://pkemb.com/2024/03/dx4600-enable-ssh/">DX4600开启ssh</a>。</li>
<li>安装 docker-compose</li>
<li>切换到桥接模式<br>
<img src="http://image.pkemb.com/image/202403202120004.png" style="zoom:67%;" /></li>
<li>在某个地方创建2个目录，存放配置文件和ISO镜像。<code>webvirtcloud/config</code>和<code>webvirtcloud/iso</code>。</li>
<li>复制操作系统镜像文件（例如Ubuntu、Windows等）到<code>webvirtcloud/iso</code>。</li>
</ol>
<h2 id="备份配置文件"><a class="header-anchor" href="#备份配置文件">¶</a>备份配置文件</h2>
<p>下载镜像<code>linkease/webvirtcloud:0.2</code>。创建一个不启动的容器，从里面复制配置文件。需要备份<code>/etc/libvirt</code>和<code>/etc/nginx/conf.d/webvirtcloud.conf</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull linkease/webvirtcloud:0.2</span><br><span class="line">docker container create --name temp_webvirt linkease/webvirtcloud:0.2</span><br><span class="line">docker container cp temp_webvirt:/etc/libvirt  M2_2/docker/webvirtcloud/etc</span><br><span class="line">docker container cp temp_webvirt:/etc/nginx/conf.d/webvirtcloud.conf M2_2/docker/webvirtcloud</span><br><span class="line">docker container rm -f temp_webvirt</span><br></pre></td></tr></table></figure>
<p>网络的配置放在 <code>/etc/libvirt/qemu/networks</code>，实例的配置放在 <code>/etc/libvirt/qemu</code>，存储池的配置放在 <code>/etc/libvirt/storage</code>。</p>
<p>修改 <code>webvirtcloud.conf</code>，将监听端口从<code>80</code>改为<code>6009</code>。因为只想通过域名访问，所以只监听一个IP地址，而不是所有IP。IP地址<code>192.168.0.1</code>是Docker NAT IP，而不是路由器的IP，<code>nginx</code>容器在这个网段。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">192.168.0.1:6009</span>;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置反向代理"><a class="header-anchor" href="#配置反向代理">¶</a>配置反向代理</h2>
<p>首先配置好域名解析。这里使用的是<code>Nginx Proxy Manager</code>。填写<code>webvirtcloud</code>监听的IP地址端口，设置好SSL。</p>
<img src="http://image.pkemb.com/image/202403202125071.png" style="zoom:67%;" />
<p>在<code>Advanced</code>选项卡下面配置好如下指令。主要是对这三个路径配置websocket反向代理。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">1024M</span>;</span><br><span class="line"><span class="section">location</span> /novncd  &#123;</span><br><span class="line">        <span class="attribute">include</span> conf.d/include/proxy.conf;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /socket.io/  &#123;</span><br><span class="line">        <span class="attribute">include</span> conf.d/include/proxy.conf;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> /websockify  &#123;</span><br><span class="line">        <span class="attribute">include</span> conf.d/include/proxy.conf;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动容器"><a class="header-anchor" href="#启动容器">¶</a>启动容器</h2>
<p>使用<code>docker compose</code>启动容器。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> compose -f M2_2/docker-compose/dx4600.inc/webvirtcloud/webvirtcloud.yml up &amp;</span><br></pre></td></tr></table></figure>
<p>compose文件如下。关键点，<code>privileged: true</code>和<code>network_mode: host</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.9&quot;</span><br><span class="line">services:</span><br><span class="line">    webvirtcloud:</span><br><span class="line">        image: &#x27;linkease/webvirtcloud:0.2&#x27;</span><br><span class="line">        container_name: webvirtcloud</span><br><span class="line">        privileged: true</span><br><span class="line">        network_mode: host</span><br><span class="line">        volumes:</span><br><span class="line">            - &#x27;/home/pkemb/M2_2/docker/webvirtcloud/config:/srv/webvirtcloud/dbconfig&#x27;</span><br><span class="line">            - &#x27;/home/pkemb/M2_2/docker/webvirtcloud/iso:/var/lib/libvirt/iso&#x27;</span><br><span class="line">            - &#x27;/home/pkemb/M2_2/docker/webvirtcloud/etc:/etc/libvirt&#x27;</span><br><span class="line">            - &#x27;/home/pkemb/M2_2/docker/webvirtcloud/webvirtcloud.conf:/etc/nginx/conf.d/webvirtcloud.conf:ro&#x27;</span><br><span class="line">            - &#x27;/sys/fs/cgroup:/sys/fs/cgroup&#x27;</span><br><span class="line">        tmpfs:</span><br><span class="line">            - /run/lock</span><br><span class="line">            - /run</span><br><span class="line">            - /tmp</span><br><span class="line">        cgroup: host</span><br><span class="line">        tty: true</span><br><span class="line">        stdin_open: true</span><br><span class="line">        restart: always</span><br></pre></td></tr></table></figure>
<h2 id="初始化服务"><a class="header-anchor" href="#初始化服务">¶</a>初始化服务</h2>
<p>第一次启动容器需要初始化服务。<code>docker exec</code>进入容器内部，执行如下命令启动服务，并向<code>local_settings.py</code>添加<code>DEBUG=True</code>。域名替换成实际解析的域名。这个步骤只需要做一次。<code>cloud.dx4600.inc</code>是反向代理的域名，<code>443</code>是https端口。如果不想要https，可以设置为80。修改<code>local_settings.py</code>中域名的配置，<code>http</code>替换为<code>https</code>，删除<code>:443</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it webvirtcloud /bin/bash</span><br><span class="line">/srv/startup.sh cloud.dx4600.inc 443</span><br><span class="line">sed -i -e &#x27;s/http:/https:/&#x27; -e &#x27;s/:443//&#x27; /srv/webvirtcloud/dbconfig/local_settings.py</span><br><span class="line">echo &quot;DEBUG=True&quot; &gt;&gt; /srv/webvirtcloud/dbconfig/local_settings.py</span><br></pre></td></tr></table></figure>
<p>如果<code>local_settings.py</code>中，<code>CSRF_TRUSTED_ORIGINS</code>配置的域名与实际访问的域名不一样，会出现如下错误。</p>
<img src="http://image.pkemb.com/image/202403202127006.png" style="zoom:67%;" />
<p>退出容器shell，重启容器。因为网络模式是<code>host</code>，容器会在主机创建<code>virbr0</code>虚拟网卡。启动容器之前，需要先删除网卡。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> compose -f M2_2/docker-compose/dx4600.inc/webvirtcloud/webvirtcloud.yml down</span><br><span class="line">ifconfig virbr0 down</span><br><span class="line">ip link delete virbr0</span><br><span class="line">docker compose -f M2_2/docker-compose/dx4600.inc/webvirtcloud/webvirtcloud.yml up -d</span><br></pre></td></tr></table></figure>
<h2 id="基础配置"><a class="header-anchor" href="#基础配置">¶</a>基础配置</h2>
<p>浏览输入<code>cloud.dx4600.inc</code> 访问控制台，默认的用户名和密码都是admin。关于节点、存储的创建，可以参考B站视频 <a href="https://www.bilibili.com/video/BV1iB421k7Xe/">绿联NAS如何安装虚拟机，DX4600全系列支持</a>。</p>
<h3 id="网络"><a class="header-anchor" href="#网络">¶</a>网络</h3>
<p>创建一个桥接网络，网桥名称填<code>br-wan</code>。创建虚拟机时选择这个网络，这样虚拟机可以拿到路由器分配的IP地址，方便访问虚拟机。</p>
<img src="http://image.pkemb.com/image/202403202128611.png" style="zoom:50%;" />
<p>nat 网络使用自带的<code>default</code>。</p>
<img src="http://image.pkemb.com/image/202403202129675.png" style="zoom:50%;" />
<p>如果重启了容器，在启动容器之前，要先删除虚拟网卡。不然网络会异常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig virbr0 down</span><br><span class="line">ip link delete virbr0</span><br></pre></td></tr></table></figure>
<h2 id="创建虚拟机"><a class="header-anchor" href="#创建虚拟机">¶</a>创建虚拟机</h2>
<p>具体步骤可以参考B站视频<a href="https://www.bilibili.com/video/BV1iB421k7Xe/">绿联NAS如何安装虚拟机，DX4600全系列支持</a>。这里提一下我安装虚拟机遇到的坑：</p>
<ul>
<li>Ubuntu 20.04 server：可以直接安装成功</li>
<li>Ubuntu 22.04 server：可以直接安装成功。不要安装<code>22.10</code>，已经EOL了。安装<code>22.10</code>的过程中会crash。</li>
<li>win10：默认创建的磁盘总线是<code>virtio</code>，Windows不认，会找不到磁盘。需要手工添加一个<code>sata</code>总线的磁盘。</li>
<li>win7：磁盘的问题和win10一样，手工添加一个<code>sata</code>硬盘。win7镜像自带的安装程序走到创建分区这一步时，创建分区失败。我的解决方法是找一个PE ISO镜像，先进入PE，在PE安装win7。<br>
<img src="http://image.pkemb.com/image/202403202141000.png" alt=""></li>
</ul>
<h3 id="ubuntu20-04"><a class="header-anchor" href="#ubuntu20-04">¶</a>ubuntu20.04</h3>
<p><img src="http://image.pkemb.com/image/202403202241517.png" alt=""></p>
<h3 id="ubuntu22-04"><a class="header-anchor" href="#ubuntu22-04">¶</a>ubuntu22.04</h3>
<p><img src="http://image.pkemb.com/image/202403202245030.png" alt=""></p>
<h3 id="win7"><a class="header-anchor" href="#win7">¶</a>win7</h3>
<p><img src="http://image.pkemb.com/image/202403202244051.png" alt=""></p>
<h3 id="win10"><a class="header-anchor" href="#win10">¶</a>win10</h3>
<p>太卡了。</p>
<p><img src="http://image.pkemb.com/image/202403202247600.png" alt=""></p>
]]></content>
      <tags>
        <tag>dx4600</tag>
      </tags>
  </entry>
  <entry>
    <title>bash补全函数</title>
    <url>/2024/11/bash-completion/</url>
    <content><![CDATA[<p>编写bash补全函数的关键就是根据上下文生成合适的<code>COMPREPLY</code>数组。这里记录了bash补全的相关资料，以及常用的代码片段。</p>
<span id="more"></span>
<p>关于补全，建议先通读一遍<a href="https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion">Programmable Completion</a>，可以了解当按下<code>&lt;tab&gt;</code>按键时，bash是如何处理的。这里专注于补全函数，相关描述如下。</p>
<blockquote>
<p>After these matches have been generated, any shell function or command specified with the -F and -C options is invoked. When the command or function is invoked, the COMP_LINE, COMP_POINT, COMP_KEY, and COMP_TYPE variables are assigned values as described above (see Bash Variables). If a shell function is being invoked, the COMP_WORDS and COMP_CWORD variables are also set. When the function or command is invoked, the first argument ($1) is the name of the command whose arguments are being completed, the second argument ($2) is the word being completed, and the third argument ($3) is the word preceding the word being completed on the current command line. No filtering of the generated completions against the word being completed is performed; the function or command has complete freedom in generating the matches.</p>
<p>Any function specified with -F is invoked first. The function may use any of the shell facilities, including the compgen and compopt builtins described below (see Programmable Completion Builtins), to generate the matches. It must put the possible completions in the COMPREPLY array variable, one per array element.</p>
</blockquote>
<h2 id="注册补全函数"><a class="header-anchor" href="#注册补全函数">¶</a>注册补全函数</h2>
<p>使用bash内置命令<code>complete</code>可以为指定shell命令注册补全函数。如下代码表示shell命令<code>foo</code>的补全函数是<code>_foo</code>。在shell命令中，依次敲入<code>foo</code>、<code>空格</code>、<code>&lt;tab&gt;</code>时，补全函数<code>_foo</code>将在当前shell运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">complete -F _foo foo</span><br></pre></td></tr></table></figure>
<p>可以使用命令<code>complete -p func</code>来查询指定命令的补全函数。例如<code>cd</code>命令的补全函数是<code>_cd</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pk@pkdev22:~$ complete -p cd</span><br><span class="line">complete -o nospace -F _cd cd</span><br></pre></td></tr></table></figure>
<h2 id="上下文"><a class="header-anchor" href="#上下文">¶</a>上下文</h2>
<p>阅读<a href="https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion">Programmable Completion</a>可以得知，当调用补全函数时，bash会准备好<code>COMP_LINE</code>、<code>COMP_POINT</code>、<code>COMP_KEY</code>、<code>COMP_TYPE</code>、<code>COMP_WORDS</code>和<code>COMP_CWORD</code>变量。bash手册关于这些变量的描述如下。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>COMP_LINE</td>
<td>The current command line. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see <a href="https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion">Programmable Completion</a>).</td>
</tr>
<tr>
<td>COMP_POINT</td>
<td>The index of the current cursor position relative to the beginning of the current command. If the current cursor position is at the end of the current command, the value of this variable is equal to <code>$&#123;#COMP_LINE&#125;</code>. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see <a href="https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion">Programmable Completion</a>).</td>
</tr>
<tr>
<td>COMP_KEY</td>
<td>The key (or final key of a key sequence) used to invoke the current completion function.</td>
</tr>
<tr>
<td>COMP_TYPE</td>
<td>Set to an integer value corresponding to the type of completion attempted that caused a completion function to be called: TAB, for normal completion, ‘?’, for listing completions after successive tabs, ‘!’, for listing alternatives on partial word completion, ‘@’, to list completions if the word is not unmodified, or ‘%’, for menu completion. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see <a href="https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion">Programmable Completion</a>).</td>
</tr>
<tr>
<td>COMP_WORDS</td>
<td>An array variable consisting of the individual words in the current command line. The line is split into words as Readline would split it, using COMP_WORDBREAKS as described above. This variable is available only in shell functions invoked by the programmable completion facilities (see <a href="https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion">Programmable Completion</a>).</td>
</tr>
<tr>
<td>COMP_CWORD</td>
<td>An index into <code>$&#123;COMP_WORDS&#125;</code> of the word containing the current cursor position. This variable is available only in shell functions invoked by the programmable completion facilities (see <a href="https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion">Programmable Completion</a>).</td>
</tr>
</tbody>
</table>
<p>直接看描述，有点迷迷糊糊，上例子。<code>COMP_LINE</code>是一个字符串，表示整个命令行，如果末尾有空格，则包含空格。<code>COMP_POINT</code>是<code>COMP_LINE</code>的长度。<code>COMP_KEY</code>不知道是干啥的。<code>COMP_TYPE</code>在第一次敲<code>&lt;tab&gt;</code>时，是9，即<code>&lt;tab&gt;</code>的ASCII值，第二次敲<code>&lt;tab&gt;</code>时，是63，即<code>?</code>的ASCII值。<code>COMP_WORDS</code>和<code>COMP_LINE</code>很类似，但<code>COMP_WORDS</code>是一个数组。<code>COMP_CWORD</code>是数组<code>COMP_WORDS</code>的下标，</p>
<table>
<thead>
<tr>
<th>变量</th>
<th><code>foo a b&lt;tab&gt;</code></th>
<th><code>foo a b&lt;space&gt;&lt;tab&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>COMP_LINE</td>
<td><code>foo a b</code></td>
<td><code>foo a b&lt;space&gt;</code></td>
</tr>
<tr>
<td>COMP_POINT</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>COMP_KEY</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>COMP_TYPE</td>
<td>9 或 63</td>
<td>9 或 63</td>
</tr>
<tr>
<td>COMP_WORDS</td>
<td><code>foo</code> <code>a</code> <code>b</code></td>
<td><code>foo</code> <code>a</code> <code>b</code> <code>&lt;space&gt;</code></td>
</tr>
<tr>
<td>COMP_CWORD</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>根据bash提供的这些变量，可以推算出两个关键的信息，<code>prev</code>和<code>cur</code>。<code>prev</code>表示上一个单词，<code>cur</code>表示当前的单词。绝大多数情况下，可以根据这两个信息计算出补全列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_foo() &#123;</span><br><span class="line">    local prev=&quot;$&#123;COMP_WORDS[COMP_CWORD-1]&#125;&quot;</span><br><span class="line">    local cur=&quot;$&#123;COMP_WORDS[COMP_CWORD]&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bash提供了辅助函数<code>_init_completion</code>用来初始化变量<code>prev</code>、<code>cur</code>、<code>words</code>、<code>cword</code>。其中<code>words</code>等同于<code>COMP_WORDS</code>，<code>cword</code>等同于<code>COMP_CWORD</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_foo() &#123;</span><br><span class="line">    _init_completion || return</span><br><span class="line">    # 接下来的代码可以使用 prev / cur / words / cword 变量。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回补全结果"><a class="header-anchor" href="#返回补全结果">¶</a>返回补全结果</h2>
<p>补全函数需要填充<code>COMPREPLY</code>数组，向bash返回补全列表。根据日常使用补全的经验，有两种情况。第一种情况，当前的选项输入到一半了。第二种情况，上一个选项输入完成了，开始输入下一个选项。</p>
<p>对于第一种情况，只需要根据当前的输入<code>$&#123;cur&#125;</code>做一个筛选，将匹配的结果填充到<code>COMPREPLY</code>数组即可。例如<code>foo</code>命令有三个选项<code>--foo1</code>、<code>--foo2</code>、<code>--bar</code>。当输入<code>foo --foo&lt;tab&gt;</code>时，期望bash会提示<code>--foo1</code>和<code>--foo2</code>。bash的内置命令<code>compgen</code>可以帮助做筛选。补全函数的参考实现如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_foo() &#123;</span><br><span class="line">    _init_completion || return</span><br><span class="line">    COMPREPLY=( $(compgen -W &#x27;--foo1 --foo2 --bar&#x27; -- $&#123;cur&#125;) )</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种情况比较复杂，需要根据之前的输入，向<code>COMPREPLY</code>数组填充不同的值。例如<code>foo</code>命令的所有选项只允许出现一次，当输入<code>foo --foo1 &lt;tab&gt;</code>时，期望只会提示<code>--foo2</code>和<code>--bar</code>。参考实现如下。首先遍历选项列表，如果不在<code>$&#123;words[*]</code>，则追加到变量<code>comp_opts</code>。最后根据<code>$&#123;cur&#125;</code>做筛选。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_foo() &#123;</span><br><span class="line">    _init_completion || return</span><br><span class="line">    COMPREPLY=()</span><br><span class="line"></span><br><span class="line">    local opts=(&quot;--foo1&quot; &quot;--foo2&quot; &quot;--bar&quot;)</span><br><span class="line">    local comp_opts</span><br><span class="line">    for (( i=0; i &lt; $&#123;#opts[@]&#125;; i++)); do</span><br><span class="line">        # 遍历所有选项，如果不在$&#123;words[*]&#125;，则追加到comp_opts。</span><br><span class="line">        if [[ &quot;$&#123;words[*]&#125;&quot; != *&quot; $&#123;opts[i]&#125; &quot;* ]]; then</span><br><span class="line">            comp_opts+=&quot;$&#123;opts[i]&#125; &quot;</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">    COMPREPLY=( $(compgen -W &quot;$&#123;comp_opts&#125;&quot; -- $&#123;cur&#125;) )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>bash比较子字符串时，子字符串必须放在后面。</p>
</blockquote>
<p>实际情况往往更加的复杂，比如很多shell命令还有子命令，这些子命令有不同的选项。但思路都是类似的，根据上下文生成合适的<code>COMPREPLY</code>数组。</p>
<h2 id="compgen"><a class="header-anchor" href="#compgen">¶</a>compgen</h2>
<p>除了用<code>-W</code>指定补全的数据外，<code>compgen</code>还提供了生成常用数据的选项。比如<code>compgen -u</code>或<code>compgen -A user</code>会输出系统的所有用户，编写<code>chmod</code>的补全函数就会用到。</p>
<table>
<thead>
<tr>
<th>-A <em>action</em></th>
<th>短选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A alias</td>
<td>-a</td>
<td>别名</td>
</tr>
<tr>
<td>-A arrayvar</td>
<td></td>
<td>数组变量名</td>
</tr>
<tr>
<td>-A binding</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-A builtin</td>
<td>-b</td>
<td>shell内置命令</td>
</tr>
<tr>
<td>-A command</td>
<td>-c</td>
<td>命令</td>
</tr>
<tr>
<td>-A directory [dir]</td>
<td>-d</td>
<td>当前路径或指定路径的子目录</td>
</tr>
<tr>
<td>-A disabled</td>
<td></td>
<td>禁用的shell内置命令</td>
</tr>
<tr>
<td>-A enabled</td>
<td></td>
<td>使能的shell内置命令</td>
</tr>
<tr>
<td>-A export</td>
<td>-e</td>
<td>导出的shell变量</td>
</tr>
<tr>
<td>-A file [dir/]</td>
<td>-f</td>
<td>当前路径或指定路径的文件。如果加了可选参数，一定用<code>/</code>结尾</td>
</tr>
<tr>
<td>-A function</td>
<td></td>
<td>shell函数</td>
</tr>
<tr>
<td>-A group</td>
<td>-g</td>
<td>组名</td>
</tr>
<tr>
<td>-A helptopic</td>
<td></td>
<td>内置命令<code>help</code>接受的主题</td>
</tr>
<tr>
<td>-A hostname</td>
<td></td>
<td>主机名</td>
</tr>
<tr>
<td>-A job</td>
<td>-j</td>
<td>任务名</td>
</tr>
<tr>
<td>-A keyword</td>
<td>-k</td>
<td>shell关键字</td>
</tr>
<tr>
<td>-A running</td>
<td></td>
<td>正在运行的任务名</td>
</tr>
<tr>
<td>-A service</td>
<td>-s</td>
<td>服务名</td>
</tr>
<tr>
<td>-A setopt</td>
<td></td>
<td><code>set</code>内置命令<code>-o</code>选项的有效参数</td>
</tr>
<tr>
<td>-A shopt</td>
<td></td>
<td><code>shopt</code>内置命令接受的选项名</td>
</tr>
<tr>
<td>-A signal</td>
<td></td>
<td>信号名</td>
</tr>
<tr>
<td>-A stopped</td>
<td></td>
<td>停止的任务</td>
</tr>
<tr>
<td>-A user</td>
<td>-u</td>
<td>用户名</td>
</tr>
<tr>
<td>-A variable</td>
<td>-v</td>
<td>变量名</td>
</tr>
</tbody>
</table>
<h2 id="调试技巧"><a class="header-anchor" href="#调试技巧">¶</a>调试技巧</h2>
<p>在调试补全函数的过程中，经常需要打印某些变量的值。如果直接使用<code>echo</code>输出，会和补全提示混在一起，非常不好看。建议重定向到某一个文件。</p>
<h2 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h2>
<h3 id="bash-completion"><a class="header-anchor" href="#bash-completion">¶</a>bash-completion</h3>
<p>软件包<code>bash-completion</code>实现了非常多命令的补全，我们可以阅读这些脚本，学习是如何实现的。在Ubuntu系统，这些脚本在<code>/usr/share/bash-completion/</code>目录下面。</p>
<h3 id="cdwork"><a class="header-anchor" href="#cdwork">¶</a>cdwork</h3>
<p>假如有一个工作目录，期望在任意目录敲<code>cdwork</code>命令，则跳转到工作目录。如果执行<code>cdwork subdir1</code>，则跳转到工作目录下的<code>subdir1</code>子目录。支持<code>任意一级子目录</code>补全，即输入<code>cdwork &lt;tab&gt;</code>时，补全工作目录下的所有子目录。以下实现是参考<code>_cd</code>函数改的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export WORKDIR=&quot;/path/to/work/dir&quot;</span><br><span class="line">function cdwork() &#123;</span><br><span class="line">    cd &quot;$&#123;WORKDIR&#125;/$1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_cdwork()</span><br><span class="line">&#123;</span><br><span class="line">    local cur prev words cword;</span><br><span class="line">    _init_completion || return;</span><br><span class="line">    local IFS=&#x27;</span><br><span class="line">&#x27; i j k;</span><br><span class="line">    compopt -o filenames;</span><br><span class="line">    local -r mark_dirs=$(_rl_enabled mark-directories &amp;&amp; echo y);</span><br><span class="line">    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories &amp;&amp; echo y);</span><br><span class="line"></span><br><span class="line">    k=&quot;$&#123;#COMPREPLY[@]&#125;&quot;;</span><br><span class="line">    for j in $(compgen -d -- $WORKDIR/$cur);</span><br><span class="line">    do</span><br><span class="line">        if [[ ( -n $mark_symdirs &amp;&amp; -L $j || -n $mark_dirs &amp;&amp; ! -L $j ) &amp;&amp; ! -d $&#123;j#$WORKDIR/&#125; ]]; then</span><br><span class="line">            j+=&quot;/&quot;;</span><br><span class="line">        fi;</span><br><span class="line">        COMPREPLY[k++]=$&#123;j#$WORKDIR/&#125;;</span><br><span class="line">    done;</span><br><span class="line"></span><br><span class="line">    _filedir -d;</span><br><span class="line">    if (($&#123;#COMPREPLY[@]&#125; == 1)); then</span><br><span class="line">        i=$&#123;COMPREPLY[0]&#125;;</span><br><span class="line">        if [[ $i == &quot;$cur&quot; &amp;&amp; $i != &quot;*/&quot; ]]; then</span><br><span class="line">            COMPREPLY[0]=&quot;$&#123;i&#125;/&quot;;</span><br><span class="line">        fi;</span><br><span class="line">    fi;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complete -o nospace -F _cdwork cdwork</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>ImmortalWrt软路由安装及配置</title>
    <url>/2025/11/ImmortalWrt/</url>
    <content><![CDATA[<p>记录一下ImmortalWrt的安装方法，以及一些配置。</p>
<span id="more"></span>
<h2 id="镜像下载"><a class="header-anchor" href="#镜像下载">¶</a>镜像下载</h2>
<p>下载地址：<a href="https://firmware-selector.immortalwrt.org/">https://firmware-selector.immortalwrt.org/</a>。根据目标设备选择对应的镜像即可，</p>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<h3 id="VMware虚拟机"><a class="header-anchor" href="#VMware虚拟机">¶</a>VMware虚拟机</h3>
<p>在镜像下载页面搜索<code>Generic x86/64</code>，选择ext4 vmdk镜像下载。当前最新版本<code>24.10.2</code>，查看package，确认kernel版本是6.6。</p>
<p>将下载好的<code>vmdk</code>文件复制到存放虚拟机的文件夹。VMware新建虚拟机，操作系统类型选择<code>其他Linux 6.x 内核 64 位</code>，命名为<code>p73wrt</code>，处理器和内存按需配置。网络选择NAT。磁盘界面选择复制进去的vmdk文件。虚拟机创建好之后直接启动即可。</p>
<p>系统启动之后，如果终端一直在吐log，可以用<code>echo 0 &gt; /proc/sys/kernel/printk</code>关闭log。</p>
<h3 id="树莓派3B"><a class="header-anchor" href="#树莓派3B">¶</a>树莓派3B</h3>
<p>镜像下载页面搜索<code>Raspberry Pi 3</code>，我选择的64位ext4版本。解压后用Win32DiskImage或其他类似工具写入TF卡，插入树莓派启动即可。</p>
<h2 id="基础设置"><a class="header-anchor" href="#基础设置">¶</a>基础设置</h2>
<h3 id="IP地址"><a class="header-anchor" href="#IP地址">¶</a>IP地址</h3>
<p>进入虚拟机终端，编辑文件<code>/etc/config/network</code>，给网卡lan设置IP地址，网段和路由器保持一致。添加网关和dns的配置。网关可以填路由器的地址。最后<code>/etc/init.d/network restart</code>重启网卡。可以ping路由器、<code>8.8.8.8</code>或<code>baidu.com</code>测试网络是否正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lan</span><br><span class="line">	...</span><br><span class="line">	option gateway &#x27;ipaddr&#x27;</span><br><span class="line">	list dns &#x27;dns server&#x27;</span><br><span class="line">	option ipaddr &#x27;ip&#x27;</span><br></pre></td></tr></table></figure>
<p>网络配置好之后，在浏览器输入IP地址，即可进入网页端，默认没有密码。以上关于网络接口的配置，也可以访问管理网页，进入<code>网络-&gt;接口</code>，进入设置。</p>
<h3 id="root密码"><a class="header-anchor" href="#root密码">¶</a>root密码</h3>
<p>shell执行 <code>passwd root</code>，或网页web进入<code>系统-&gt;管理权</code>进行设置。</p>
<h3 id="软件包更新和安装"><a class="header-anchor" href="#软件包更新和安装">¶</a>软件包更新和安装</h3>
<p>immortalwrt 使用opkg管理软件包，所以可以使用opkg安装软件包。也可以访问网页端，进入<code>系统-&gt;软件包</code>，对软件包进行管理。</p>
<h3 id="rootfs扩容"><a class="header-anchor" href="#rootfs扩容">¶</a>rootfs扩容</h3>
<p>安装系统的时候，默认分配了1GB大小的磁盘，但是rootfs最大只有290MB。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ImmortalWrt:~# df -h</span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line">/dev/root               290.4M     42.1M    242.3M  15% /</span><br><span class="line">tmpfs                   991.9M      1.1M    990.8M   0% /tmp</span><br><span class="line">/dev/vda1                31.9M      8.3M     23.6M  26% /boot</span><br><span class="line">/dev/vda1                31.9M      8.3M     23.6M  26% /boot</span><br><span class="line">tmpfs                   512.0K         0    512.0K   0% /dev</span><br></pre></td></tr></table></figure>
<p>安装相关工具的指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">opkg install resize2fs parted losetup fdisk</span><br></pre></td></tr></table></figure>
<p>关闭虚拟机，进入虚拟机设置，把磁盘设置为10GB大小（如果是树莓派，忽略）。启动虚拟机，进入终端，执行<code>fdisk /dev/vda</code>命令，进入交互式界面，敲<code>p</code>查看分区表，确认rootfs分区编号，应该是2。然后输入<code>e-&gt;2</code>，不输入大小，直接回车，用默认的最大值。最后敲<code>w</code>保持退出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Command (m for help): e</span><br><span class="line">Partition number (1,2,128, default 128): 2</span><br><span class="line"></span><br><span class="line">New &lt;size&gt;&#123;K,M,G,T,P&#125; in bytes or &lt;size&gt;S in sectors (default 10G):</span><br><span class="line"></span><br><span class="line">Partition 2 has been resized.</span><br><span class="line"></span><br><span class="line">Command (m for help): w</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>
<p>重启系统，待系统重启成功后，执行 <code>resize2fs /dev/vda2</code>，扩大文件系统。最终效果如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ImmortalWrt:~# df -h</span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line">/dev/root                 9.8G     43.1M      9.8G   0% /</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以参考 <a href="https://blog.csdn.net/2301_81011704/article/details/142636930">https://blog.csdn.net/2301_81011704/article/details/142636930</a> 扩容rootfs。</p>
</blockquote>
<p>如果 rootfs 扩容遇到如下错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ImmortalWrt:~# resize2fs /dev/sda2</span><br><span class="line">resize2fs 1.47.0 (5-Feb-2023)</span><br><span class="line">Filesystem at /dev/sda2 is mounted on /; on-line resizing required</span><br><span class="line">old_desc_blocks = 1, new_desc_blocks = 1</span><br><span class="line">Performing an on-line resize of /dev/sda2 to 2613120 (4k) blocks.</span><br><span class="line">resize2fs: Invalid argument While trying to add group #3</span><br></pre></td></tr></table></figure>
<p>kernel log 如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ImmortalWrt:~# dmesg | grep sda2</span><br><span class="line">[   31.879942] EXT4-fs (sda2): resizing filesystem from 98304 to 2613120 blocks</span><br><span class="line">[   31.880641] EXT4-fs warning (device sda2): reserve_backup_gdb:1052: reserved block 24 not at offset 23</span><br><span class="line">[   31.880945] EXT4-fs warning (device sda2): ext4_resize_fs:2194: error (-22) occurred during file system resize</span><br><span class="line">[   31.881274] EXT4-fs (sda2): resized filesystem to 98304</span><br><span class="line">[   31.883174] EXT4-fs warning (device sda2): reserve_backup_gdb:1052: reserved block 24 not at offset 23</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://github.com/openwrt/openwrt/issues/7729">https://github.com/openwrt/openwrt/issues/7729</a>，拿到如下修复命令。成功修复。如果是虚拟机，分区名字要换成 <code>/dev/sda2</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -o remount,ro / #Remount root as ReadOnly</span><br><span class="line">tune2fs -O^resize_inode /dev/mmcblk0p2 #Remove reserved GDT blocks</span><br><span class="line">fsck.ext4 /dev/mmcblk0p2 #Fix part, answer yes to remove GDT blocks remnants。所有全部选y</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line">resize2fs /dev/mmcblk0p2</span><br></pre></td></tr></table></figure>
<h2 id="webserver-切换到nginx"><a class="header-anchor" href="#webserver-切换到nginx">¶</a>webserver 切换到nginx</h2>
<p>首先停止uhttpd，防止端口冲突。然后安装nginx。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service uhttpd stop &amp;&amp; service uhttpd disable</span><br><span class="line">opkg update &amp;&amp; opkg install nginx-full nginx-mod-luci</span><br></pre></td></tr></table></figure>
<p>nginx的主配置文件是<code>/etc/nginx/uci.conf</code>。这个文件是根据<code>/etc/config/nginx</code>里面的配置生成来的。修改此文件，参考如下。主要修改了第一个server的名字，server_name，证书的文件名，以及包含文件<code>p73wrt.inc.conf</code>。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">config</span> main global</span><br><span class="line">        option uci_enable <span class="string">&#x27;true&#x27;</span></span><br><span class="line"></span><br><span class="line">config server <span class="string">&#x27;_main&#x27;</span></span><br><span class="line">        list listen <span class="string">&#x27;443 ssl default_server&#x27;</span></span><br><span class="line">        list listen <span class="string">&#x27;[::]:443 ssl default_server&#x27;</span></span><br><span class="line">        option server_name <span class="string">&#x27;p73wrt.inc&#x27;</span></span><br><span class="line">        list include <span class="string">&#x27;restrict_locally&#x27;</span></span><br><span class="line">        list include <span class="string">&#x27;conf.d/*.locations&#x27;</span></span><br><span class="line">        list include <span class="string">&#x27;p73wrt.inc.conf&#x27;</span></span><br><span class="line">        <span class="comment"># option uci_manage_ssl &#x27;self-signed&#x27;</span></span><br><span class="line">        option ssl_certificate <span class="string">&#x27;/etc/nginx/conf.d/p73wrt.inc.crt&#x27;</span></span><br><span class="line">        option ssl_certificate_key <span class="string">&#x27;/etc/nginx/conf.d/p73wrt.inc.key&#x27;</span></span><br><span class="line">        option ssl_session_cache <span class="string">&#x27;shared:SSL:32k&#x27;</span></span><br><span class="line">        option ssl_session_timeout <span class="string">&#x27;64m&#x27;</span></span><br><span class="line">        option access_log <span class="string">&#x27;off; # logd openwrt&#x27;</span></span><br><span class="line"></span><br><span class="line">config server <span class="string">&#x27;_redirect2ssl&#x27;</span></span><br><span class="line">        list listen <span class="string">&#x27;80&#x27;</span></span><br><span class="line">        list listen <span class="string">&#x27;[::]:80&#x27;</span></span><br><span class="line">        option server_name <span class="string">&#x27;_redirect2ssl&#x27;</span></span><br><span class="line">        option return <span class="string">&#x27;302 https://<span class="variable">$host</span><span class="variable">$request_uri</span>&#x27;</span></span><br></pre></td></tr></table></figure>
<p>修改完成之后，使用如下命令重启nginx。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch /etc/nginx/p73wrt.inc.conf</span><br><span class="line">uci commit nginx</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>
<p>在<code>p73wrt.inc.conf</code>添加如下内容，禁止IP直接访问。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$host</span> != <span class="string">&#x27;p73wrt.inc&#x27;</span>) &#123;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ol>
<li>安装nginx <a href="https://segmentfault.com/a/1190000044574943">https://segmentfault.com/a/1190000044574943</a></li>
<li>禁止IP访问：<a href="https://zhuanlan.zhihu.com/p/372689544">https://zhuanlan.zhihu.com/p/372689544</a></li>
</ol>
<h2 id="DHCP"><a class="header-anchor" href="#DHCP">¶</a>DHCP</h2>
<p>把主路由的静态IP设置，同步到ImmortalWrt。关闭主路由的DHCP服务，使用软路由分配IP地址。在<code>网络-&gt;DHCP/DNS-&gt;静态地址分配</code>，可以为某台设备设置静态IP地址和标签。注意，如果只设置标签而没有设置固定IP地址，则标签设置不会生效。</p>
<p>dhcp 选项3用于指定网关。关闭主路由的dhcp后，软路由dhcp默认指定的网关是软路由地址，这样局域网内所有的设备都能科学上网了。但是不想所有设备都走代理。关键配置在于设备的网关地址。</p>
<p>经过搜索资料，有两种方式可以做到。黑名单，即默认网关指向软路由（默认走代理），如果某个设备不想走代理，通过设置把网关指向主路由。白名单，即默认网关指向主路由（默认不走代理），如果想让某个设备走代理，通过设置把这台设备的网关指向软路由。这里选择白名单模式。</p>
<p><code>网络-&gt;接口-&gt;点击lan编辑-&gt;DHCP服务器-&gt;高级设置</code>，增加三个DHCP选项，<code>3,192.168.100.1</code>、<code>6,192.168.100.25</code>和<code>tag:outsea,3,192.168.100.55</code>，保存并应用。</p>
<p>DHCP的地址范围在<code>网络-&gt;接口-&gt;点击lan编辑-&gt;DHCP服务器-&gt;常规设置</code>下面，默认是从100开始分配地址。</p>
<p>参考：</p>
<ul>
<li>DHCP协议，<a href="https://zhuanlan.zhihu.com/p/17391337608">https://zhuanlan.zhihu.com/p/17391337608</a></li>
<li>openwrt旁路由dhcp指定主路由网关方法，<a href="https://blog.51cto.com/fxn2025/9836451">https://blog.51cto.com/fxn2025/9836451</a></li>
<li>设置 OpenWrt 指定主机DHCP 获取不同网关DNS，<a href="https://www.right.com.cn/forum/thread-8225205-1-1.html">https://www.right.com.cn/forum/thread-8225205-1-1.html</a></li>
</ul>
<h2 id="DNS"><a class="header-anchor" href="#DNS">¶</a>DNS</h2>
<p>切换lan到inc，<code>网络-&gt;DHCP/DNS-&gt;常规</code>，将<code>本地解析这些项目</code>改成<code>/inc/</code>，<code>本地域名</code>改成<code>inc</code>。这样会自动增加一个<code>&lt;hostname&gt;.inc</code>的域名。</p>
<p><code>选项</code>卡下面的<code>所有服务器</code>，即打开<code>all-servers</code>选项，同时查询所有的上游DNS服务器。询问AI，会导致CPU使用率增加、带宽使用增加、减低缓存命中率。打开之后会提高查询速度，避免DNS劫持。综合考虑，性能优先，打开这个选项。</p>
<p><code>DNS记录</code>选项卡下面可以添加DNS记录，例如A记录、CNAME记录等。图形化界面。但是历史DNS记录比较多，图形化界面不利于重新部署，还是考虑自动化部署。首先将<code>/etc/dnsmasq.d</code>包含到dnsmasq的配置文件中，参考如下命令。最后修改相关自动化脚本，将DNS记录配置文件部署到/etc/dnsmasq.d 下面。。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/dnsmasq.d</span><br><span class="line">uci set dhcp.@dnsmasq[0].confdir=&quot;/etc/dnsmasq.d&quot;</span><br><span class="line">uci commit dhcp</span><br><span class="line">service dnsmasq restart</span><br></pre></td></tr></table></figure>
<p><code>转发</code>选项卡下面的<code>DNS转发</code>可以设置上游DNS服务器地址。可以设置为阿里的公共DNS服务器，<code>223.5.5.5</code>和<code>223.6.6.6</code>。注意，如果安装了openclash插件，clash默认会打开DNS劫持，<code>DNS转发</code>的设置总是会被自动修改成<code>127.0.0.1#7874</code>。建议在<code>服务-&gt;OpenClash-&gt;插件设置-&gt;DNS设置</code>关闭DNS劫持。避免部分网页无法打开。为了访问速度更快，建议使用运营商的dns。主路由拨号时会自动获取运营商的dns，所以这里填主路由IP即可。</p>
<p><code>Resolv和Hosts文件</code>选项卡下面的<code>解析文件</code>，默认也配置了两个上游DNS服务器。默认是文件<code>/tmp/resolv.conf.d/resolv.conf.auto</code>。参考<a href="https://www.openwrt.pro/post-141.html">https://www.openwrt.pro/post-141.html</a>，看起来是netifd自动生成的。</p>
<p>openclash也有设置上游DNS服务器的地方，在<code>服务-&gt;OpenClash-&gt;复写设置-&gt;DNS设置</code>，找到<code>设置自定义上游 DNS 服务器（在上方设置中启用本功能后生效）</code>，有<code>NameServer</code>和<code>Default-NameServer</code>两个选项卡可以配置。这里默认不生效。</p>
<p><code>Resolv和Hosts文件</code>选项卡下面的<code>忽略解析文件</code>，表示打开选项<code>noresolv</code>，忽略<code>/etc/resolv.conf</code>文件。</p>
<h2 id="打开dnsmasq的log"><a class="header-anchor" href="#打开dnsmasq的log">¶</a>打开dnsmasq的log</h2>
<p>修改dhcp和dns的时候，可能遇到问题，这时就需要打开dnsmasq的log进行debug。首先编辑<code>/etc/dnsmasq.conf</code>文件，注释<code>log-facility=/dev/null</code>。然后<code>service dnsmasq restart</code>重启服务。</p>
<p>进入web，进入<code>网络-&gt;DHCP/DNS-&gt;日志</code>，勾选记录查询日志，记录设施选自定义，填<code>/tmp/dnsmasq.log</code>，保存并应用。这时就能在<code>/tmp/dnsmasq.log</code>文件看到相关日志。</p>
<p>调整完成之后，记得关闭log，提高性能。</p>
<blockquote>
<p>如果在web界面打开log后，dnsmasq启动失败。使用命令<code>logread | grep dnsmasq</code>查询启动日志，确认启动失败的原因。</p>
</blockquote>
]]></content>
  </entry>
</search>
